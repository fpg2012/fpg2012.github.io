<site>
    
    
    
    
    
    
    
    
    <page>
        <title>
        
        homepage
        
        </title>
        <url>////nth233.top/index.html</url>
        <search-text>
        
        
        sushi-theme-letter is a theme written for blog generator sushi-gen, created by nth233
        
        
        
        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        404
        
        </title>
        <url>////nth233.top/404.html</url>
        <search-text>
        
        
        
        
        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        KMP实现和笔记
        
        </title>
        <url>////nth233.top/notes/2023-11-13-kmp.html</url>
        <search-text>
        
        
            algorithm
        
            kmp
        
            算法
        
        
        
        
        
## 笔记

![之前手写的笔记](/assets/img/post/kmp-notes.png)

之前的笔记，从自动机开始，推到KMP。如果继续写，可以引入AC自动机。

## 实现

```c
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#define MAXN 100000
#define MAXM 100000

char str[MAXM];
char pattern[MAXM];
int m, n;

int pi[MAXM];

// 计算前缀函数
void compute_pi() {
    int k = 0;
    pi[0] = 0;
    pi[1] = 0;
    for (int i = 2; i &lt;= m; ++i) {
        // 特别注意i-1
        while (k &gt; 0 &amp;&amp; pattern[i-1] != pattern[k]) {
            k = pi[k];
        }
        if (pattern[i-1] == pattern[k]) {
            k++;
        }
        pi[i] = k;
    }
}

void print_match(int index) {
    printf(&quot;%s\n&quot;, str);
    for (int i = 0; i &lt; index; ++i) {
        if (index - i &lt; m) {
            putchar(&#39;-&#39;);
        } else {
            putchar(&#39; &#39;);
        }
    }
    putchar(&#39;^&#39;);
    putchar(&#39;\n&#39;);
}

void print_array(int *arr, int k) {
    for (int i = 0; i &lt; k; ++i) {
        printf(&quot;%d &quot;, pi[i]);
    }
    putchar(&#39;\n&#39;);
}

// 匹配
void find_all_matches() {
    int j = 0;
    // i始终无需减少
    for (int i = 0; i &lt; n; ++i) {
        // 失配，则j回退到pi[j]
        // j最多回退到0
        while (j &gt; 0 &amp;&amp; str[i] != pattern[j]) {
            j = pi[j];
        }
        // 匹配，则j和i都+1
        if (str[i] == pattern[j]) {
            j++;
        }
        if (j == m) {
            printf(&quot;match @ %d\n&quot;, i);
            print_match(i);
            j = pi[m]; // 匹配完成，假装失配
        }
    }
}

int main() {
    printf(&quot;pattern\n&quot;);
    scanf(&quot; %s&quot;, pattern);
    printf(&quot;str\n&quot;);
    scanf(&quot; %s&quot;, str);
    m = strlen(pattern);
    n = strlen(str);
    compute_pi();
    print_array(pi, m+1);
    find_all_matches();
    return 0;
}
```

        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        解决Linux下音频持续输出高频噪声的问题
        
        </title>
        <url>////nth233.top/notes/buzzing.html</url>
        <search-text>
        
        
            note
        
            破事水
        
            linux
        
            音频
        
            噪声
        
        
        
        很可能是在Linux下，声卡默认启用了省电模式，导致其中有电容持续充放电。关闭省电模式即可。
        
        
        
## 原因

很可能是在Linux下，声卡默认启用了省电模式，导致其中有电容持续充放电。关闭省电模式即可。

## 处理

在开始之前，看看用的是哪个声卡，我这里是snd_hda_intel。如果是snd_usb_audio，则下文可能需要做出相应更改。

```
cat /proc/asound/modules
```

首先，检查是不是省电模式，如果输出0，则不是省电模式，请另找原因。

```
cat /sys/module/snd_hda_intel/parameters/power_save
```

然后，如果只需要临时解决，可以往这个文件里面写0：

```
echo 0 &gt; /sys/module/snd_hda_intel/parameters/power_save
```

如果需要永久解决，可以添加配置文件，命名为`audio_disable_powersave.conf`：

```
sudo vim /etc/modprobe.d/audio_disable_powersave.conf
```

添加一行配置：

```
options snd_hda_intel power_save=0
```

搞定。

## 结果

问题缓解了很多，但仔细听还是有极小声的高频噪声（可能我的耳朵比较灵）。

所以平常不用音响的时候还是得把音响的电源关掉。

## 起因以及排查过程

大概一两个月前搬进租屋开始，我就感觉电脑的音响一直在持续地发出高频噪音。这种噪音平时难以察觉，但是当四周特别安静的时候，就会格外恼人。然而我一直找不到导致高频噪音的原因。当时我发现Windows下没有这个问题，因此初步判断和Linux有关，但是加上回声降噪之后并没有解决问题。

最近从租屋搬回家，这一问题居然神秘地消失了。直到今天，我感觉显示器的音频输出驱动能力不够强，把音频线接到了主机上，噪声又出现了。所以我判定噪声和主板的声卡有关，一搜……果然是。

## 参考/解决方法来源

[How I Fixed Buzzing Noise Coming from Speakers in Linux](https://itsfoss.com/buzzing-noise-speaker-linux)

        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        使用Intel Arc A770进行AI画图
        
        </title>
        <url>////nth233.top/posts/2023-09-03-intel-arc-a770-ai.html</url>
        <search-text>
        
        
            intel
        
            AI画图
        
            stable diffusion
        
            显卡
        
            Arc A770
        
        
        
        
        
        
        
&gt; 本文假设读者对Linux、PyTorch有一定的了解，对AI绘画的原理有一定了解。

## 前言

网上对[Intel Arc A770]()的风评不太好，评论基本上都说这张卡“性能不如同等级的N卡“、“驱动不完善”、“未来可期未来买”。但是综合考虑了一下我的需求，我还是决定无视这糟糕的风评，入手这张卡。这卡有几个优点：

1. 16GB显存（同级别的N卡基本上显存都没它大）

2. Linux下驱动支持良好（前提是内核版本6.2+，对比起来，N卡在Linux下用十分痛苦）

3. 没有矿

4. 价格已经初具性价比了，非公版现在只要2000出头，二手应该会更便宜

5. 性能可能确实一般，但是对我而言够用

6. 驱动已经逐渐完善了

7. AV1编码（虽然PR不支持，但是kdenlive支持）

随着Intel在去年发布了Intel Extensions For Pytorch（IPEX），用A770进行机器学习，也并非不可能。

故为了充分利用我手上的这张卡，我打算来试试AI绘图、AI音色替换、自己部署ChatGLM之类的玩法。但正如标题，本文只涉及AI绘图。

## 配置基本环境

我个人使用的环境如下：

```
                   -`                    nth233@lune 
                  .o+`                   ----------- 
                 `ooo/                   OS: Arch Linux x86_64 
                `+oooo:                  Kernel: 6.4.12-arch1-1 
               `+oooooo:                 Uptime: 32 mins 
               -+oooooo+:                Packages: 1503 (pacman), 16 (flatpak) 
             `/:-:++oooo+:               Shell: zsh 5.9 
            `/++++/+++++++:              Resolution: 2560x1440 
           `/++++++++++++++:             DE: GNOME 44.4 
          `/+++ooooooooooooo/`           WM: Mutter 
         ./ooosssso++osssssso+`          WM Theme: Adwaita 
        .oossssso-````/ossssss+`         Theme: Adwaita [GTK2/3] 
       -osssssso.      :ssssssso.        Icons: Adwaita [GTK2/3] 
      :osssssss/        osssso+++.       Terminal: kgx 
     /ossssssss/        +ssssooo/-       CPU: AMD Ryzen 5 5600G with Radeon Graphics (12) @ 3.900GHz 
   `/ossssso+/:-        -:/+osssso+-     GPU: AMD ATI Radeon Vega Series / Radeon Vega Mobile Series 
  `+sso+:-`                 `.-/+oso:    GPU: Intel DG2 [Arc A770] 
 `++:.                           `-/+/   Memory: 3503MiB / 15275MiB 
 .`                                 `/
```

其中有几个要点：

1. 用Linux或WSL2。Windows我没有尝试过，因此请参照官方文档。

2. **确保内核版本 &gt;= 6.2**（目前Arch Linux的lts内核还只是6.1）

IPEX只支持Ubuntu 22.04，但是实测用Arch Linux应该也没问题。如果求稳，可以用Docker。建议第一次尝试使用Docker，比较省心。

&gt; 确保内核版本足够高，这点特别重要！

安装intel oneapi相关的工具。

```
# pacman -S intel-compute-runtime-bin intel-oneapi-basekit intel_gpu_tools
```

`intel_gpu_tools`提供了`intel_gpu_top`这类工具，可以比较方便地查看显卡的占用情况。

似乎安装以上的包就已经足够了。但为了以防万一，确保读者可以复现，我这里列出我安装的所有和intel有关的包。

```
$ pacman -Qs intel

local/intel-compute-runtime-bin 23.22.26516.18-1
    Intel Graphics Compute Runtime for oneAPI Level Zero and OpenCL Driver (pre-compiled binaries)
local/intel-gpu-tools 1.27-2
    Tools for development and testing of the Intel DRM driver
local/intel-graphics-compiler-bin 1:1.0.14062.11-1
    Intel Graphics Compiler for OpenCL (pre-compiled binaries)
local/intel-media-driver 23.3.1-1
    Intel Media Driver for VAAPI — Broadwell+ iGPUs
local/intel-oneapi-basekit 2023.2.0.49397-1
    Intel oneAPI Base Toolkit for Linux
local/libmfx 23.2.2-2
    Intel Media SDK dispatcher library
local/libva-utils 2.19.0-1
    Intel VA-API Media Applications and Scripts for libva
local/onetbb 2021.9.0-1
    High level abstract threading library (oneAPI Threading Building Blocks)
local/openimagedenoise 1.4.3-1
    Intel(R) Open Image Denoise library
local/openpgl 0.5.0-5
    Intel Open Path Guiding Library
local/vulkan-intel 1:23.1.6-4
    Intel&#39;s Vulkan mesa driver
```

### 使用Docker

首先，安装Docker，并且启用docker服务。

```
# pacman -S docker
# sudo systemctl start docker
```

拉取Intel官方的docker映像（image）

```
# docker pull intel/intel-extension-for-pytorch:xpu-flex-2.0.110-xpu
```

运行映像。

```
# docker run --rm -it --privileged --device=/dev/dri --ipc=host &lt;image_name&gt;:&lt;tag&gt; bash
```

然后检查一下是否能跑。在docker里运行以下代码，看能否正确输出IPEX的版本、显卡设备的信息。

```
$ python -c &quot;import torch; import intel_extension_for_pytorch as ipex; print(torch.__version__); print(ipex.__version__); [print(f&#39;[{i}]: {torch.xpu.get_device_properties(i)}&#39;) for i in range(torch.xpu.device_count())];&quot;
```

到此为止，环境就配好了。

### 不使用Docker

确保安装了Python 3.11和对应的`python-pip`。

`cd`到一个合适的地方，然后创建Python虚拟环境，随后启用虚拟环境。

```
$ cd ~/workspace/intel_draw
$ python -m venv venv
$ source ./venv/bin/activate
```

到下载Python 3.11对应版本的PyTorch、torchvison和IPEX的whl文件。截至9月3日，是下面这三个。

```
torch-2.0.1a0+cxx11.abi-cp311-cp311-linux_x86_64.whl
torchvision-0.15.2a0+cxx11.abi-cp311-cp311-linux_x86_64.whl
intel_extension_for_pytorch-2.0.110+xpu-cp311-cp311-linux_x86_64.whl
```

然后一一使用`pip`装到虚拟环境中。

```
$ pip install torch-2.0.1a0+cxx11.abi-cp311-cp311-linux_x86_64.whl
$ pip install torchvision-0.15.2a0+cxx11.abi-cp311-cp311-linux_x86_64.whl
$ pip install intel_extension_for_pytorch-2.0.110+xpu-cp311-cp311-linux_x86_64.whl
```

然后，配置必要的环境变量。Intel提供了一个脚本，我这里是在`/opt/intel/oneapi`下面，执行这一脚本即可。之后每次使用IPEX前，都要先执行这一脚本。

```
$ source /opt/intel/oneapi/setvars.sh
```

然后运行以下代码，看能否正确输出IPEX的版本、显卡设备的信息。

```
$ python -c &quot;import torch; import intel_extension_for_pytorch as ipex; print(torch.__version__); print(ipex.__version__); [print(f&#39;[{i}]: {torch.xpu.get_device_properties(i)}&#39;) for i in range(torch.xpu.device_count())];&quot;
```

&gt; 如果需要使用Python 3.10或者更老的版本，可以conda创建虚拟环境，同时环境时指定Python版本。
&gt; 
&gt; ```
&gt; conda create -n intel_draw python==3.10.13
&gt; ```
&gt; 
&gt; 启用这个刚刚创建的`intel_draw`环境，然后再从头开始配置环境。注意Python 3.10对应的`whl`文件和3.11不同，注意检查。

到此为止，基本的环境就配好了。

## 配置ComfyUI

Stable Diffusion WebUI虽然是最流行的WebUI，但它的没有直接支持Intel独显。虽有几个fork支持Intel独显，但是更新不如原项目勤快。所以我还是选择把intel独显支持整合进主分支的ComfyUI。

&gt; 其实也可以不使用任何的WebUI，直接自己手动调用模型，可能还更简单一些。

把comfyui的仓库克隆到本地。这里是放在`~/workspace/ComfyUI`

```
$ git clone https://github.com/comfyanonymous/ComfyUI
```

然后启用刚才配置好的基本环境。

&gt; 如果使用的是docker，启动容器的命令要添加几个选项。如下（注意根据自己的实际情况进行改动）：
&gt; 
&gt; ```
&gt; # docker run --rm -it -v /home/nth233/workspace/ComfyUI:/opt/sd -p 8188:8188 --privileged --device=/dev/dri --ipc=host &lt;image_name&gt;:&lt;tag&gt; bash
&gt; ```
&gt; 
&gt; `-v`是把我们刚刚克隆下来的ComfyUI的代码映射到docker容器中。`-p`是为了之后能够访问容器中运行的ComfyUI服务端，进行端口映射。

安装ComfyUI所需的基本依赖，在`~/workspace/ComfyUI`（如果使用docker，按照上面的命令启动，那么是`/opt/sd`）下，执行：

```
$ pip install -r requirements.txt
```

然后就可以启动ComfyUI了。

```
$ python main.py --listen 0.0.0.0 --use-split-cross-attention
```

然后可在浏览器中打开`localhost:8188`，即可看到ComfyUI。

## 下载模型

目前比较流行的是Stable Diffusion 1.5，因此我们以此为例。

从[huggingface](https://huggingface.co/runwayml/stable-diffusion-v1-5)上下载Stable Diffusion 1.5的checkpoint（如图）。下载完之后，放到`ComfyUI/models/checkpoints`下。

![Stable Diffusion 1.5 safetensors](/assets/img/post/sd-ckpt.png)

读者还可以根据需要，下载其他模型的checkpoint放进来选用。如果有需要，还可以上civitai上下载各种各样的LoRA模型，放到`lora`文件夹下面。ControlNet同理

然后，参考ComfyUI的文档和示例，就可以开始画图了。

## 结果

结果还行。但是似乎画图速度不算太快。但是不知是什么原因，intel这卡没法长宽太大的图，如果需要生成大图，可以考虑先生成小图，然后其他的模型超分辨率到高清大图。

&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=787658335&amp;bvid=BV1214y1171Z&amp;cid=1246931591&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; style=&quot;width: 100%;aspect-ratio: 1920/1080;&quot;&gt; &lt;/iframe&gt;

## 参考

[IPEX文档](https://intel.github.io/intel-extension-for-pytorch/xpu/latest/tutorials/installations/linux.html)

[I 卡也要炼！本地运行 Stable Diffusion &amp; ComfyUI](https://kwaa.dev/stable-diffusion)

[ComfyUI](https://github.com/comfyanonymous/ComfyUI)

        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        Plans - 开坑计划
        
        </title>
        <url>////nth233.top/plan/index.html</url>
        <search-text>
        
        
            plan
        
        
        
        
        
# 短期内完成

- [ ] Intel Arc A770使用体验
- [ ] 毕业杂记
- [ ] 八月总结
- [ ] 掌阅Smart Air体验报告
- [ ] 《希腊史》笔记
- [ ] 《罗马帝国衰亡史》编节版笔记

# 博客优化

1. 简单的搜索功能（添加`search.xml`和相关的js）
2. 自动生成目录（方案一：用pandoc-filter生成；方案二：在前端用js生成）
3. 更丰富的侧边栏
4. 图片懒加载、渐进加载
5. 扩展markdown语法（加入可折叠的引用框、warning、error等等）（使用pandoc-filter可以比较容易地实现）
6. 编写自用的markdown解析器加速页面渲染速度
7. 加密内容
8. 优化列表的css（现在缩进似乎太多）

# 长期准备

- [ ] 自制方向键盘（STM32或ESP32)
- [ ] Vulkan Tutorial总结
- [ ] 《动物农场》笔记
- [ ] 哈尔变换笔记

        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        评论系统迁移至utterances
        
        </title>
        <url>////nth233.top/posts/2023-08-17-utterances.html</url>
        <search-text>
        
        
            瞎写
        
            blog
        
        
        
        
        
先前博客一直在使用valine作为评论系统。一直以来运行“良好”，我始终没察觉到它的问题，毕竟除了我自己没有人会来这里评论。

但是今年情况发生了变化。我那篇《Hyprland的配置》的文章下出现了本站第一条游客评论，但因为Valine没有邮件提醒的功能，我没有在5月份那条评论出现的第一时间看到它。等到我回复的时候，我想评论主已经不会回头来访问本站了。

另外valine还存在较为严重的安全性问题，我之前一直没有注意到。

为了替换掉valine，我先后尝试了几个评论系统：

1. remark42
2. isso
3. utterances

remark42和isso都是自部署的评论系统。remark42效果不错，但是必须要确保服务器的域名和博客网站的域名相同才能使用GitHub登陆，这一点我无法满足。isso较remark42简单很多，但是可扩展性太差，无法修改邮件模板，导致邮件统统被识别为spam，无法发送，这点我无法容忍。

故最后还是使用了utterances。utterances使用github的issue作为评论区，省去了一大堆麻烦的配置和部署。utterances的缺点是会申请“act on your behalf”的权限，无法保证一定不会出现安全性问题。**如果您不信任utterances，可以直接到对应的issue（标题为页面的相对路径，可以参考issues中现有的issue）进行评论，避免授权给utterances**。

------

这里要向《Hyprland的配置》一文下的评论游客道歉，我更换了评论系统，原先的评论也就不再显示，我的回复您也看不到了。

        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        《神秘岛》
        
        </title>
        <url>////nth233.top/posts/2023-07-24-《神秘岛》/index.html</url>
        <search-text>
        
        
            瞎写
        
            读书笔记
        
            神秘岛
        
            科幻
        
            凡尔纳
        
        
        
        
        
![小说早期版本的封面](./Untitled.jpeg)

《神秘岛》是凡尔纳科幻三部曲（《格兰特船长的儿女》《海底两万里》《神秘岛》）的最后一部，出版时间最晚，剧情时间也最晚，为三部曲画上了一个精致的句号。在三部曲中，《神秘岛》的名气似乎远远不如《海底两万里》，也不如凡尔纳《气球上的五星期》《地心游记》等作品，有点可惜。我个人认为本作精彩程度不在《海底两万里》之下。

本书作者凡尔纳无需我多言——科幻小说的鼻祖。他写下的不少内容已经成为现实，但即使这样，我始终不觉得他的作品过时。每当翻开凡尔纳的小说，我总是能感受到鲜活的想象力、凡尔纳本人宏大的知识储备、以及蒸汽时代对新鲜事物的那种乐观精神。这种乐观精神是现在的小说所不具有的——就好比后世无法复刻唐诗的“盛唐气象”，要想感受这种乐观精神，只能到早期的科幻作品中体会了。凡尔纳始终是我最喜欢的科幻作家，我看的第一本科幻小说也正是凡尔纳的《海底两万里》。之后我把《海底两万里》读了一遍又一遍，小学时最终可能看了不下十遍，不敢说“常读常新”，但至少每次阅读都欣喜如初。

第一次阅读《神秘岛》大约是在小学五年级时，当时直接一口气从头读到了尾，早晨翻开，下午合上，就看完了。紧接着我又读了一两遍。当年我觉得《神秘岛》在三部曲中远胜《海底两万里》（最近读完之后我感觉并没有“远胜”）。在这种“童年滤镜”的加持之下，我今年2月又找了《神秘岛》的电子书放到了kindle上，想找回童年时的那种快乐。但这次断断续续到4月中旬才看完。

我认清了一个事实：我的心态发生了变化，周围环境也发生了变化，不再拥有童年时不断挖掘新鲜感的超能力了。这次阅读去掉了我的“童年滤镜”，让我觉得《神秘岛》没有以前那么精彩。但因为看得比较仔细，也整理出了一些以前没发现的信息。

本文本应于四月底完成（和三四郎的那篇同时），但因为完美主义强迫症（我想要重画出一张中文版的神秘岛地图），加上毕设/毕业等各种琐事缠身导致我缺少连续的自由时间，迟迟未能动笔，一直拖到了毕业回家之后才开始着手准备。现在离入职没剩几天了，决不能再拖延，否则又要和我的众多想法一样不了了之了。

## 人物简介

赛勒斯·史密斯：博学的工程师，完美体现“知行合一、经世致用”八个字，废奴主义者。主角团的带头者。【特长：博学多识的实干家】【性格：坚定、仁善、冷静】【马萨诸塞人】

纳布乔多诺索（简称纳布）：赛勒斯忠诚的仆人，先前是个黑奴，被赛勒斯解放。【特长：厨艺】【性格：天真】【马萨诸赛人】

热代尔·斯皮莱：《纽约先驱报》战地记者，曾为了第一时间向报社传回消息，占用电报线发《圣经》若干小时。【特长：速记、观察力】【性格：坚毅】

彭克罗夫：水手。常常起活跃气氛的作用。【特长：航海，健壮】【性格：急躁】【北方人】

哈伯·布朗：14岁少年，水手的船长留下的孤儿，具有博物学家的潜质。【特长：博物学】【性格：天真，坚强】【新泽西人】

托普：赛勒斯忠诚的爱犬，敏捷又聪慧。

艾尔通：《格兰特船长的儿女》中的人物，因背叛格兰特船长和格里那凡爵士等人被流放到塔波岛上悔罪。

## 情节梗概

故事开始于南北战争期间。赛勒斯作为北军参战，斯皮莱随北军报道，二人被俘于南方“首都”里士满，两人互相仰慕，相见恨晚。彭克罗夫和哈伯前往里士满办事，不料里士满被北军的李将军围困。纳布得知主人被俘，连夜从马萨诸撒潜入里士满。主角5人在里士满相会，密谋利用气球和风暴天气逃出被围困的里士满。

5人成功利用气球逃出了里士满，但不料风暴将他们带到了太平洋。气球坠毁时，5人正好到达一篇陆地。工程师之外的4人成功在**安全岛**下气球，赛勒斯被巨浪冲向北边，托普前去救援，也不知所踪。

4人相互扶持，成功找到一个庇护所和食物，度过了第一晚。第二天，众人尝试寻找赛勒斯，未果。第二晚，狂风交加，托普突然出现。众人跟随托普在**山洞**中找到赛勒斯。赛勒斯对自己在山洞中获救感到不解。

有了赛勒斯，众人在岛上的生活步入正轨，并逐渐有了归属感。先是在赛勒斯的带领下对岛屿进行了一番简单的勘探，登上岛上的**火山**，为岛屿上的各处地点和岛屿本身命名。然后从头干起：制砖、制陶、炼铁、制造硝化甘油炸药、搭建**花岗岩宫**住所、测算岛屿的位置、搭建**畜栏**、种植小麦、制衣、造船、狩猎、建磨坊、架电报。一切都十分顺利，每当众人陷入困境时，总会阴差阳错地得救。

众人收服了一只黑猩猩，命名为“于普”。众人在海上发现了一个箱子，里面是枪支、书籍、地图、工具等重要的补给。里面有本圣经，赛勒斯发现其中一句话被特地标注了：

&gt; 只要祈求，便能得到；只要寻找，便能发现。
&gt; 

在第二年，在船下水时**，**众人收到漂流瓶，告知临近的塔波岛有人。于是彭克罗夫等人驾“乘风破浪号”前往，带回已经如同野人的艾尔通。艾尔通已经悔罪，但仍然十分自责，不愿与5人交流，只是默默干活。

第三年，遭到海盗袭击，海盗船被神秘力量突然摧毁。部分海盗流落上岛，造成极大破坏，乘风破浪号被毁。众人一度处于险境，但屡屡得救。

第四年，赛勒斯终于知道了屡屡得救的原因——尼摩船长一直在暗处为他们保驾护航。林肯岛是鹦鹉螺号的休整点。在神秘岛第四年时，尼摩的同伴几乎已经悉数去世，潜艇也因地形改变的原因无法开出林肯岛水下了。尼摩获知岛上有5个善良、正直的人不幸落难于此，从一开始便暗中帮助，他时而跟踪，时而在花岗岩洞的深井里偷听，伸手众人品质的感动。临终前，尼摩船长通过电报，呼唤赛勒斯等人登上鹦鹉螺号。此时的尼摩船长已经奄奄一息、行将就木了。众人感激之余履行了尼摩的遗嘱：将鹦鹉螺号连同尼摩自己沉入深海。尼摩去世前密告赛勒斯，林肯岛随时可能沉没。

果然，不久后，火山爆发，岩浆改道。众人于是加紧造船工作，只可惜功亏一篑，在船只即将下水前，岛屿爆炸，摧毁了一切，只留下一块礁石，岛上生物连同于普在内全数死亡，6人侥幸存活。一天后，格里那凡爵士驾驶“邓肯号”前来，救走6人。于是6人登船后回到美国，用尼摩馈赠的财报在艾奥瓦州购置了一篇土地，命名为林肯岛。

&gt; 史密斯等人在这儿非常幸福，他们仍旧像患难之时一样地团结一致。不过，他们谁都无法忘记那座海上孤岛。他们刚落在它上面时，什么都没有了，是地地道道的落难者，但是在整整四个年头中，是林肯岛保证了他们的生活所需。可是现在，原先的那座美丽的孤岛已不复存在，只是一块任由风吹浪打的花岗岩礁石，只是一个曾经名为尼摩船长的神秘人物的坟墓了。
&gt; 

## 林肯岛地图

~~虽然已经在笔记本上画好了，但是最近暂时实在没有时间绘制成矢量图，干脆过后再补充。~~

由于林肯岛的中文地图很难找，所以我根据网上流传的地图[A](https://en.wikipedia.org/wiki/The_Mysterious_Island#/media/File:Ile_Mysterieuse_03.jpg)、[B](https://commons.wikimedia.org/wiki/Category:Maps_of_The_Mysterious_Island#/media/File:Isla_de_Lincoln.jpg)、[C](https://www.reddit.com/r/books/comments/1hcnfi/a_highdefinition_color_english_map_of_lincoln/)、[E](https://www.pinterest.com/pin/6966574416461437/)，重绘了一张中文的林肯岛地图。

![林肯岛地图.svg（By nth233） CC BY-SA 4.0](./map.svg)

如果有诸如字体错误等问题，可以查看[PNG版本](./map.png)

![林肯岛地图.png（By nth233） CC BY-SA 4.0](./map.png)

&gt; 注：上面两张地图按照CC BY-SA 4.0协议共享，即转载时需标明出处（原作者署名），同时必须以相同方式共享。不限制对该作品的演绎和商用。
&gt; 
&gt; &lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-sa/4.0/&quot;&gt;&lt;img alt=&quot;Creative Commons License&quot; style=&quot;border-width:0&quot; src=&quot;https://i.creativecommons.org/l/by-sa/4.0/88x31.png&quot; /&gt;&lt;/a&gt;&lt;br /&gt;This work is licensed under a &lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-sa/4.0/&quot;&gt;Creative Commons Attribution-ShareAlike 4.0 International License&lt;/a&gt;.

![法文地图](./Isla_de_Lincoln.jpg)

我们可以对照一下原文：

&gt; 该岛轮廓确实如此，知道这一点是很有必要的。记者所画之图十分精确。
&gt;
&gt; 海岸东部形成一个宽阔的海湾，遇险者们正是从这儿登上海岛的。东南尽头是一个突出的海角，东北方向另有两个海角围绕着海湾，两海角之间是一个海峡，看起来像狗鲨半张开的嘴。从东北到西北，海岸呈弧形，然后，地势逐渐走高，隆起。海岛中央就是火山。从这隆起处开始，海岸从南到北比较平直，在三分之二的地方有一条狭窄小河，把海岸割开。从这儿往南，海岸变得细长，犹如一条鳄鱼的尾巴。这条鳄鱼尾巴形成一个真正的半岛，从前面所说之东南角起，向大海中延伸有三十多英里，顶端弯曲，形成一宽阔锚地，是该岛的低海岸。它最窄的地方就是“壁炉”到与它同纬度的西海岸的小河，只有十英里，而其最长距离，亦即从东北的狗鲨嘴角到西南的尾端，有三十余英里。海岛内陆，从高山至海滨的整个南部地区，林木众多，而北部地区则干旱多沙地。在火山和东海岸之间，他们意外地发现了一个湖。湖边绿树环绕。从高处望去，此湖似与大海处于同一海拔高度，但工程师略加考虑，认为海拔高度有三百英尺，因为它处于海岸高地的延伸部分。
&gt;
&gt; “这是淡水湖吗？”水手问。
&gt; 
&gt; “应该是的，”工程师回答，“湖水是从山里流出来的。”
&gt; 
&gt; “看呀！有一条小河流进湖里。”哈伯指着一条小溪说。小溪显然是从西面山梁支脉流下来的。
&gt; 
&gt; “既然这条小溪向湖里供水，”工程师说，“那么，靠海的地方就一定有一个溢流口，湖水太满时，可以从口子溢出。我们返回时可以去看一看。”
&gt;
&gt; 这条小溪与前面所说的那条河形成小岛的水系。但占该岛三分之二面积的森林下面，可能也有河流流入大海，这是根据此处长有那么多的温带植物而做出的判断。在海岛北部，似无河水。位于东北部的沼泽地也许有一些死水。此外，沙丘、沙滩和显而易见的干旱与岛上大部分地区的草肥林美形成强烈的反差。
&gt; 
&gt; 火山没在岛中心，而是立于西北部，好似两个地区的分水岭。在西南、正南和东南，山梁支脉末端为青翠草木所掩映，但在北边，山的分支明显地延伸到海滩。火山喷发时，熔岩从这儿流过，形成一条宽阔的熔岩流，直伸至形成东北海湾的峡口。他们在火山顶上观察了足足有一个钟头。呈现在他们面前的海岛色彩斑斓，绿绿的森林、黄黄的沙地、蓝蓝的海水。他们对海岛的概貌已基本有数了。
&gt; 
&gt; 现在，还有一个重要问题必须弄清：岛上有人吗？他们没见任何地方有人的痕迹：没见幢幢房舍，没见孤立小屋，没见渔场，没见炊烟。
&gt; 
&gt; 
&gt; ……
&gt; 
&gt; “我看这样吧，”史密斯见大家你一言我一语地取了不少名字，最后说道，“我们把东面的那个大海湾叫作‘联合湾’，把南面的那个叫作‘华盛顿湾’，把我们现在所在的山称作‘富兰克林山’，山下的那个湖叫‘格兰特湖’……这些名字能让我们想起我们的国家以及那些为国增光的伟大公民。有些地方可以根据地形来取名，尚待发现的地方，以后随时再取，大家意下如何？”史密斯的建议得到朋友们的一致赞同。于是，大家又你一言我一语地把伸向西南边的半岛称作“盘蛇半岛”，末端的弯弯的尾巴称作“爬虫角”；把另一端的海湾称作“鲨鱼湾”，把“鲨鱼”的嘴部称作“颌骨角”，因为有两个海角，故而分别称作“北颌骨角”和“南颌骨角”；把东南边的海角，也就是联合湾的顶端称作“爪角”，而那条为大家提供淡水的河被称作“慈悲河”；这些遇险者最初着陆的那个小岛被称作“安全岛”；“壁炉”上方高耸着的花岗岩峭壁，顶端是一高地，可以对整个大海湾一览无余，所以被称作“眺望岗”；覆盖整个盘蛇半岛的密林被称作“远西森林”。
&gt;
&gt;  命名工作暂告一段落，斯皮莱一一记在他的笔记本上。
&gt;
&gt; 至于海岛的方位，工程师打算等准确地测定了海岛的正北方向之后，再做记录。
&gt; 
&gt; 一切都弄完了，众人正待走下富兰克林山返回“壁炉”，突然彭克罗夫大声嚷道：“啊，怎么搞的！我们怎么把我们的岛给忘了，没给它取个名字！”哈伯正想建议以史密斯先生的名字为之命名，可工程师立即表示道：“朋友们，我们就用一位伟大的公民的名字来命名它吧。此人现在正在为保卫美利坚合众国的统一而斗争，所以我们就把我们的这个岛称为‘林肯岛’吧！”
&gt; 

## 时间线整理

我在整理时间线时发现有几处矛盾，可能时翻译问题，也有可能是电子书制作时的错误，不排除凡尔纳原作就是这样的，我没有验证。

| 年份 | 日期 | 事件 | 备注 |
| --- | --- | --- | --- |
| 1865 | 3.20 | 逃离里士满 |  |
|  | 3.23 | 气球在大洋上空漏气 |  |
|  | 3.25 | 到达林肯岛 |  |
|  | 3.26夜 | 找到赛勒斯 |  |
|  | 3.29暮 | 赛勒斯判断处于小岛 |  |
|  | 3.30晨 | 确认处于小岛 |  |
|  | 4.6 | 制砖 |  |
|  | 4.15 | 制陶 | 林肯遇刺 |
|  | 4.16 | 复活节，完成岛的定位 |  |
|  | 4.17 | 炼铁准备 |  |
|  | 4.20 | 采矿 |  |
|  | 4.21 | 得到生铁 |  |
|  | 4.25 | 得到铁锭，制成铁器 |  |
|  | 5.5 | 冶金终止 |  |
|  | 5.7 | 找到格兰特湖溢流口 |  |
|  | 5.8 | 着手制作炸药 |  |
|  | 5.18 | 制得硫化铁等物质 |  |
|  | 5.20 | 制得硝酸和硝化甘油 |  |
|  | 5.21 | 炸开瀑布，格兰特湖水面下降，溢流口露出 |  |
|  | 5.22 | 入住花岗岩宫 |  |
|  | 6.29 | 气温骤降，入冬 |  |
|  | 7.5 | 慈悲河封冻 |  |
|  | 8.15 | 暴雪 |  |
|  | 8月底 | 暂时转暖，发现猫科动物踪迹。炼糖 |  |
|  | 10.24 | 捕获野猪，但是小野猪里有子弹 |  |
|  | 10.29 | 小船下水，发现尼摩的补给 |  |
|  | 10.31 | 到达瀑布河口，发现竹子 |  |
|  | 11.1 | 找到气球残骸，位置命名为气球港 |  |
|  | 11.2 | 回到花岗岩宫，发现被猴子占领，收服于普 |  |
|  | 11.20 | 慈悲桥完工，收麦 |  |
|  | 11.21 | 开凿甘油河 |  |
|  | 12.23 | 收服野驴 |  |
| 1866 | 3.14 | “周年” | 此处时间线有误 |
|  | 3.17 | 水里升降机投用 |  |
|  | 3.28 | 吹制玻璃器皿 |  |
|  | 4.1 | 意识到塔波岛存在，决心造船 |  |
|  | 4.15 | 第二季收麦 |  |
|  | 5.1 | 发现烟草 |  |
|  | 5.30 | 彭克罗夫终于抽到烟 |  |
|  | 6.20 | 入冬，造船中止 |  |
|  | 6.30 | 信天翁到达，用于送信 |  |
|  | 8.3 | 工程师下花岗岩宫的井，但没有发现异常 |  |
|  | 8.12 | 狐狸袭击，于普受伤 |  |
|  | 9.15 | 船甲板完工 |  |
|  | 10.10 | 新船下水，命名为“乘风破浪号”，发现漂流瓶，得知塔波岛上有人 |  |
|  | 10.13 | 斯、彭、哈三人抵塔波岛 |  |
|  | 10.20 | 哈伯遭到艾尔通袭击 |  |
|  | 10.18夜 | 三人迷失方向前，尼摩点亮篝火引路 |  |
|  | 11.3 | 艾尔通终于开口 |  |
|  | 11.15 | 第三季小麦 |  |
|  | 12.1 | 风磨完工，得到面粉 |  |
|  | 12.20 | 艾尔通入住畜栏新居 |  |
| 1867 | 2.12 | 电报机落成 |  |
|  | 4.25 | 工程师盘点岛上怪事 |  |
|  | 10.17 | 遭到海盗袭击 |  |
|  | 10.18 | 海盗船神秘沉没 |  |
|  | 10.19-10.20 | 收拾沉船物资 |  |
|  | 11.6 | 阿龙纳克斯登船 | 《海底两万里》* |
|  | 11.8 | 炮台完工 |  |
|  | 11.11 | 夺回畜栏，哈伯中弹，被围困 |  |
|  | 11.29 | 敌人占领眺望岗 |  |
|  | 12.6 | 哈伯高烧 |  |
|  | 12.8 | 尼摩送奎宁 | 冲突 |
| 1868 | 2.19 | 尼摩救艾尔通。工程师基本确认了保护者的存在 | 冲突 |
|  | 2.25 | 返回花岗岩宫 |  |
|  | 3.25 | 三周年 |  |
|  | 5.15 | 船龙骨完工 |  |
|  | 6.10 | 入冬，终止造船 |  |
|  | 8月 | 阿龙纳克斯离开鹦鹉螺号 | 《海底两万里》* |
|  | 9.7 | 火山首次出现爆发迹象 |  |
|  | 10.15 | 尼摩发电报。发现达卡洞，见到尼摩 |  |
|  | 10.16 | 尼摩逝世，随鹦鹉螺号沉入深海 |  |
| 1869 | 1.3 | 火山喷发 |  |
|  | 1.8 | 工程师确认林肯岛将消失 |  |
|  | 1.23 | 火山剧烈喷发。船甲板尚未完工 |  |
|  | 3.3 | 船几乎完工，再过10余天便可下水 |  |
|  | 3.8 | 众人登船（未完工），林肯岛毁灭 |  |
|  | 3.24 | 邓肯号到达，众人得救 |  |

*稍加验证就能知道，海底两万里和神秘岛的时间线是冲突的，因为尼摩和鹦鹉螺号同时出现在两处。如果把海底两万里的时间整体往前挪一年，似乎可以避免时间上的冲突。或者说……有两个尼摩船长、两艘鹦鹉螺号？总结一下有几种可能性：

1. 凡尔纳搞错了时间线
2. 尼摩船长和鹦鹉螺号有两个
3. 送奎宁、救艾尔通的人不是尼摩

我倾向于认为是第一种情况——凡尔纳或者其出版商搞错了时间线。

## 神秘岛为何“神秘”

书名叫做神秘岛，但我童年阅读时始终不觉得神秘岛对5人主角团来说有多神秘。在赛勒斯的带领下，神秘岛几乎没有什么秘密可言，他们详细地勘探了岛屿，也推测了岛屿的成因，测定了岛屿的位置，最后还见到了尼摩船长。在博学的赛勒斯看来，神秘岛的一切自然现象似乎都有合理的科学解释，没有什么神秘之处。

但其实凡尔纳特意留了一条线索，只不过我以前一直没有注意。凡尔纳特意突出了众人经历中的一些特殊事件，特地强调了他们在千钧一发之时得救的经历。神秘的不是这个不在地图上标注的无人岛，而是尼摩船长在暗处的种种支援。尼摩做了这些事情，在5人眼里看起来仿佛像是上帝显灵：

1. 把赛勒斯救到山洞里
2. 托普下水捕捉儒艮时用水流托起托普，托普此时已经知道尼摩船长的存在了
3. 在花岗岩宫的井底偷听众人的谈话，被托普和于普发现
4. 在小船下水时送来一箱物资，并且在圣经上标注了“只要祈求，便能得到；只要寻找，便能发现。”这句话
5. 在花岗岩宫被猴子占领时，帮忙放下绳梯
6. 帮助众人打猎，把子弹打进小猪体内
7. 在大船下水时送来漂流瓶
8. 在斯皮莱、彭克罗夫、哈伯三人返航时点亮篝火引路
9. 布置水雷炸沉海盗船
10. 在众人被围困、哈伯高烧时送来救命的奎宁
11. 在艾尔通被囚禁昏迷的时候解救艾尔通，杀害海盗，把艾尔通送回畜栏

在尼摩终于无法掩饰自己的存在时，他接通了达卡洞到畜栏的电报线，告知史密斯火山即将爆发、毁灭林肯岛的重要信息。尼摩还悄悄前往塔波岛，写好一封信，以便格里那凡等人能够及时赶往林肯岛，到生命终结后仍然在保护这些落难者。

工程师赛勒斯虽然信教，但是绝不迷信神秘力量，也不愿意轻信“奇迹”的发生，他骨子里认为所有的现象都应该有合理的科学解释，对他而言林肯岛的神秘不在于自然现象，而在于神秘“守护神”的存在。凡尔纳行文中多次强调工程师的疑虑，不断提示尼摩船长这一条暗线，这才是神秘岛的神秘之处。

尼摩的存在让整个故事性质发生了微妙的变化。我原本以为神秘岛是一群人从头干起，从什么也没有到自给自足。但事实并非如此，如果没有尼摩船长在背后暗中支援、暗中引导，赛勒斯一行人根本无法在神秘岛生存。说到底，众人能够在林肯岛站稳脚跟，虽然自力更生十分重要，但归根结底靠的还是运气和尼摩的恩惠——这让整个故事变得更加合理，但不那么振奋人心了。神秘岛丰饶的物产以及赛勒斯的博学为尼摩最大限度地隐身提供了条件，尼摩不需要像《海底两万里》里面那样直接出面相救，他只需要给予少量必要的援助，就可以拯救赛勒斯等人的命运。

## 杂谈

### 尼摩船长

从《海底两万里》到《神秘岛》，我想尼摩船长代表了凡尔纳或出版商的某种立场：同情殖民地人民受压迫的命运，反对奴役，崇尚自由平等。

尼摩船长本是印度达卡王子，具有秘密造出鹦鹉螺号这样的潜艇所需的资金、知识、人力等条件。因为祖国始终在英国人的压迫之下，反抗不成，便转入海洋。海洋是尼摩对人世失望后的最后归宿，因为海洋深处不会有暴君，不会有暴行和压迫。

尼摩极少发怒，似乎只在《海底两万里》中有一次：他那时以复仇的心态驾驶潜艇摧毁了“某国”的军舰（凡尔纳起初写是哪国的军舰，可能是为了避免引发不必要的争议，在《神秘岛》中才写明了是英国的军舰）。尼摩一向竭力为善，这次正当防卫后，尼摩或许也多少感到不安，所以在《神秘岛》中才会向赛勒斯等人询问众人对自己的评价。即使表面上看起来坚定，但他或许也开始怀疑自己的选择是否正确了。

&gt; 他将双手伸向空中，喃喃地说：“我到底是对还是错呀？”
&gt; 

赛勒斯没有直接回答，只是再次表达了自己的感激之情。

我认为尼摩完全没有必要怀疑自己，他根本没有必要在意世人的看法。他选择与世隔绝，人类的正义与非正义在属于尼摩的深海中已经没有意义了。他选择与世隔绝并非是为了复仇，而是为了追寻一个真正自由、没有奴役、没有殖民者的国度。如果非要说，我觉得尼摩是正义的。不管怎么样，尼摩带走他的一切沉入了他热爱的深海，至于后面的是是非非，全留给世人讨论。

凡尔纳反对奴役的立场在另一处也可以明显地体现出来：行文的前前后后，他始终表现出对林肯代表的北军的崇敬，以至于还在时间线中突出了林肯遇刺的那一天。

### 五人核心

《神秘岛》和《鲁滨逊漂流记》最明显的区别在于人数。《神秘岛》涉及到5个核心人物，而《鲁滨逊》只有两个，这使得《神秘岛》里的主角们可以走得更远。《神秘岛》中众人以及于普和托普始终保持着通力合作和民主决策，没有明显的主奴划分，而《鲁滨逊》就不一样了——我总感觉《鲁滨逊》还带着点奴隶制的古旧味道，《神秘岛》则进步得多。

### 题外话

断断续续两个月下来，才勉强写完本文，并且最后成文我个人不太满意，没能把我所有的感受和想法都整合进来。

        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        装机小记
        
        </title>
        <url>////nth233.top/posts/2023-07-13-装机小记.html</url>
        <search-text>
        
        
            瞎写
        
            blog
        
        
        
        
        
我一直有装机的想法，尤其是在舍友装机之后。

用了一下舍友的电脑之后，多年无法体会台式机好处的我，又再一次体会到台式机的舒服之处。台式机虽然不好携带，但是可扩展性、性价比、可定制性、舒适程度都是完爆笔记本的。于是五月中下旬开始，我就开始关注主要部件的价格，6月初趁着618就下单了。

我原本认为6月8日怎么也该回到家了，没想到各种学校琐事拖着我没法走，外加桂林、云南的旅游计划一直推迟，最终6月25日晚上才回到家，我的那堆装机部件在家里静静躺了半个多月。

6月25日晚上，我装机装到了凌晨三点，第二天又零星解决了一些问题，总算是把电脑装好了。可以说台式机的体验完爆我现在的笔记本（2019年的小米pro）。

---

这次装机的原则很简单：够用就行。讲究的就是能妥协的妥协，该省钱的省钱。机箱特地选了一个小机箱，但是到手之后发现还是有点大，和网上一些折腾ITX的人没法比。

| 部件 | 型号 | 价格 |
| --- | --- | --- |
| CPU | Ryzen 5 5600G | ¥700.00 |
| 主板 | ASUS B550m-plus wifi | ¥774.00 |
| 内存条 | 科赋 16GB DDR4 3200 | ¥201.00 |
| 电源 | 长城 X5 550W | ¥307.00 |
| 固态硬盘 | 致钛 TiPlus5000 1TB | ¥326.00 |
| 机箱 | 先马趣造白色 | ¥238.00 |
| 显示器 | 优派VX2758-2k-pro | ¥971.00 |
| 音箱 | 漫步者 R12U 白色 | ¥74.00 |
| HDMI线 | 淘工厂杂牌 1米 ×3 | ¥4.70 |
| 散热风扇 | 先马冰洞3个套装+集线器 | ¥59.00 |
| 显卡 |  |  |
| 机械硬盘 |  |  |
| 固态硬盘（扩） |  |  |
| 内存条（扩） |  |  |
| 排插 | 德力西 K3X3Z 3米 | ¥39.01 |
| 会议摄像头+麦克风 |  |  |
|  | 合计 | ¥3,693.71 |

        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        《三四郎》
        
        </title>
        <url>////nth233.top/posts/2023-04-30-《三四郎》/index.html</url>
        <search-text>
        
        
            读书笔记
        
        
        
        这是一篇拖了很久没写的读书笔记。每次坐在键盘前，打开笔记的这个页面，我都想不到该写些什么，脑海中只是浮现出那个不眠之夜的景象。2021年的双十一我购入了这本书，随即看了几章，之后便没有读书的兴致了。一年以前我开始从头重读，但不久后各种各样的琐事又消磨掉了我读书的兴致，进度便又停滞了。最后，在去年的某个秋夜，舍友鼾声雷动，夜里又实在是无事可做，便下床拿起书开始看，一页接着一页，最终竟然在当天把这本书读完了。当时读完之后已是凌晨四点，昏昏沉沉之间我只觉得《三四郎》就该以这种遗憾收尾。
        
        
        
&gt; 迷途的羊 - Stray Sheep
&gt; 

这是一篇拖了很久没写的读书笔记。每次坐在键盘前，打开笔记的这个页面，我都想不到该写些什么，脑海中只是浮现出那个不眠之夜的景象。

2021年的双十一我购入了这本书，随即看了几章，之后便没有读书的兴致了。一年以前我开始从头重读，但不久后各种各样的琐事又消磨掉了我读书的兴致，进度便又停滞了。最后，在去年的某个秋夜，舍友鼾声雷动，夜里又实在是无事可做，便下床拿起书开始看，一页接着一页，最终竟然在当天把这本书读完了。当时读完之后已是凌晨四点，昏昏沉沉之间我只觉得《三四郎》就该以这种遗憾收尾。

但当时我没有当即把自己的感受写下来，而是赶紧睡觉去了。于是又开始了拖延，直到某个平凡的日子，大概是不想复习考研了，就开始打开笔记的这一页面开始码字，我忘了写了多少，但最终被我当天全部删掉了。

不到有压力的时候，我似乎是不会想到写这些七七八八的东西的，多半做正事去了。只有现状如同泥沼一般、不想做正事的时候，才会煞有介事地写什么读书笔记。因此，出于类似当时不想复习考研的心态，我最近又在几天内重新看完了这本书，并且觉得必须动笔开始胡乱写点东西了，借此短暂逃避一下泥沼般的现状。

---

故事开始于熊本乡下的学生三四郎到东大入学。这一人生阶段的人可能最有东西可写。熊本与东京，是两个截然不同的世界：东京不仅城市建设上日新月异，大学校园的氛围、人的思想也与乡下不同。现代化的东京和未现代化的家乡简直是两个世界，这让三四郎感到震撼。三四郎是个胆怯的人，做各种事情都有着顾虑（就如同夏目漱石的其他主角一样）。也正是三四郎的这种胆怯，才让他的故事显得这么朦胧隐晦。

在东京，三四郎遇到了理科的野野宫君，同班同学与次郎，颇有思想且安贫乐道的广田先生，还有野野宫君的妹妹良子、里见美祢子这样的新女性。野野宫君执着于在阴暗潮湿的地窖中测试光线的压力，有时显得优点木讷。与次郎则相反，这个同级学生很快就和三四郎混的很熟。广田先生则是一个高中教师，一直未婚。月薪不高，但是对此并不觉得担忧。与次郎很敬佩广田先生，尝试后台做些运作，甚至作文替广田先生入校任职造势，可惜最后弄巧成拙。

故事最明显的线索就是三四郎和美祢子之间朦胧的关系。

在故事开始不久，三四郎就在东大的湖边看到了美祢子，当即被迷住了，美祢子也注意到了三四郎，两人发生了一点点眼神交流（所以现在这个池子直接被叫做“三四郎”池了）。从此三四郎就有意无意地深陷其中。美祢子家庭相对富裕，并且在那个时代，比乡下的女性思想更为独立。不久后两人在广田先生新家正式相识，两人分工合作打扫了广田先生的房间之后，三四郎产生了某种朦胧的情感。之后三四郎随广田先生一行人去看菊偶，美祢子也同行，那天美祢子似乎心情不佳，显得有点疲惫，三四郎询问过后，两人去了某个较为僻静的地方闲坐看云。一段时间过后，三四郎担心广田先生一行找不到他们两人，美祢子却说：

&gt; 不，没关系的。我们是迷路的大孩子。
&gt; 

随即告诉三四郎“迷途的羊”的英文是“stray sheep”。三四郎就一直这样记着stray sheep，无聊时的涂鸦也尽是stray sheep。美祢子有次给三四郎写信，背面画着两只羊，三四郎的名字下面小字写着“迷途的羊”，三四郎对此觉得很有趣味——这是两人之间独有的某种语言。

后来三四郎替与次郎借钱（三十圆钱，在那时对三四郎来说不是小钱），得以到美祢子家里去。因为与次郎的谎言，美祢子以为是三四郎买了马票赔光了钱，才来借钱。但美祢子并没有责怪的意思，反而显得很乐意借出这笔钱。其实对美祢子家来说这笔钱不算什么，而且美祢子作为养尊处优、我行我素的新女性，对此这笔钱本身根本不在意。但三四郎出身乡下，当然不好意思一直借着，最终还是让乡下寄来了钱。美祢子借钱时用嗔怪的语气说了这句耐人寻味的话：

&gt; 凭马券去猜马，这不是比猜中人的心还要难吗？像你这种稀里糊涂的人，连附有索引的人的心都不会去猜一猜，竟然去买……
&gt; 

过后美祢子邀请三四郎去画展，三四郎什么也不懂，但也跟着去了。直到去了才知道，原来原先美祢子应该和野野宫君一起来的。

第一次尝试还钱时，美祢子正在画家原口先生家里做模特，手持团扇，半遮面。原口不时问三四郎画得怎么样——尤其是眼睛。看着画里的美祢子，和现实中的美祢子，三四郎又有了某种感受。美祢子也在看着三四郎，她的情绪在三四郎到来之后发生了微妙的变化。原口注意到了美祢子显出了疲态，便中止了当天的作画，明日再继续。期间三四郎尝试还钱，但被美祢子拒绝。美祢子随后被一个不认识的男性接走——即未来的丈夫。

第二次尝试还钱是在教堂。美祢子显得萎靡不振，引用《圣经》对三四郎说：

&gt; 我知我罪，我罪常在我前。
&gt; 

最后，美祢子和三四郎的关系就在朦胧中结束了。美祢子婚礼过后的某个画展，三四郎和与次郎、野野宫、广田先生一行一同前往，那副美祢子手持团扇的巨幅肖像正在展出，命名为《森林之子》。野野宫君把婚礼的请帖撕碎，丢在地板上。三四郎只觉得这画的题名不好，满脑子都是：

&gt; 迷途的羊。
&gt; 

---

所以，三四郎和美祢子这种朦胧的关系，从一开始就模糊不清，又在朦胧中以遗憾收尾，仿佛没有开始就结束了。其实站在旁观者的视角，这种朦胧得几乎不存在得关系根本没有什么可“遗憾”的，之所以会有遗憾得感受，其实是因为夏目漱石只会在三四郎受到触动的时候才对美祢子展开详细的描写，让读者不知不觉站在三四郎的一边，从三四郎的视角看美祢子，甚至是代入三四郎。我觉得这个结局是非常合适的——我本身就偏爱有缺憾的结尾，看到最后只觉得这个故事就该以这种方式收场——如果一切都没有缺憾，那我反而会觉得不对劲了。

其实在开篇不久，作者就已经暗示了这段关系不会有结果。在湖畔初见时，美祢子是站在柯树下的，并且文中多次强调了柯树“不会结果”，大概就是象征这段似有似无、还没开始就结束的关系吧。另外，三四郎在广田家中，众人讨论文学的时候，广田就半开玩笑的说三四郎有点像小说中的黑人，美祢子有点像小说中的公主，还让与次郎尝试翻译“怜悯近于爱”。作者有时似乎刻意强调三四郎和美祢子差距悬殊的出身，并借着与次郎的嘴说三四郎“没有资格”。作者早就为这样的结局做好了铺垫，一切都在意料之内、情理之中，一切都自然而然。

但我看不懂美祢子为何会有这样的行为，怜悯？被迫妥协？美祢子最初似乎和野野宫君存在某种联系，但在看菊偶之前，美祢子似乎对野野宫的言行不太满意，于是看菊偶的时候显出某种疲态。我无法判断她过后是否是有意地借三四郎甩开野野宫。第二次显出疲态，是她在为原口做模特的时候。看到三四郎时，美祢子就显得有点疲惫了，不知是同一个姿势做久了感到疲惫，还是因为三四郎而感到疲惫呢？画像结束时，三四郎几乎明说了自己来不只是还钱，是想来“看看你”，美祢子并没有因此触动。在教堂时，美祢子也显得萎靡不振，这更加耐人寻味。美祢子究竟是有意作弄三四郎，还是作为“迷途的羊”无意做了这一切，还是对三四郎真有朦胧的感情？我不得而知，也揣测不出结果。与次郎说，美祢子这样的女性不可能看上不如自己的人，这个意义上说，一切可能都是无意之举，或者是有意作弄。广田先生说，与次郎和美祢子都是所谓与伪君子对立的“真恶人”，直率而任性。但广田先生立马又说，现在有些人用“真恶”来行“伪善”，要正直地“把自己的伪善不走样地显示给对方知晓”，这一看，似乎是在说美祢子陷于包办婚姻之中……美祢子未来的丈夫原本要娶的是良子，但良子更加任性，严词拒绝，最后才娶的美祢子——这么看来，这一婚姻是十分仓促的，若非长辈催促，作为新女性的美祢子怎么可能这么快成婚……

总之我看不懂，现在也认为没必要梳理出种种蛛丝马迹、牵强附会地解释美祢子各种行为。

---

下面罗列了一堆七七八八的感受，并不存在某种主题。

在大一新生三四郎的眼里，世界似乎分裂成三个。一个是家乡，家乡的时间仿佛停留在明治初年，民风淳朴，一切按传统有序地发生着，三四郎对此既觉得厌烦，又觉得温情——就和所有人的故乡一样。第二个是知识和学术的领域，广田先生和野野宫君在这里，这个世界的人往往生活拮据、衣冠不整，物质的丰富程度远不如精神的丰富程度，虽然如此，但却远离烦恼的尘世，十分静谧。第三个世界则是恋爱，如同春天一般灿烂，但却又像月亮——就在眼前，却遥不可及。这三个世界的分裂，恐怕就是三四郎一切烦恼的源泉。夏目漱石是在熊本的中学教书过的，对这种心理的把握可以说是细致入微。小地方的人，和大城市的原住民不同。大城市的人在家乡就能得到不错的发展，小地方的人很多则是不得不到大城市里去，既想着探索第二个世界和第三个世界，又每时每刻都挂念着第一个世界，对三四郎这样拿不起又放不下的胆小者来说尤为如此。这样一看，出身于落后的小地方，简直就是天生带着绝对的劣势。何况三四郎的父亲早就去世，是个单亲家庭。所以，当思考未来的时候，三四郎这样地人会“茫然地感觉到一种沉重地压迫、好像未来正从远处朝眼前逼过来”。三四郎时迷途的羊，当代的许多人又何尝不是。

夏目漱石似乎喜欢在作品里面写电车，时不时冒出一堆东京车站的站名，让人看得一头雾水。电车是现代化的标志，能够快速地在东京内部移动，可能作者也是喜欢坐着电车到处逛逛，才会对车站附近地景色如此熟悉。电车这种快速移动的特性也便于推动剧情。本作里面夏目漱石插入了一个电车轧死卧轨年轻女子的事件，也不知是有什么用意。我觉得可能是当时的某个社会热点事件……插入进来只是为了填充剧情，顺便探讨一下生死。

广田先生是个奇怪的角色，似乎毫不在意功名，也毫不在意利禄，一直未婚，可能连生死都想透了。夏目漱石似乎就爱写这种“超脱”的文人。然而广田似乎跟那种假的超脱不同，是真的有他的故事。他好像在知识方面无所不知，在恋爱方面一无所知——可能是因为很久以前碰到过一个年轻女子，一眼就“爱”上了，念念不忘，有时做梦都会做到。他和三四郎说了一个梦：他已垂垂老矣，在林中又碰到了那个女子，还是十二三岁的模样，他感到震惊，女子说自己就爱这一刻的容貌，因此从未改变。他说：“你是画”，女子回答：“你是诗”。广田的父亲很早就去世了，但母亲离世的时候担心他没人照顾，告诉他可以找某某人。广田问是谁，母亲说：“是你父亲”。可能也因此，广田一直对婚姻持怀疑态度。

夏目漱石可能把自己拆成了好几个人，到这一作品里面客串了好几次，比如“有胃病的老师”、学水彩的良子、到处闲逛的三四郎、文学沙龙上的谈话者、高级中学英语教师广田、接替外国人的归国文学老师。当然我不了解其人，不敢妄加揣测。作品里面有时会出现和主线剧情无关的社会事件、文坛事件，让人觉得是作者有意写进来，表达自己的观点——就好像《我是猫》那样。

总之这就是我眼中的《三四郎》，不如《我是猫》那样有趣，看完只觉得朦朦胧胧。买到书时，里面夹着“漱石枕流，悠悠百年”的小册子，里面大概介绍了夏目漱石的生平，并把《三四郎》说得像是轻小说一样的青春文学——可能差不多就是吧。

        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        自制TrueType字体（零）
        
        </title>
        <url>////nth233.top/posts/2023-03-25-自制TTF字体（一）.html</url>
        <search-text>
        
        
            font
        
            truetype
        
            字体
        
            TTF
        
        
        
        
        
        
        
## 0 前言

我一直以来就很想自己制作一个字体，自定义出各种字形，但每次要行动的时候总是卡在第一步：无从下手。计算机上的字体不同于传统印刷的字体，并不是用手画出来就大功告成了，还涉及到相对复杂的一些数字字体相关的原理。前几年偶然发现了FontForge这个软件，界面看着简单，但打开之后依然毫无操作的头绪，又是无从下手。

时间一天天过去，我觉得现在时机已经成熟，不该再一直拖延了。是时候可以从阅读TrueType的文档开始，脚踏实地地把一切都搞明白，最后一步一步地把字体做出来。

以上是开坑的原因。

本章可以视为阅读TrueType文档的笔记

## 1 字体的数字化

字体，可以说就是字的形状。将传统雕版或是字模上的所谓字体搬到计算机的屏幕上，要解决的其实就是怎么表示和存储形状的问题。上世纪八十年代，为了能够显示多样的字体，苹果推出了TrueType标准，把Times New Roman、Helvetica、Courier等字体搬上了Macintosh的屏幕。微软过后也在Windows 3.1中引入了TrueType。如今大部分字体都有TrueType格式的版本（`*.ttf`），而最初的那三种字体也早已成为了经典。1994年，微软在TrueType基础上推出了OpenType，如今OpenType也是主流字体格式之一（`*.oft`）。所以要做计算机字体，应该先了解一下TrueType。

TrueType，说到底，就是用分段的二次贝塞尔曲线表示字形的**轮廓**，就像是用Photoshop的钢笔工具把字形画出来。三个点（两个端点、一个控制点）可以确定一个二次贝塞尔曲线。如果曲线复杂一些，可以用多条二次贝塞尔曲线进行逼近。有些点（曲率为0的点）其实是可以省略的（隐含了）。贝塞尔曲线的表示的字体能够比较好地适应不同地屏幕分辨率，并且怎么放大都不会有明显地锯齿，质量相比点阵字体高了一个台阶。

![用贝塞尔曲线表示的轮廓（似乎不是二次贝塞尔曲线）](/assets/img/post/makefont/g1.png)

字体中的轮廓有方向（点编号从小到大，把右手边的区域填充成黑色）、可以重叠、可以组合（比如ü）。

定义轮廓的点必须在**主网格**上。因为宽度常常与大写字母M相同，主网格通常也叫**em方块**，网格密度依字体而定，一般是二的整数幂次。坐标系也是依字体而定，拉丁字母多数把原点设在左下角，汉字很多把原点设在正下方。字形一般不会超出em方块，但是并不绝对（比如积分符号∫就常常被设计为超出em方块的）。控制点的数量不宜过多或过少。

![em方块的坐标系](/assets/img/post/makefont/coordinate.png)

## 2 字体引擎

字体通过字体引擎显示到屏幕上。分为四步：缩放、对格、光栅化。

第一步，缩放。缩放器根据要渲染设备和大小，划定要渲染的网格。然后，直接将em方块缩放上去，所有的点保留器原有的位置（具体而言，用的是26.6定点小数），此时缩放后的坐标记为(x~, y~)。

&gt; x~和y~使用26.6定点小数，意即对准的是每个1/64像素的位置。
&gt; 

具体的缩放系数为：`scale = pointSize * resolution / (72 points per inch * units_per_em)`

比如有个字形长度是550 FUnit，那么在72dpi的显示屏上，它的长度就是`550 * [(18 * 72 )/ (72 * 2048 )] = 4.83`。有两个特殊的点值得注意：出发点和落脚点，分别对应起始的笔位置和结束的笔位置，可以表示出宽度。

&gt; FUnit代表em方块上的一格。
&gt; 

第二步，对格，即根据需要和偏好，在新网格上移动轮廓上的点。对格不是粗暴地四舍五入，而是根据字体内部包含的指令实现的。通过指令，可以实现对格时的不同偏好，保持字形的一些重要性质/参数，下面两张图应该可以直观显示为什么要对格，以及对格为什么需要指令而不能直接四舍五入。对格之后，点的坐标表示为(x,y)。

![“@”的对格与不对格](/assets/img/post/makefont/gridfitting.png)

第三步，光栅化。这一步将轮廓转化为像素点阵，即控制哪些像素“开”，哪些像素“关”。简单来说，如果一个像素的中心点在轮廓内部就开，否则不开（***规则1***）。这里涉及一个重要的问题：如何判断像素点中心到底是在轮廓内还是在轮廓外？TrueType使用环绕数来解决这一问题。如果环绕数非0，那么就在轮廓内，否则在轮廓外。

环绕数的计算十分容易。首先，置环绕数初始值为0。然后从像素点中心出发，沿着一条射线扫描。每当穿过轮廓的时候进行计数，如果是从轮廓线的左边跨到右边/下边跨到上边，则环绕数+1，否则环绕数-1。因为轮廓肯定是闭合的，所以射线的方向不重要。但为了方便，一般采用向正右或者向正上发射的射线。

默认模式下，仅按照规则1进行光栅化。但这不一定能满足现实的需要。在ppem（Pixels Per EM）较低的时候，或是字体经过旋转、伸缩等变换时，容易出现像素丢失的问题（dropout）。比如：

为了应对像素丢失问题，可以启用两种丢失管理模式，分别引入以下额外的规则。规则3相比规则2，去掉了尖角的情况。

1. 规则2
    1. 如果一条连接两个像素的横线，经过从左至右同时跨过两条方向不同的轮廓，并且根据规则1两个像素都不开启，那么开启左边的像素。
    2. 如果一条连接两个像素的竖线，经过从下至上同时跨过两条方向不同的轮廓，并且根据规则1两个像素都不开启，那么开启下边的像素。
2. 规则3
    1. 如果一条连接两个像素的横线，经过从左至右同时跨过两条方向不同的轮廓，并且根据规则1两个像素都不开启，而且两条轮廓继续与其他的扫描线相交，那么开启左边的像素。
    2. 如果一条连接两个像素的竖线，经过从下至上同时跨过两条方向不同的轮廓，并且根据规则1两个像素都不开启，而且两条轮廓继续与其他的扫描线相交，那么开启下边的像素。

![非尖角（左）和尖角（右）引起的像素点丢失](/assets/img/post/makefont/pixelmissing.png)

## 3 解释器与指令

字体文件中的指令不仅仅用于前面提到的对格。指令的序列称为程序。TrueType字体文件中的程序又可以分为三种：字体程序、控制值程序和字形程序。顾名思义，字体程序与整个字体相关，在应用程序首次加载这一字体时执行，并且只执行这一次，主要用于定义函数和指令；控制值程序在每次发生变换、字号改变时执行；字形程序在字形被使用的时候执行。

指令的名称和操作码不一定一一对应，一类指令的不同变种可能共用同一个指令名，通过设定一些标志，便可确定具体用的是哪条指令。具体请查文档。比方说`PUSHB[abc]`，方括号中的部分就是标志，真实的指令操作码就是PUSHB的操作码在低位补上标志位。

解释器的执行环境包括一些全局的状态变量，称为图形状态。这些状态包括自由向量的设置、投影向量的设置、舍入状态的设置等，具体可查文档。图形状态在解释器开始执行时，会重置回默认值，因此字形程序之间无法相互发生影响。控制值程序可以修改图形状态的默认值，也就是说，控制值程序可以影响后续字形程序。

解释器处理指令的方式类似计算机的CPU。执行时，指令指针〔IP，Instruction Pointer〕指向下一条要执行的指令。指令顺序存放，默认采用顺序执行，形成一条指令流，但也可以使用跳转和循环指令执行顺序。

解释器将数据存储在栈上，与指令分离。每个栈元素32位宽。PUSH类的指令可以往栈上压入字节（8位）或是字（16位），其余指令只能读取栈上元素，或者把元素从栈上弹出（自然是先进后出）。当压入一个字的时候，采用大端序，即高字节在前，低字节在后。如果一次压入的数据量不足32位，解释器会在高位进行符号扩展。

解释器还有一块内存空间，用于暂存栈上取出的数据，称为存储区。

除设置图形状态的指令、管理栈的指令、读写存储区的指令、跳转和循环指令、获取解释器状态的指令之外，还有用于算数运算、逻辑运算、比较运算的指令，和CPU的指令集略有些类似。

## 4 点的移动

TrueType引入指令的主要目的是为了对格的时候能够得到较好的效果。说到底，就是为了对格的时候智能地移动轮廓上的点。

首先我们对轮廓点坐标的变换做一个概述。在TrueType字体文件中，所有轮廓点的坐标的单位都是FUnit，也就意味着都是整数。在缩放到具体设备的像素网格上之后，坐标使用26.6定点小数表示，也就是自动对齐到像素的1/64的整数倍上面去，1:32就表示一个半像素，2:16就表示2又1/4个像素。

根据点存在的方式，我们可以把指令用到的点分成两类，分属两个区。存储在字体文件中的轮廓点的坐标，处于字形区。指令根据需要，临时生成的点的坐标，属于过渡区（twilight zone）。过渡区的点在重新加载字形的时候不会自动初始化，所以在使用前，必须先用指令设置它们。

指令不显式区分两个区域的点。区域指针（zp）用于指定点所在的区。引用指针（rp）用于指向具体的点。两个区域的点都从0开始编号，因此不指明区域会发生混淆。有一系列指令可以设置zp和rp。还有一些指令切换点是否在轮廓上的状态。

对于某个具体的点，我们可以移动它。所有的点只能沿着自由向量的方向进行移动。自由向量作为表示方向的向量，其起点在哪并不重要，在逻辑上可以平移到任何位置。自由向量是一个图形状态变量，用一对数字表示。

点的位置通过投影向量给定。具体而言，将点投影到投影向量上，其投影在投影向量上的坐标就代表了点的位置。移动点时，我们给定一个投影向量上的坐标，将点沿着自由向量移动到对应位置上。

![P代表投影向量（所在的直线），F代表自由向量（所在的直线）](/assets/img/post/makefont/movepoint.png)

投影向量还可以用于计算两点沿投影向量的行程（distance）。行程除长度之外，还具有颜色属性。仅穿过黑色区域的行程为黑色行程，仅穿过白色区域的行程为白色行程。既穿过白色区域也穿过黑色区域的行程需要按照子行程的组合确定颜色。将行程切分成白色和黑色的子行程，然后按照规则进行组合。最后组合出是什么颜色就是什么颜色。规则如下图。（ps. 我不清楚distance翻译成“距离”会不会更好。）

![行程的颜色](/assets/img/post/makefont/colorofdistance.png)

行程的颜色用于舍入时引擎的补偿。比如根据需要，在像素较大的设备上，引擎可以让黑色行程短一些、白色行程长一些。灰色行程不会进行补偿。

TrueType解释器的舍入针对的是行程，而非点坐标。舍入模式位于图形状态中，可以按需改变。行程在舍入之后转化为整数或是半整数。不同舍入模式有不同的阈值和相位，具体细节请参考文档。舍入的具体流程：

1. 添加引擎补偿
2. 减去相位
3. 加上阈值
4. 根据周期进行去尾
5. 加回相位
6. 调整：如果正数被舍入到负数，则调整为最靠近0的整数。负数同理。

接下来终于可以讨论对点的移动了。移动点的指令可以分为5种：给定位移（此时不用到投影向量）、给定目标位置、给定相对行程、对齐（使两点在投影向量上有相同位置）、插值（按其他点的移动进行移动）。指令的具体细节以后再探讨。

## 参考资料

插图来自TrueType文档和OpenType文档。

1. [TrueType文档](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM01/Chap1.html)
2. [OpenType文档](https://learn.microsoft.com/en-us/typography/opentype/spec/overview)
3. [TrueType - Wikipedia](https://en.wikipedia.org/wiki/TrueType)
4. [Em(typography) - Wikipedia](https://en.wikipedia.org/wiki/Em_(typography))
5. [Em Square](https://designwithfontforge.com/zh-CN/The_EM_Square.html)
6. [FontForge字体设计](https://designwithfontforge.com/zh-CN/The_EM_Square.html)


        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        Hyprland的配置
        
        </title>
        <url>////nth233.top/posts/2023-02-26-Hyprland配置.html</url>
        <search-text>
        
        
            Linux桌面
        
            窗口管理器， Hyprland
        
            Wayland
        
            archlinux
        
        
        
        本文主要介绍[Hyprland](https://hyprland.org/)的基本配置。虽然Hyprland已经有了一个官方文档，但是和i3wm的文档相比，可读性还是差了很多。单看文档，不给一个配置范例的话，还是很难上手。很可惜的是，Hyprland的默认配置和Sway相比差远了，必须要一番折腾才堪用。因此才有了这篇文章，一方面是分享一下我的配置，另一方面是分享一下踩的坑。本文只涵盖最基本的配置，由于我觉得Hyprland默认的特效已经很炫酷了，因此没有对特效做任何修改，本文也就不会包含任何与特效配置相关的内容。
        
        
        
本文主要介绍[Hyprland](https://hyprland.org/)的基本配置。虽然Hyprland已经有了一个官方文档，但是和i3wm的文档相比，可读性还是差了很多。单看文档，不给一个配置范例的话，还是很难上手。很可惜的是，Hyprland的默认配置和Sway相比差远了，必须要一番折腾才堪用。

因此才有了这篇文章，一方面是分享一下我的配置，另一方面是分享一下踩的坑。本文只涵盖最基本的配置，由于我觉得Hyprland默认的特效已经很炫酷了，因此没有对特效做任何修改，本文也就不会包含任何与特效配置相关的内容。

![我的Hyprland](/assets/img/post/myhyprland.png)

## 为什么要用Hyprland？

特效？wlroots？平铺式布局？其实我也忘了我为什么要用Hyprland。当初觉得Gnome资源占用太高，就去用Sway。但是Sway的动画简陋而且不适配N卡，就试着使用了一下Hyprland，于是一路折腾过来，就用上了。不过没过多久，我还是回到了Gnome和Sway。日常使用Gnome，需要低占用就用Sway，似乎真的没有使用Hyprland的理由。

如果你不愿意使用臃肿DE、想要使用平铺式的WM、愿意使用Wayland、想要自己配置炫酷的特效、乐于折腾，那么Hyprland确实值得一试。如果你从未尝试过平铺式WM，那么我建议先尝试一下i3或者Sway，初次尝试可能会觉得不适应，但一旦习惯了平铺式WM，就会觉得传统的层叠式WM十分低效。

## 在ArchLinux上安装Hyprland

&gt; 我个人不建议使用任何“一键安装脚本”进行安装，除非你很清楚脚本在做什么。如果读过别人写的bash脚本，就会知道这东西可读性极差，与其对脚本进行费时费脑的审查，不如直接手动装了。

Hyprland尚未进入Arch的官方仓库，因此得从AUR安装。

```
yay -S hyprland
```

安装完成后，理论上Hyprland就可以用了（实际上此时Hyprland使用的默认配置不仅丑，而且十分难用）。可以注销登录进Hyprland，看看配置前的Hyprland是什么样子的。

## Hyprland本体的基本配置

打开`$HOME/.config/hypr/hyprland.conf`修改配置。要做的第一件事是把“自动生成”的标志给注释掉，否则每次启动Hyprland都会报警告。把下面这行注释掉：

```
autogenerated = 1 # remove this line to remove the warning
```

改为

```
#autogenerated = 1 # remove this line to remove the warning
```

### 键位绑定

我习惯把快捷键改得像Sway。如果有特殊的需要，可以自己修改。`$mainMod`键类似i3中的`mod`键，建议把所有和WM相关的快捷键都设置为以`mod`这个键开头，这样比较有条理。一般设Super键为`$mainMod`，因为大部分程序的快捷键都不涉及Super键。

```
$mainMod = SUPER # 用super键作为mod键

```

然后逐个绑定快捷键。绑定快捷键的语法如下：

```
bind=MODS,key,dispatcher,params
```

`MODS`表示快捷键中的“模式键”，譬如SUPER、SHIFT、CTRL等等。`key`则表示快捷键组合中最后的那一个键。`dispatcher`则表示是Hyprland内置的命令，比如`exec`运行、`movefocus`移动焦点等等，详见[Hyprland的wiki](https://wiki.hyprland.org/Configuring/Binds/)，`params`表示`dispatcher`的参数。

下面是我个人习惯使用的配置：

#### 应用

```
bind = $mainMod, return, exec, kitty # 打开终端
bind = $mainMod SHIFT, return, exec, gnome-terminal # 有时我需要用gnome-terminal
bind = $mainMod SHIFT, q, killactive, # 关闭当前窗口
bind = $mainMod SHIFT, e, exit, # 注销
bind = $mainMod, n, exec, nautilus # 文件管理器，我习惯用nautilus
bind = $mainMod, p, exec, firefox # 浏览器，我习惯用firefox
bind = $mainMod, space, togglefloating, # 切换悬浮模式，悬浮的窗口和层叠式WM中的窗口行为类似，会浮动在平铺的窗口上面
#bind = $mainMod, tab, exec, wofi --show drun # 使用wofi选择应用
bind = $mainMod, tab, exec, rofi -show drun # 使用rofi选择应用，之后解释
bind = $mainMod, x, exec, hyprland-interactive-screenshot # 截图，之后解释
```

#### 窗口和工作区

```
bind = $mainMod, d, pseudo, # dwindle # 伪平铺，后面解释
bind = $mainMod, V, togglesplit, # 修改划分方式（切换纵横向切分）
bind = $mainMod, S, togglegroup, # 切换编组（打开编组模式后，同组的窗口会叠在一起）
bind = $mainMod CTRL, l, changegroupactive # 切换编组中的窗口
bind = $mainMod SHIFT, f, fullscreen # 切换全屏
bind = $mainMod, H, movefocus, l # 选中左边的窗口
bind = $mainMod, L, movefocus, r # 选中右边的窗口
bind = $mainMod, K, movefocus, u # 选中上面的窗口
bind = $mainMod, J, movefocus, d # 选中下面的窗口，这四个快捷键受vim启发
bind = $mainMod, 1, workspace, 1 # 选中工作区1，下面同理
bind = $mainMod, 2, workspace, 2
bind = $mainMod, 3, workspace, 3
bind = $mainMod, 4, workspace, 4
bind = $mainMod, 5, workspace, 5
bind = $mainMod, 6, workspace, 6
bind = $mainMod, 7, workspace, 7
bind = $mainMod, 8, workspace, 8
bind = $mainMod, 9, workspace, 9
bind = $mainMod SHIFT, 1, movetoworkspace, 1 # 把窗口移动到工作区1，下面同理
bind = $mainMod SHIFT, 2, movetoworkspace, 2
bind = $mainMod SHIFT, 3, movetoworkspace, 3
bind = $mainMod SHIFT, 4, movetoworkspace, 4
bind = $mainMod SHIFT, 5, movetoworkspace, 5
bind = $mainMod SHIFT, 6, movetoworkspace, 6
bind = $mainMod SHIFT, 7, movetoworkspace, 7
bind = $mainMod SHIFT, 8, movetoworkspace, 8
bind = $mainMod SHIFT, 9, movetoworkspace, 9
bind = $mainMod, mouse_down, workspace, e+1 # 鼠标滚轮切换工作区，下面同理
bind = $mainMod, mouse_up, workspace, e-1
bind = $mainMod ALT, h, workspace, -1 # 键盘切换到上一个工作区
bind = $mainMod ALT, l, workspace, +1 # 键盘切换到下一个工作区
bind = $mainMod ALT, left, workspace, -1
bind = $mainMod ALT, right, workspace, +1
```

#### 鼠标

```
bindm = $mainMod, mouse:272, movewindow # 按住mod用鼠标左键拖动窗口
bindm = $mainMod, mouse:273, resizewindow # 按住mod用鼠标右键拖动窗口
```

#### 音量和亮度控制

```
bind = , xf86audioraisevolume, exec, amixer set Master 5%+ # 调大音量
bind = , xf86audiolowervolume, exec, amixer set Master 5%- # 调小音量
bind = , xf86monbrightnessdown, exec, brightnessctl set 5%- # 调高亮度
bind = , xf86monbrightnessup, exec, brightnessctl set 5%+ # 调低亮度
```

可以根据需要再加入其他的[X绑定功能键（XBindKeys）](https://wiki.archlinux.org/title/Xbindkeys)。

### 窗口规则

可以强制让一些窗口默认悬浮。比如rofi、QQ的图片查看器。

```
windowrulev2 = float, title:rofi.*
windowrulev2 = float, title:Lutris
windowrulev2 = float, title:QQ
windowrulev2 = float, title:图片查看器
```

### 输入法

在Hyprland启动的时候，顺便启动fcitx5。

```
exec-once=fcitx5 -d
```

## 一些必装的工具

完成上面的配置之后，Hyprland勉强算是可以用了，但是体验会非常糟糕。要想日常使用，下面这些工具基本上是必装的。

### 壁纸：swaybg

swaybg没有花里胡哨的功能，就单纯是显示一张静态壁纸，对我来说已经很够用了。如果需要自动切换壁纸，可以用[swww](https://github.com/Horus645/swww)；如果需要花里胡哨的动态壁纸，可以试试[mpvpaper](https://github.com/GhostNaN/mpvpaper)。

首先安装swaybg

```
# pacman -S swaybg
```

然后在`hyprland.conf`中调用它（就是在Hyprland启动后顺便执行swaybg）。记得把`&quot;$HOME/Pictures/wallpaper/brown-mountain.jpg&quot;`改成你壁纸的路径。

```
exec-once=swaybg -i &quot;$HOME/Pictures/wallpaper/brown-mountain.jpg&quot;
```

### 状态栏：Waybar

状态栏有[很多种选择](https://wiki.hyprland.org/Useful-Utilities/Status-Bars/)，我使用最保守的waybar。Hyprland的文档中建议使用定制版的waybar，也就是AUR上的`waybar-hyprland-git`。

```
# yay -S waybar-hyprland-git
```

然后对它进行配置。配置文件有两个，默认都在`.config/waybar/`下：

1. `config`：用JSON格式描述的状态栏结构。
2. `style.css`：CSS样式，用于调整布局的细节。

整体配置起来就像在写一个网页。

我个人比较喜欢像GNOME的状态栏，配置如下。

`config`中内容如下。主要是定义了启动应用、托盘、CPU内存占用、音量调整、亮度调整、工作区、网络显示、电量、日期时间这些内容。日期和时间默认只显示时间，鼠标悬停显示日期，右键单击用`lunar-date`显示农历。


```json
{
	&quot;layer&quot;: &quot;top&quot;,
	&quot;modules-left&quot;: [&quot;custom/launcher&quot;,&quot;cpu&quot;,&quot;memory&quot;,&quot;tray&quot;,&quot;hyprland/window&quot;],
	&quot;modules-center&quot;: [&quot;clock&quot;],
	&quot;modules-right&quot;: [&quot;wlr/workspaces&quot;, &quot;backlight&quot;, &quot;pulseaudio&quot;, &quot;network&quot;, &quot;battery&quot;,&quot;custom/power&quot;],
	
	&quot;pulseaudio&quot;: {
		&quot;tooltip&quot;: false,
		&quot;scroll-step&quot;: 5,
		&quot;format&quot;: &quot;{icon} {volume}%&quot;,
		&quot;format-muted&quot;: &quot;{icon} {volume}%&quot;,
		&quot;on-click&quot;: &quot;pavucontrol&quot;,
		&quot;format-icons&quot;: {
			&quot;default&quot;: [&quot;&quot;, &quot;&quot;, &quot;&quot;]
		}
	},
	&quot;hyprland/window&quot;: {
		&quot;format&quot;: &quot;&lt;b&gt;{}&lt;/b&gt;&quot;,
		&quot;max-length&quot;: 40
	},
	&quot;wlr/workspaces&quot;: {
		&quot;format&quot;: &quot;{icon}&quot;,
		&quot;on-click&quot;: &quot;activate&quot;,
		&quot;on-scroll-up&quot;: &quot;hyprctl dispatch workspace e+1&quot;,
		&quot;on-scroll-down&quot;: &quot;hyprctl dispatch workspace e-1&quot;
	},
	&quot;network&quot;: {
		&quot;tooltip&quot;: false,
		&quot;format-wifi&quot;: &quot; {essid}&quot;,
		&quot;format-ethernet&quot;: &quot;wired&quot;
	},
	&quot;backlight&quot;: {
		&quot;tooltip&quot;: false,
		&quot;format&quot;: &quot; {}%&quot;,
		&quot;interval&quot;:1,
		&quot;on-scroll-up&quot;: &quot;brightnessctl set 5%+&quot;,
		&quot;on-scroll-down&quot;: &quot;brightnessctl set 5%-&quot;
	},
	&quot;battery&quot;: {
        	&quot;states&quot;: {
            		&quot;good&quot;: 95,
            		&quot;warning&quot;: 40,
            		&quot;critical&quot;: 20
        	},
        	&quot;format&quot;: &quot;{icon}  {capacity}%&quot;,
        	&quot;format-charging&quot;: &quot; {capacity}%&quot;,
        	&quot;format-plugged&quot;: &quot; {capacity}%&quot;,
        	&quot;format-alt&quot;: &quot;{time} {icon}&quot;,
        	&quot;format-icons&quot;: [&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;]
	},
	&quot;tray&quot;:{
		&quot;icon-size&quot;:18,
		&quot;spacing&quot;: 10
	},
	&quot;clock&quot;: {
		&quot;format&quot;: &quot;&lt;b&gt;{:%H:%M}&lt;/b&gt;&quot;,
		&quot;tooltip-format&quot;: &quot;&lt;big&gt;{:%Y-%m-%d %A %Z}&lt;/big&gt;&quot;,
		&quot;on-double-click&quot;: &quot;gnome-clocks&quot;,
		&quot;on-click-right&quot;: &quot;kitty --hold lunar-date `date +&#39;%Y %m&#39;`&quot;
	},
	&quot;cpu&quot;: {
		&quot;interval&quot;: 15,
		&quot;format&quot;: &quot; {}%&quot;,
		&quot;max-length&quot;: 10,
		&quot;on-click&quot;: &quot;kitty htop&quot;
	},
	&quot;memory&quot;: {
	       	&quot;interval&quot;: 30,
		&quot;format&quot;: &quot; {}%&quot;,
		&quot;max-length&quot;: 10
	},
	&quot;custom/launcher&quot;:{
        	&quot;format&quot;: &quot;&quot;,
        	&quot;on-click&quot;: &quot;rofi -show drun&quot;,
        	&quot;on-click-right&quot;: &quot;rofi -show run&quot;
    	},
}
```

`style.css`样式如下：

```css
* {
	border: none;
	font-family: &quot;Fira Sans Compressed&quot;, &quot;Noto Sans CJK SC&quot;;
	font-size: 17px;
	min-height: 14px;
}

#waybar {
	background: rgba(20, 20, 20, 20);
	min-height: 20px;
	border-radius: 0px;
}

#window {
	margin: 6px;
	padding-left: 5px;
	padding-right: 5px;
	border-radius: 5px;
	transition: none;
	color: white;
	background: transparent;
	font-family: &quot;Fira Sans SemiBold&quot;, &quot;Noto Sans CJK SC&quot;;
}

#workspaces {
	color: #EEEEEE;
	background: rgba(50, 50, 50, 80);
	margin: 6px;
	font-family: &quot;Liberation Mono&quot;;
	border-radius: 5px;
}
#workspaces button {
	margin: 2px;
	color: white;
	background: rgba(50, 50, 50, 80);
}
#workspaces button:hover {
	color: black;
	background: rgba(200, 200, 200, 80);
}

#network,
#pulseaudio,
#battery,
#backlight {
	margin: 6px;
	padding-left: 5px;
	padding-right: 5px;
	border-radius: 5px;
	transition: none;
	background: transparent;
	color: white;
}

#network:hover,
#pulseaudio:hover,
#battery:hover,
#backlight:hover
{
	background: rgba(50, 50, 50, 80);
}

#battery.charging, #battery.plugged {
	color: white;
}

#battery.critical:not(.charging) {
    	animation-name: blink;
    	animation-duration: 0.5s;
    	animation-timing-function: linear;
    	animation-iteration-count: infinite;
    	animation-direction: alternate;
}

@keyframes blink {
    to {
        background-color: #BF616A;
        color: #B5E8E0;
    }
}

#clock {
	margin: 6px;
	padding-left: 5px;
	padding-right: 5px;
	border-radius: 5px;
	transition: none;
	color: white;
	font-size: 22px;
	font-family: Fira Code;
	background: transparent;
}

#memory {
	margin: 6px;
	padding-left: 5px;
	padding-right: 5px;
	border-radius: 5px;
	transition: none;
	color: white;
	background: rgba(0, 0, 0, 80);
}
#cpu {
	margin: 6px;
	padding-left: 5px;
	padding-right: 5px;
	border-radius: 5px;
	transition: none;
	color: white;
	background: rgba(0, 0, 0, 80);
}

#tray {
	margin: 6px;
	padding-left: 5px;
	padding-right: 5px;
	border-radius: 5px;
	transition: none;
	background: transparent;
}

#custom-launcher {
	font-size: 24px;
	margin: 6px;
	padding-left: 5px;
	padding-right: 5px;
	border-radius: 5px;
	transition: none;
	color: rgb(134, 216, 231);
    background: rgb(22, 19, 32);
}
```

最后在hyprland中启用。

### 应用程序选择菜单：rofi或者wofi

如果没有rofi或者wofi这类启动器，纯WM的体验真的会很糟糕。这里我使用rofi。

```
# pacman -S rofi
```

在Hyprland一侧的配置刚才已经完整了，如果按照我上面的配置文件，按`Mod`+`Tab`打开rofi。如果觉得默认的rofi比较丑，可以自己安装主题，比如[dracula](https://draculatheme.com/rofi)。

可以把`.config/rofi/config.rasi`中的`show-icons`设为`true`，这样rofi会自动显示图标。

### 通知：dunst

Hyprland默认没有显示通知的工具。要显示统治，dunst是不错的选择。

```
# pacman -S dunst
```

然后在`hyprland.conf`中调用。

```
exec-once=dunst
```

如果觉得dunst默认的主题太丑，也可以换主题，比如[dracula](https://draculatheme.com/dunst)。

### 锁屏

WM在锁屏这方面一直没有太好的解决方案。我目前习惯超时直接挂起。用swayidle实现超时自动调用，下面的timeout可以自己改，单位是秒。

```
exec-once=swayidle -w timeout 1800 &#39;systemctl suspend&#39; 
```

swaylock也是不错的选择，但我觉得不好用。

```
# yay -S swaylock-effects-git
```

然后修改配置`~/.config/swaylock/config`。

```
ignore-empty-password
font=Fira Sans Compressed

clock
timestr=%R
datestr=%a, %e of %B

screenshots

fade-in=0.2

effect-blur=20x2
#effect-greyscale
effect-scale=0.3

indicator
indicator-radius=360
indicator-thickness=60
indicator-caps-lock

key-hl-color=228833

separator-color=00000000

inside-color=00000099
inside-clear-color=ffd20400
inside-caps-lock-color=009ddc00
inside-ver-color=d9d8d800
inside-wrong-color=ee2e2400

ring-color=231f20D9
ring-clear-color=231f20D9
ring-caps-lock-color=231f20D9
ring-ver-color=231f20D9
ring-wrong-color=231f20D9

line-color=00000000
line-clear-color=ffd2000
line-caps-lock-color=009ddc00
line-ver-color=d9d8d800
line-wrong-color=ee2e2400

text-clear-color=ffd20400
text-ver-color=d9d8d800
text-wrong-color=ee2e2400

bs-hl-color=ee2e24FF
#caps-lock-key-hl-color=ffd204FF
#caps-lcok-key-hl-color=ee2e24FF
#caps-lock-bs-hl-color=ee2e24FF
#disable-caps-lock-text
text-caps-lock-color=000000FF
```

然后在`hyprland.conf`中调用。

```
exec-once=swayidle -w timeout 1800 &#39;swaylock&#39; 
```

### 终端：kitty

我始终觉得kitty不如gnome-terminal和konsole好用（但是比起alacritty，还是好用很多的）。如果追求既~~简陋~~轻量又好看，可以用。

```
# pacman -S kitty
```

`~/.config/kitty/kitty.conf`

```
font_size 13.0
font_family Jetbrains Mono
background_opacity 0.80

# keybinds

kitty_mod ctrl+shift

map kitty_mod+c copy_to_clipboard
map kitty_mod+v paste_from_clipboard

include theme.conf
```

`~/.config/kitty/theme.conf`

```
background            #202020
foreground            #d0d0d0
cursor                #d0d0d0
selection_background  #d0d0d0
color0                #151515
color8                #505050
color1                #ac4142
color9                #ac4142
color2                #7e8d50
color10               #7e8d50
color3                #e5b566
color11               #e5b566
color4                #6c99ba
color12               #6c99ba
color5                #9e4e85
color13               #9e4e85
color6                #7dd5cf
color14               #7dd5cf
color7                #d0d0d0
color15               #f5f5f5
selection_foreground #202020
```

### 截图和录屏工具

我尝试过用grim+slurp截图，但是后面感觉这样用实在是太简陋了。我个人更推荐直接用`hyprland-interactive-screenshot`。

```
# yay -S hyprland-interactive-screenshot-git
```

## 原理：Wayland桌面的架构

「之后填坑」


        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        Enchant-Gen——MC附魔指令生成器
        
        </title>
        <url>////nth233.top/posts/2023-02-25-enchant-gen.html</url>
        <search-text>
        
        
            我的世界
        
            附魔
        
            网页工具
        
            enchant-gen
        
            Minecraft
        
            enchantment
        
            mc
        
            nth233
        
            command
        
            generator
        
        
        
        我写了附魔生成器，[Enchant-Gen](https://fpg2012.github.io/enchant-gen/)。只要动动鼠标在网页上按几个按钮就能生成附魔工具所需的`/give`指令，粘贴到MC中可以直接使用，免去手敲指令的烦恼
        
        
        
你是否还在为MC附魔指令太长而烦恼？或是为了搞到一把“火焰附加2+击退2+抢夺3+经验修补+锋利5+横扫之刃3+耐久3”的钻石剑，不得不在铁砧上面敲敲打打半天。如果要输指令生成，那么是这样的

```
/give @p diamond_sword{&quot;Enchantments&quot;:[{&quot;id&quot;:&quot;fire_aspect&quot;,&quot;lvl&quot;:2},{&quot;id&quot;:&quot;knockback&quot;,&quot;lvl&quot;:2},{&quot;id&quot;:&quot;looting&quot;,&quot;lvl&quot;:3},{&quot;id&quot;:&quot;mending&quot;,&quot;lvl&quot;:1},{&quot;id&quot;:&quot;sharpness&quot;,&quot;lvl&quot;:5},{&quot;id&quot;:&quot;sweeping_edge&quot;,&quot;lvl&quot;:3},{&quot;id&quot;:&quot;unbreaking&quot;,&quot;lvl&quot;:3}]} 1
```

这个指令长度，手敲的速度甚至不如铁砧慢慢附魔。

因此我写了附魔生成器，[Enchant-Gen](https://fpg2012.github.io/enchant-gen/)。只要动动鼠标在网页上按几个按钮就能生成附魔工具所需的`/give`指令，粘贴到MC中可以直接使用。地址如下

[https://fpg2012.github.io/enchant-gen/](https://fpg2012.github.io/enchant-gen/)

&gt; 只支持1.8以上的版本

![网页截图](/assets/img/post/enchant-gen.png)

---

做这个东西的起因，其实是因为某一次挂机不小心被怪打死了，身上穿了很久的神装没找回来。因为懒得自己敲命令，就写了这个工具。不过事实证明，写这东西比自己真的去手敲命令费时多了……

Enchant-Gen的页面逻辑完全使用原生Javascript实现，没有使用任何框架，所以代码看起来很直截了当。附魔相关的数据直接存在一个数组里面。

欢迎在[GitHub](https://github.com/fpg2012/enchant-gen)上贡献代码和提交issue。

        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        如何更好地使用sushi
        
        </title>
        <url>////nth233.top/posts/2022-12-29-如何更好地使用sushi.html</url>
        <search-text>
        
        
            sushi
        
            blog generator
        
            博客生成器
        
            best practice
        
        
        
        今年三月份的时候因为受不了jekyll的种种问题，便花了点时间写了个自用的生成器。sushi的自定义灵活度应该要比jekyll和hugo之流要高得多，一旦配置完成，应该会十分顺手——所以就有了这篇介绍如何配置sushi的文章。
        
        
        
今年三月份的时候因为受不了jekyll的种种问题，便花了点时间写了个自用的生成器。sushi的自定义灵活度应该要比jekyll和hugo之流要高得多，一旦配置完成，应该会十分顺手——所以就有了这篇介绍如何配置sushi的文章。

## 使用sushi的理由

灵活性和自定义是sushi的特色。

sushi力争做到**KISS**〔Keep It Simple Stupid〕，不做任何多余的事情。sushi只做一件事情，用一句话概括，就是：根据各处的配置，调用converter把你的博文转化为html格式，然后放到约定好的位置，**其余的事情一概不做**。

这件事情十分简单，使得sushi的代码本身十分的简单。而“其余的事情”就交给其余的程序去做，sushi不会强制用户选择哪个程序来完成这些”外围“的工作，允许用户发挥想象力，进行灵活的自定义，比如：

1. 把markdown或者其他格式翻译为html（交给pandoc，或者用户自己写一个翻译器）

2. 主题管理

3. 部署（如果在本地测试，可以用sfz；正式部署可以用nginx、caddy等）

4. 统一管理图片等资源（这个工作完全是多余的）

5. 全文检索（交给专门的全文检索软件）

但也不是说sushi什么都不做，sushi本身围绕着组织站点结构这一任务展开，对于分类〔taxonomy〕、分页〔pagination〕、套模板〔template〕也有简单但是灵活的接口。

后记中具体举了一些例子，说明为什么这些灵活性是很重要的。多个简单的程序之间分工合作，也能实现很多复杂的任务，而灵活性是这种分工的前提。

当然，如果你不需要这些灵活性，不在乎自定义性，而是需要一个包打天下、囊括所有任务的生成器，那么就没有必要使用sushi，可能你更适合WordPress或者Jekyll、Hugo。

## sushi原理简介

因为sushi遵循KISS原则，所以使用sushi必须对其原理有个大致的了解。

### 站点结构

sushi对于站点结构的要求很少，但站点必须放在一个文件夹内（下面称为站点目录）。站点目录下必须要有`_site.yml`（站点配置文件），以及`_converters`（转换器目录）、`_includes`（页面片段目录）、`_templates`（模板目录）。sushi会自动把生成后的站点放到`_gen`（生成目录）中。如下：

```
site-example # 站点目录
├── _converters # 转换器目录
├── _gen # 生成目录
├── _includes # 页面片段目录
├── _site.yml # 站点配置
└── _templates # 模板目录
```

这些下划线`_`开头的目录和文件总体的作用，就是为sushi生成页面提供必要的信息，具体作用后面将会解释。

&gt; 这些目录和文件的命名是可以修改的，sushi不强制用户使用默认的命名。如果要使用自定义命名，则需要在命令行参数或者配置文件中指明。

### 工作流程

首先，sushi会读取`_site.yml`作为站点配置文件，构建。然后紧接着读取`_gen`，再然后是`_converters`、`_templates`、`_includes`。读取结束后，sushi就掌握了这个站点整体有哪些配置、有哪些可用的转换器、哪些可用的模板、哪些页面片段、已经生成了哪些页面。

接下来，sushi开始遍历整个站点树，所有不以下划线`_`开头的文件和文件夹都会被访问一遍，访问的同时sushi用自己内部的数据结构表示这一站点树。以`_`下划线开头的文件和目录都会被sushi忽略。

然后进入生成阶段。sushi根据遍历得到的站点树，开始进行生成。sushi会在`_gen`目录中创建一个**一模一样**的站点树。在这个生成后的站点树中，所有的页面文件都被替换为渲染后的HTML文件或者其他的某种文件。

这里展开说明生成一个页面的过程：首先会读取它的扉页内容〔Front Matter〕，然后读取其主体部分。如果配置文件中指定了生成器，那么就调用指定的生成器（生成器是一个可执行程序，sushi会把页面的主体部分送入生成器的标准输入，然后读取其标准输出作为渲染的结果）。接着sushi把渲染后的结果，连同站点配置、站点树、扉页中的页面配置、所需的**页面片段**填入指定的liquid**模板**中，最后把最终结果输出到站点树的对应位置；如果没有指定生成器，sushi则执行默认操作，即原封不动地把文件复制到生成的站点树的对应位置。

再展开说套用模板的过程：sushi使用liquid模板语言，有关详情可以参照liquid的文档。sushi会将读取的站点配置存到`site`对象中，扉页的配置存到`page`对象中，分页器相关的内容放到`paginator`对象中，站点树的内容存放到`sitetree`对象中等等。这些对象使得模板编写变得十分灵活（虽然有时可能会显得不太优雅），具体详情可以参照README。

## 基本使用

开始之前先安装sushi。目前（2022.12.29）暂时建议使用cargo安装。

```
cargo install sushi-gen
```

然后，找个站点主题（或者自己做一个），比如[Empty](https://github.com/fpg2012/sushi-theme-empty)。

```
git clone https://github.com/fpg2012/sushi-theme-empty
```

然后，找个合适的位置，然后创建站点，假设你的站点名字叫做`Hey`

```
ssushi init --theme ${path_to_theme} Hey
```

把`${path-to-theme}`替换成你刚才下载的主题的路径。然后站点就创建完成了。

以Empty主题为例，所有posts文件夹下的内容都会被列到主页`index.html`中。以这个主题出发，参考文档进行自定义应该会容易很多。

## 外部工具

#### Pandoc

sushi本身不提供页面渲染的功能，它只调用你提供的渲染器。这里十分推荐使用pandoc，因为它很方便自定义。如果在可以写个shell脚本直接调用Pandoc。比如在Linux下，可以写成：

```
#!/bin/bash
pandoc -t html
```

如果引入了自定义的pandoc过滤器，那么自行添加相应的参数。然后给这个脚本可执行权限，然后在`_site.yml`中指定使用它。假如这个脚本叫做`convert.sh`，那么`_site.yml`中这样写可以让sushi把所有的md文件都转换成html：

```yaml
convert_ext: [&quot;md&quot;] # 让sushi把md文件看作是需要渲染的页面文件，而非普通文件
converter_choice:
  &quot;md&quot;: &quot;convert.sh&quot; # md文件选用刚才的脚本进行转换
```

#### GitHub Pages

要部署到GitHub Pages，首先你需要创建一个GitHub项目，然后启用GitHub Pages功能。然后把生成的`_gen`目录中的内容传上去。

如果你想要把站点的源文件和生成后的页面放在一个仓库中。可以考虑使用git worktree。比如说把源文件放在`main`分支中，把生成后的页面放在`gh-page`分支中，可以这样：

```
git checkout -b gh-page # 创建gh-page分支
git checkout -b main # 回到main分支
git worktree add --track - gh-page _gen
```

然后删除`_gen`中的所有内容。那么之后sushi生成的东西会自动放到gh-page分支中。详情参考worktree的用法。

#### Pygments

实现代码高亮。有现成的用pygments实现高亮的pandoc filter，直接使用之。

#### SFZ

sfz可以简化在本地部署静态页面，这对于发布前预览页面尤其有用。sushi没有类似`jekyll serve`的功能，这部分工作就交给sfz或者其他代劳了。下面给出了一种方法。

首先，把`_site.yml`复制一份，重命名为`_test.yml`。然后，修改`_test.yml`，把里面的`url`改成`http://localhost:5000`或者其他本地的地址。然后添加一项：

```
gen_dir: _test_gen
```

之后，可以用以下命令模拟`jekyll serve`。

```
ssushi build -A -c _test.yml &amp;&amp; sfz -r _test_gen
```

#### Just

sushi生成站点的命令可能会显得有点长。just可以帮助缩短这些命令。

可以创建一个`justfile`：

```makefile
all:
	ssushi build -A

inc:
	ssushi build

test:
	ssushi build -c _test.yml
	sfz -r _test_gen

test-all:
	ssushi build -A -c _test.yml
	sfz -r _test_gen

clean-gen:
	cd _gen
	rm -rf *
	cd ..

deploy-gen:
	cd _gen
	git add .
	git commit -m &quot;Update: `date`&quot;
	git push
	cd ..

deploy: deploy-gen
	git commit -a
	git push
```

之后要生成站点，直接敲`just`，增量生成则敲`just inc`。

要执行类似`jekyll serve`的操作，直接`just test-all`或者`just test`。

你可以按自己的需要修改`justfile`。

## 主题编写

实际上sushi并不存在什么主题，所谓主题其实也和一般站点没有任何差别。`ssushi init`做的事情其实是把主题的那个文件夹原封不动地拷贝过来。

一般而言，编写主题和写一般的网站基本没有区别，主要的区别在于使用liquid的模板。关于liquid模板，可以参照其文档。

这里建议对于一般的博客，至少准备`page`、`post`、`archive`、`home`四个模板便于用户使用，如果可以的话还可以加入rss的模板。模板之间可以有“继承关系”，比如套post模板后的内容需要再套入`page`模板，这些可以通过模板的扉页来实现。

而通用的Javascript脚本、页面header、footer等部分放到`_includes`文件夹中，用liquid的`include`语句包含进来。

上面提到的Empty主题是个不错的起点，可以在其基础上参照文档进行修改和扩展。

## 后记

我最初编写sushi其实是为了解决两个简单的问题：

1. 在渲染页面时直接转换数学公式。

2. 图片可以随心所欲地放在任何位置，并被任何一个markdown页面引用。并且确保在markdown编辑器（比如Typora中）可以正确地查看图片。

这两个看起来微不足道的需求，居然没有办法很好地用Jekyll或者Hugo实现。

第一条不能解决，是因为它们为了追求渲染速度和开箱即用，使用了自己的markdown渲染器，用户很难做修改，除非改源码。但如果要渲染数学公式，就非得修改markdown的渲染过程不可，到这里我就卡住了。主流解决方案是把数学公式渲染的工作甩锅给前端JavaScript，但这会带来一大堆问题；还有人修改了Hugo的源码，但这也非常麻烦。

第二条不能解决，是因为它们对站点结构做了太多的限制，连插图这点小事也要管。为什么就不能保持我站点树的结构不要做修改呢？

所以就有了sushi。渲染器自己定，那就没有什么不能渲染的了（刚好有Pandoc这个神器，自己写filter、reader、writer，什么文档都能转换）；不改变站点树，那么自定义站点、使用现有工具都会变得简单。

当然sushi也有自己的问题：

1. 为了灵活性牺牲了速度。sushi为了调用用户提供的、外部的渲染器，需要通过管道传递数据，速度掉了一大截。如果你用pandoc，并且使用Python编写的pandoc过滤器，那就更慢了。增量生成部分地解决了速度慢的问题，但目前的增量生成仍不完美，依然有待改进。

2. 开箱即用有一定的门槛。

3. 用的人少

当然这些缺点都是可以克服的……比如速度慢，你可以修改ssushi的源码（和Jekyll与Hugo的源码不同，sushi的源码很短），使它直接调用Rust编写的渲染器。

        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        使用无头的wayvnc做远程桌面——乱水
        
        </title>
        <url>////nth233.top/notes/wayvnc.html</url>
        <search-text>
        
        
            note
        
            破事水
        
            远程桌面
        
            wayvnc
        
            wayland
        
            sway
        
        
        
        虽说服务器上一般没有必要跑图形界面，但还是偶尔会碰到有些烦人的程序CLI不能跑端解决的问题。不过前几天我发现了WayVNC，十分适合没有物理屏幕的远程服务器。一方面是FAQ里写得清清楚楚，另一方面是用wlroots做合成器〔Compositor〕的窗口管理器，比如sway，十分的轻量。图省事我用了Nix来安装。
        
        
        
## 起因

虽说服务器上一般没有必要跑图形界面，但还是偶尔会碰到有些烦人的程序CLI不能跑，比如百度网盘。

正巧，远古MC存档的备份就在百度网盘上……最后折腾了半天，也没成功把远程桌面搞起来，最后还是用`Baidupcs-Go`这个第三方CLI客户端解决的问题。

不过前几天我发现了`WayVNC`，十分适合没有物理屏幕的远程服务器。一方面是FAQ里写得清清楚楚，另一方面是用`wlroots`做合成器〔Compositor〕的窗口管理器，比如`sway`，十分的轻量。

## 搭建

因为阿里云的服务器用的是debian 10 buster这个远古版本，包基本上旧得不行，比如就没有sway。要安装可以参照[sway的wiki关于debian 10的这篇文章](https://github.com/swaywm/sway/wiki/Debian-10-\(Buster\)-Installation)手动编译，麻烦的很。所以选择用Nix。

### 安装Nix

参照[Nix的文档](https://nixos.org/download.html#download-nix).

执行脚本，安装Nix（多用户）:

```bash
$ sh &lt;(curl -L https://nixos.org/nix/install) --daemon
```

然后重启一下服务器。Nix就安装好了。

### 安装所需的软件包

```bash
nix-env --install --attr sway wayvnc
```

我习惯安个浏览器和终端仿真器

```bash
nix-env --install --attr firefox konsole
```

&gt; 为什么是Qt写的konsole？因为我发现更轻量的kitty和alacritty都没法用，似乎都和openGL没法使用有关。至于为什么openGL没法用，我不太懂。

然后记得配置一下sway。

### 启动`wayvnc`


首先进入`nix-shell`。

```bash
nix-shell -p sway wayvnc firefox konsole
```

然后按照[WayVNC的FAQ](https://github.com/any1/wayvnc/blob/master/FAQ.md)，以无头〔headless〕模式启动sway。

设置三个环境变量

```bash
export WLR_BACKENDS=headless
export WLR_LIBINPUT_NO_DEVICES=1
export WAYLAND_DISPLAY=wayland-1
```

然后启动sway：

```bash
sway &amp; # 加上&amp;是为了sway可以在后台运行
```

然后启动WayVNC

```bash
wayvnc 0.0.0.0 2304 # 端口号改成自己需要的
```

如果一切正常，那么现在可以用VNC工具，比如`vinagre`，连接远程桌面了。

&gt; 注意！如果不进一步配置，那么这个连接没有任何密码、没有加密，也就不安全。如果要长期开着WayVNC，建议加上身份校验，参考[WayVNC的GitHub页面](https://github.com/any1/wayvnc)。

如果要调整屏幕的大小，开启sway之后执行下面的命令：

```bash
swaymsg output &quot;HEADLESS-1&quot; resolution 1920x1080 # 大小自己调
```

## 后记

虽说服务器带宽有点小，画面传过来有点卡顿掉帧，但毕竟不是不能用……应付偶尔的需求足够了。


        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        找中位数的线性时间算法
        
        </title>
        <url>////nth233.top/notes/median-algo.html</url>
        <search-text>
        
        
            算法
        
        
        
        困难的不是算法的思想，而是证明时间复杂度是线性。
        
        
        
困难的不是算法的思想，而是证明时间复杂度是线性。首先可以修改快排的Partition步骤，获得一个期望时间为$O(n)$的算法，这里姑且称之为**算法1**。用一些特别的办法改进Partition时**主元**的选择，可以获得一个最坏情况下时间复杂度为$O(n)$的算法，这里姑且称之为**算法1a**

# 算法1

步骤：

1. 任选一个元素$x$作为主元，应用快排$\text{Partition}$的对数组进行分块（小的在前），记分块后$x$的下标为$k$
2. 若$k\lt \lfloor n/2\rfloor$，那么说明中位数大于$x$，对右侧执行第一步
3. 若$k\gt \lfloor n/2\rfloor$，那么说明中位数小于$x$，对左侧执行第一步
4. 若$k = \lfloor n/2 \rfloor$，那么$x$就是中位数

$\text{Partition}$伪代码如下

```
partition(A[], l, r) {
    i = l-1, j = l
    p_i = random(l, r) // 等概率在[l, r)中选取一个整数
    swap(A[r-1], A[p_i])
    pivot = A[r-1]
    while (j &lt; r) {
        if (A[j] &lt;= pivot) {
            i = i + 1
            swap(A[j], A[i])
        }
        ++j
    }
    return i // 返回分块后主元的位置
}
```

下面分析时间复杂度，可以得到递归式

$$
T(n) = T(\max \{ n-k, k\}) + O(n)
$$

我们假设选取主元是随机的，并且每个元素有相等的概率（即$P = 1/n$）被选为主元，那么对上式取期望

$$
\begin{aligned}
E[T(n)] &amp; = E[T(\max \{ n-k, k\}) + O(n)] \\
&amp;= E[T(\max \{ n-k, k\})] + O(n) \\
&amp;= \frac{1}{n} \sum_{i=0}^{n-1}E[T(\max \{ n-k, k\})] + O(n)
\end{aligned}
$$

注意到，当$k &lt; \lfloor n/2 \rfloor$时，$n-k \ge k$，否则$k \ge n-k$，那么在上面的那个合式中，$T(\lfloor n/2 \rfloor + 1), T(\lfloor n/2 \rfloor + 2) , \dots, T(n-1)$出现了两次，所以得到

$$
\begin{aligned}
E[T(n)] &amp;= \frac{1}{n} \sum_{i=0}^{n-1}E[T(\max \{ n-k, k\})] + O(n) \\
&amp;\le \frac{2}{n} \sum_{i=\lfloor n/2\rfloor}^{n}E[T(i)] + O(n)
\end{aligned}
$$

我们假设存在$n_0$，使$n &lt; n_0$时有$E[T(n)] = O(1)$

那么$n = n_0$时，有

$$
E[T(n)] = O(n)
$$

&gt; $n_0$的存在是合理的，规模很小的时候，可以视为$O(1)$。因为递归到最后，肯定有个终止条件。比如说在这个算法中，分块的区间等于1的时候，我们可以立即得到结果。

因此我们有理由假设一直到$n_1$，都存在$c$使得$E[T(n)] \le cn$，当$n &gt; n_1$时，把上式带入递归式

$$
E[T(n)] \le \frac{2c}{n} \frac{ (\lfloor n/2 \rfloor + n )\lfloor n/2 \rfloor }{2} + O(n) = O(n)
$$

由此证明了$E[T(n)] = O(n)$

不过这个算法最坏情况是$O(n^2)$的。

&gt; 考虑一直选取最小或者最大的元素作为主元的情况。

# 算法1a

虽然说算法1实现起来并不困难，但是最坏时间有时候会退化到$O(n^2)$，其实我们完全有办法改进选取主元的方式，使之最坏情况下时间复杂度是$O(n)$。

改进后的选取主元的步骤：

1. 将数组切分成$\lfloor n/5 \rfloor$个长度为5的数组（如果最后一组不足5个元素，就丢弃掉这组，所以是向下取整）
2. 找出每个切分后的组的中位数，逻辑上构成一个新的数组$B$
3. 调用本算法，找到中位数数组的中位数，将其作为算法1第一步的主元

在数组$B$的中位数大于至多$\lfloor 7n/10 \rfloor$个元素，小于至多$\lfloor 7n/10 \rfloor$个元素。那么算法1的递归式可以改成。

$$
T(n) \le T\left( \frac{7n}{10} \right) + O(n)
$$

同样假设有$T(n) \le cn$，代回即可验证这一假设是正确的

$$
T(n) \le \frac{7cn}{10}  + O(n) = O(n)
$$

        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        曲率相关
        
        </title>
        <url>////nth233.top/notes/curvature.html</url>
        <search-text>
        
        
            note
        
            math， 曲率
        
        
        
        
        
## 定义

$$
K = \left|\frac{d\alpha}{dr}\right|
$$

$$
\rho = 1/K
$$

## 计算

&gt;  下面暂时省略绝对值

$$
\begin{aligned}
K &amp;= \frac{d\arctan y&#39;}{\sqrt{dx^2 + dy^2}} 
= \frac{\frac{y&#39;&#39;}{1+(y&#39;)^2}dx}{dx\sqrt{1+(y&#39;)^2}} \\
&amp; = \frac{y&#39;&#39;}{\left[1+(y&#39;)^2\right]^{3/2}}
\end{aligned}
$$

如果由参数方程确定

$$
\begin{cases}
x = \phi (t) \\
y = \psi(t)
\end{cases}
$$

那么有

$$
\begin{aligned}
K &amp;= \frac{ \frac{d}{dx}\left( \frac{dy}{dx} \right) }{\left[1 + (\frac{dy}{dx})^2 \right]^{3/2} } \\
&amp; = \frac{ \frac{d}{dt}\left( \frac{\psi&#39;(t)}{\phi&#39;(t)} \right)\frac{1}{\phi&#39;(t)} }{\left[1 + (\frac{\psi&#39;(t)}{\phi&#39;(t)})^2 \right]^{3/2} } \\
&amp; = \frac{ \frac{\phi&#39;(t)\psi&#39;&#39;(t) - \psi&#39;(t) - \phi&#39;&#39;(t)}{\phi&#39;^3(t)}}{\left[1 + (\frac{\psi&#39;(t)}{\phi&#39;(t)})^2 \right]^{3/2} } \\ 
&amp; = \frac{\phi&#39;(t)\psi&#39;&#39;(t) - \psi&#39;(t) - \phi&#39;&#39;(t)}{\left(\phi&#39;^2(t) + \psi&#39;^2(t)\right)^{3/2} }
\end{aligned}
$$

        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        Wallis公式
        
        </title>
        <url>////nth233.top/notes/Wallis.html</url>
        <search-text>
        
        
            note
        
            math， 积分
        
            Wallis
        
        
        
        
        
## 定义

$$
S_n = \int_0^{\pi/2} \sin^n x dx
$$

## 结论

$$
\begin{aligned}
&amp; S_n = \frac{n-1}{n}S_{n-2} \\
&amp; S_0 = \frac{\pi}{2} \\
&amp; S_1 = 1
\end{aligned}
$$

另外注意

$$
S_n = \int_0^{\pi/2} \sin^n x dx = \int_0^{\pi/2} \cos^n x dx
$$

## 推导

主要使用分部积分。$S_0$和$S_1$的计算这里省略。

另外可以注意，改变$S_n$的定义为余弦的积分，结论依然成立。

$$
\begin{aligned}
S_n &amp;= \int_0^{\pi/2} \sin^n x dx  \\ 
= &amp; -\int_0^{\pi/2} \sin^{n-1} x d\cos x \\
= &amp; -\left[\left. \sin^{n-1} x\cos x\right|_0^{\pi/2} - \int_0^{\pi/2}\cos x d\sin^{n-1} x\right] \\
= &amp; \int_0^{\pi/2}\cos^2 x (n-1)\sin^{n-2} x dx \\
= &amp; \int_0^{\pi/2}(1-\sin^2 x)(n-1)\sin^{n-2} x dx \\
= &amp; (n-1)\int_0^{\pi/2}\sin^{n-2}xdx - (n-1)\int_0^{\pi/2} \sin^n xdx \\
= &amp; (n-1)S_{n-2} - (n-1)S_n \\ 
\Rightarrow &amp; S_n = \frac{n-1}{n}S_{n-2}
\end{aligned}
$$

        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        《春分之后》
        
        </title>
        <url>////nth233.top/posts/2022-08-19-《春分之后》/index.html</url>
        <search-text>
        
        
            读书笔记
        
        
        
        看完《我是猫》和《后来的事》之后，我越来越喜欢夏目漱石的这种风格。对心理活动细致的描写、对生活平凡与不平凡的事情的灵活分析，当然还有不时出现的对当时总体社会环境的评价。最重要的是，读来让人有代入感，但又不会因此陷入焦虑。因此那之后我又趁着双十一，一口气买了好几本夏目漱石，其中一本我先看完了，就是这本《春分之后》。本来半年前就能看完的，但是因为种种原因，最后几十页半年来一直没看，终于功亏一篑。最近这两个月（尤其是这周），才集中精力一口气看完。总体上看，我不知道这本书在说什么主题，但是阅读起来就是很有意思。也许作者并不打算就某一主题进行探讨，也许作者想把他感兴趣的一切都糅合进去聊聊，就像《我是猫》。总之这种风格我挺喜欢。但可能是原先在报纸上连载的缘故，为了吊足读者的胃口，夏目漱石一次可能只写一点点，反映到书上来说，就是整篇小说读起来不太连贯。故事被很不自然地切割到一个又一个短短的小节里面，真是让一百年后的读者又爱又恨。
        
        
        
&gt; 不知道这本书在说什么主题，但是阅读起来就是很有意思。也许作者并不打算就某一主题进行探讨，也许作者想把他感兴趣的一切都糅合进去聊聊，就像《我是猫》。总之这种风格我挺喜欢。
&gt; 

![封面](./cover.jpg)

看完《我是猫》和《后来的事》之后，我越来越喜欢夏目漱石的这种风格。对心理活动细致的描写、对生活平凡与不平凡的事情的灵活分析，当然还有不时出现的对当时总体社会环境的评价。最重要的是，读来让人有代入感，但又不会因此陷入焦虑。

因此那之后我又趁着双十一，一口气买了好几本夏目漱石，其中一本我先看完了，就是这本《春分之后》。本来半年前就能看完的，但是因为种种原因，最后几十页半年来一直没看，终于功亏一篑。最近这两个月（尤其是这周），才集中精力一口气看完。

总体上看，我不知道这本书在说什么主题，但是阅读起来就是很有意思。也许作者并不打算就某一主题进行探讨，也许作者想把他感兴趣的一切都糅合进去聊聊，就像《我是猫》。总之这种风格我挺喜欢。

但可能是原先在报纸上连载的缘故，为了吊足读者的胃口，夏目漱石一次可能只写一点点，反映到书上来说，就是整篇小说读起来不太连贯。故事被很不自然地切割到一个又一个短短的小节里面，真是让一百年后的读者又爱又恨。

---

和我看过的前两本夏目的书一样，人物并不多，不妨在这里直接把所有主要的登场人物都罗列出来：

- 敬太郎：“我”，大学毕业，为工作奔忙，内心渴望冒险
- 森本：原先和敬太郎住在同一公寓。阅历丰富，满是离奇的冒险经历，但是生活并不稳定。后来去了大连电气公园。给敬太郎留下了一个自己雕刻的蛇头竹制手杖。
- 须永市藏：敬太郎的好友，父亲留下了大量遗产，因此生活优渥，衣食无忧。之前在大学学习法律，未婚。胆怯，却可能又想探索。
- 须永的母亲：传统日本女性，了解繁琐的旧礼数。经典催婚角色。
- 田口：须永的姨丈，实业家。善于处理人际关系，却又喜欢作弄人，给了敬太郎一个工作。
- 松本：须永的舅舅。自称高等游民，虽然没有工作，但是生活依然没有经济压力。对社会颇有自己的思考。
- 千代子：田口的女儿。出生时田口随口答应了须永母亲的请求，同意把千代子嫁给须永。和须永算是“青梅竹马”，相互了解，但又过于了解。

之外还有若干纯粹推动情节的角色，就不一一在这里列出了。

看到我列出的角色简介，恐怕你也知道这本书总体上没什么新意，甚至可以看成是《后来的事》的重置版，只不过把几个角色的特征重组了一下，拆分到不同的人身上。总是有个怯懦者，有个无业奔波者，有个玩世不恭者，有个生活无忧但未婚的富家子，有个独立观察社会的“置身事外”者，有个八面玲珑的实业家。不过总体上虽然人设上显得有些重复，具体情节上还是有点意思的。

---

大体的情节很简单。

### 1

首先，故事从敬太郎和森本在澡堂相遇开始。敬太郎仰慕森本丰富而离奇的冒险经历，因此希望森本多说一些故事。过后不久森本也几次来敬太郎家里坐客，敬太郎也以酒会之，席间森本提到了去北海道做测绘的经历，说起大风、竹林、饥饿等等离奇的事情。在竹林时，森本取了一根竹子雕刻成了现在他手上的那把蛇头手杖。但奇怪的是，在那之后，火车站职员森本就再也没有出现过。房东见森本不来，问敬太郎也得不到任何消息，就准备处理掉森本屋里的东西抵房租。在这部分故事的最后，森本给敬太郎写了一封信，主要谈及房租和屋内财产的处理问题，但是也提到了他已经到了大连。

森本允许房东处理所有的屋内财产，唯独把那把手杖给了敬太郎。

我初看这书的时候还以为森本在故事中只是暂时离开，之后会再出现，于是满怀期待地一直往后翻。不过还真就没有后续了。这个角色的登场，可能主要是为了给出那把手杖（笑）。

### 2

接下来，敬太郎去找朋友须永了。前面也说了，由于父亲的阴功，须永母子二人的生活很是优渥，也很清静。工作也不必须永发愁，自有亲戚帮忙。但是须永本人不想做官，也不想做公司职员，至今还在家待业。敬太郎过后又来了几次须永家，其中一次看到了年轻女子的木屐，便心生好奇。

敬太郎想借用须永的关系，帮忙找个工作，说“什么工作都行”。须永联系了田口，田口也答应见敬太郎一面。结果到了约定时间，田口却因为家里客人还没走，正在下围棋为由，让敬太郎吃了闭门羹。敬太郎正想回去找须永吐槽，谁知道只有须永的母亲在家。须永的母亲是个传统的日本妇女，上来就讲起一套客套话，把敬太郎请到屋里，然后滔滔不绝地开始讲起来，也说起了他们的家事。

其实这里作者已经透露了须永家的大体情况，不过第一次阅读恐怕读者不会在意这么多细节，看下来只记得须永母亲说了田口有两个女儿，也就是须永的表妹。作者有意让读者把上次敬太郎看到的木屐和须永的表妹联系起来，但又没有给出证据，只是提出这一悬疑。须永的母亲最后打破田口给敬太郎古板的影响，说这个人喜欢耍宝，但是也比较稳重，让敬太郎不要着急，事情最后肯定会有个交待。

### 3

敬太郎带上手杖，最后见到了田口，田口听说敬太郎想做侦探，就给了他一个「跟踪」的任务。其实完全可能是田口现编的。不过敬太郎哪里知道，直接就照做了，某日几点到几点之间，某地电车站，等待一个穿黑礼服，额头上有痣的人。敬太郎于是就带上手杖去做任务了，内心觉得做这种事情不合道德，也不合常理，但是心理却比较渴望刺激。但是过了任务时间，那个人还是没有出现，倒是有个年轻女子在同一个位置和敬太郎一起等待。黑礼服的人过了很长时间才出现，和那个年轻女子一起取了西餐馆。

敬太郎一路跟踪，最后还是在雨中把黑礼服的人跟丢了。

几天之后找田口回报，田口像作弄傻子一样对待敬太郎，不过演的倒是很真。先是对敬太郎没有按时结束任务回来回报表示不满，然后问起黑礼服和年轻女子的关系。敬太郎不知道，也不敢乱说，田口于是就派他直接去找黑礼服的人询问。

敬太郎第一次没带手杖，结果又吃了闭门羹，理由是“下雨天不会客”。第二次带上了手杖，天气也是晴朗的，成功见到了松本，黑礼服的人就是松本。松本简直就是另一个须永，一样无业，生活也没有经济压力，不过松本已经结婚生子了。而车站那个年轻女子，就是田口的女儿千代子。松本提醒敬太郎被田口耍了，这是敬太郎才醒悟过来。

### 4

最后田口给敬太郎安排了工作，敬太郎和须永一家，特别是须永和千代子二人，也渐渐熟络起来。渐渐敬太郎从千代子口中得知了为什么松本下雨天不会客（当然，带着他的手杖）：松本最爱的小女儿死于雨天，而那天正好有客人来。

夏目漱石对于这些生活小事的描写实在是十分生动，也许他本人也经历过类似的事情，生活环境也和他的小说里类似，让人读来很有真实感，也更容易引发共鸣。

### 5

敬太郎之后又多次去须永家里，也越发对千代子和须永二人的关系感到好奇。正好有千代子婚事的传言，因此他带上了手杖去找须永。（结果须永说出了长长的一大段文字）

千代子出生的时候，田口半开玩笑地同意把千代子许配给须永。

须永的母亲之所以会提出请求，是因为须永并非她所生，而是女佣生的。为了家族血统、光宗耀祖，须永的母亲一心想让二人结为连理。

&gt; ps. 难道和表妹结婚在日本这么普遍吗？安倍的家族也谱系看起来也怪怪的
&gt; 

然而二人因为从小到大一直在一块，彼此之间没有距离感，须永反而不太愿意娶千代子。

以此为背景，须永说了一堆乱七八糟的二人往事。活泼又有大小姐气质的千代子，这种性格让须永又有感又无感。千代子有时也暗示须永可以娶她，甚至还留着须永小时候给千代子画的画。然而须永像是故意忽略这一信号，有意把事情往后拖，不想作出决断。

须永真的一点感觉都没有吗？也不是，心理上似乎一直认为他占有着千代子。一次须永和田口全家去海边玩，叫上了强壮而又风度翩翩的高木，千代子的潜在提亲者之一。此人让须永内心莫名心生嫉妒。然而须永又是那样的自卑懦弱，没等大家一起回东京，就自己先回了。海边度假归来之后，千代子到须永家住了一晚，甚至和须永母亲一起梳了发髻。那一晚须永完全没睡好。

须永的妒忌和焦躁，虽然没有直接表达，但千代子都看在眼里。但千代子有时却觉得自己不是须永喜欢的样子，探不清须永到底心理是爱还是不爱，两人就这样在离心力和向心力的作用下维持这一种不上不下的状态。

&gt; 看到这里我真的心里有蚂蚁在爬，须永是真的废。须永和母亲的关系也很复杂，母亲自私又慈爱，让须永特别矛盾。
&gt; 

### 6

敬太郎到这就退场了，接下来的“我”就变成了松本。说的也是写无关紧要、用来给故事一个结局的话。须永最后去旅行了，他和千代子的关系最后也没有结局。

青梅竹马这种关系没有办法维持，要么成为恋人，要么变成好久都联系不上几回的普通朋友，甚至形同陌路，绝无稳定的中间状态可言。

---

说实在的，看完这个故事我没有什么感觉，虽然我也随着情节起伏把自己置入故事中去，但是真的没有特别强烈的共鸣或是启发，就像是喝了一杯糖水，嘴里微微有点甜味，但却谈不上更深刻的感觉。

倒是有些无关紧要的细节让我感兴趣，比如敬太郎去算卦的过程，比如他们的生活日常和精神状态，但也就止于此了。也许作者就是喜欢把故事的种子培养成幼苗，读者也乐见之，至于什么主题，什么中心，什么主旨，早就溶解到故事当中去了，只不过味道很淡，说不清也道不明。

        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        广义积分及其敛散性
        
        </title>
        <url>////nth233.top/notes/反常积分.html</url>
        <search-text>
        
        
            note
        
            math， 广义积分
        
        
        
        
        
## 定义

广义积分的定义不在此重复。大致就是让上限或者下限趋于奇点或者无穷的极限。比如$f(x)$在$(a, b)$上可积，那么

$$
\int_a^b f(x)dx = \lim_{p\to a, q\to b}\int_p^q f(x) dx
$$

$g(x)$在$[a, +\infty)$上可积，那么

$$
\int_a^{+\infty} g(x) dx = \lim_{p\to +\infty} \int_a^{p} g(x)dx
$$

## 敛散性的判断

### 从定义出发

显然可以从极限的定义出发，判断广义积分定义式里面的那个极限是否存在。这里用趋于无穷的极限举例。（$f(x)$在$[a, +\infty)$上可积，那么）

一方面，可以直接求不定积分，得到原函数$F(x)$，然后用Newton-Leibniz公式，那么就是研究这个极限是否存在

$$
\lim_{x \to +\infty} F(x)
$$

另一方面，可以用判断极限存在的方法。比如Cauchy极限存在准则。极限存在，意味对任意的$\epsilon$，取充分大的$p$、$q$总有下式成立：

$$
\left|\int_p^q f(x) dx\right| \lt \epsilon
$$

## 比较法

有两个结论需要记住

| 积分                               | 收敛条件        | 发散条件      |
| -------------------------------- | ----------- | --------- |
| $\int_1^{+\infty}\frac{dx}{x^p}$ | $p &gt; 1$     | $p \le 1$ |
| $\int_0^{1}\frac{dx}{x^p}$       | $0 &lt; p &lt; 1$ | $p \ge 1$ |

&gt; 类比调和级数，记住$f(x) = 1/x$的情况，然后其他的可以比出来。

&gt; 进一步有下面的定理：
&gt; 
&gt; | 区间             | 条件1              | 条件2                   |
&gt; | -------------- | ---------------- | --------------------- |
&gt; | $(a, b]$       | $0 &lt; \alpha &lt; 1$ | $(x-\alpha)^{\alpha}|f(x)|$有界 |
&gt; | $[a, +\infty)$ | $\alpha &gt; 1$     | $x^{\alpha}|f(x)|$有界          |
&gt; 
&gt; 两条的结论都是广义积分$\int_?^? f(x)dx$绝对收敛。
&gt; 
&gt; 这个结论是从高木的《定本解析概论》里抄出来的，不过我感觉这个结论不是那么好用，也不好记。

---

从辅导书里面抄个例子出来，讨论一下反常积分的敛散性：

$$
\int_1^{+\infty} \frac{(\arctan \frac{1}{x} )^\alpha}{ \left[ \ln (1 + 1/x) \right]^{2\beta}}dx
$$

---

设

$$
f(x)=\frac{(\arctan \frac{1}{x} )^\alpha}{ \left[ \ln (1 + 1/x) \right]^{2\beta}}
$$

则有

$$
\lim_{x\to\infty} \frac{f(x)}{x^{\alpha-2\beta}} = 1
$$

意味着对于足够大的$N$，$x &gt; N$时，有

$$
(1 - \epsilon)x^{\alpha-2\beta} &lt; f(x) &lt; (1 + \epsilon)x^{\alpha-2\beta}
$$

就有

$$
\int_N^{+\infty}(1 - \epsilon)x^{\alpha-2\beta} &lt; \int_N^{+\infty}f(x) &lt; \int_N^{+\infty}(1 + \epsilon)x^{\alpha-2\beta}
$$

可以注意到两侧的敛散性始终是一致的，而且结论在上面的表格中可查。两侧收敛，根据夹逼准则，中间也收敛，两侧都趋于无穷大，中间也趋于无穷大。

---

## $\Gamma$函数

经常忘记，这里顺便记录一下

$$
\Gamma(x) = \int_0^{+\infty} t^{x-1}e^{-t} dt
$$

$$
\Gamma(x+1) = x! (x \in \mathbb N)
$$

$$
\Gamma(1/2) = \sqrt{\pi}
$$

&gt; 怎么记准确呢？对于整数相当于阶乘换种写法，对于二分之一，则相当于高斯函数变个形。

        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        双曲函数和反双曲函数笔记
        
        </title>
        <url>////nth233.top/notes/sinh.html</url>
        <search-text>
        
        
            note
        
            math， 双曲函数
        
        
        
        双曲函数的相关内容偶尔要用，却经常忘记，尤其是反双曲函数的表达式，以及和它们相关的积分
        
        
        
## 定义

$$
\sinh x = \frac{e^x-e^{-x}}{2}
$$

$$
\cosh x = \frac {e^x + e^{-x}}{2}
$$

&gt; 考虑复变函数$\cos x$和$\sin x$沿着虚轴切开。由此可以理解一些性质

## 求导和积分

$$
(\sinh x)&#39; = \cosh x
$$

$$
(\cosh x)&#39; = \sinh x
$$

$$
\int \sinh x = \cosh x +C
$$

$$
\int \cosh x = \sinh x + C
$$

## 反函数

推导，设$y = \sinh x$，那么

$$
\begin{aligned}
&amp; y = \frac{e^x-e^{-x}}{2} \\
\Leftrightarrow &amp;\ 2ye^x = e^{2x} - 1 \\
\Leftrightarrow &amp;\ e^{2x} - 2ye^x - 1 = 0 \\ 
\Rightarrow &amp;\ e^x = \frac{2y + \sqrt{4y^2 + 4}}{2} = y + \sqrt{y^2 + 1} \\
\Rightarrow &amp;\ x = \ln\left(\sqrt{y^2+1} + y\right)
\end{aligned}
$$

如果设$y = \cosh x$，那么

$$
\begin{aligned}
&amp; y = \frac{e^x+e^{-x}}{2} \\
\Leftrightarrow &amp;\ 2ye^x = e^{2x} + 1 \\
\Leftrightarrow &amp;\ e^{2x} - 2ye^x + 1 = 0 \\ 
\Rightarrow &amp;\ e^x = \frac{2y + \sqrt{4y^2 - 4}}{2} = y + \sqrt{y^2 - 1} \\
\Rightarrow &amp;\ x = \ln\left(\sqrt{y^2-1} + y\right)
\end{aligned}
$$



得到反函数的表达式

$$
\sinh^{-1} x = \ln\left(\sqrt{x^2 + 1} + x\right)
$$

$$
\cosh^{-1} = \ln\left(\sqrt{x^2 - 1} + x\right)
$$

## 反函数的求导

$$
(\sinh^{-1} x)&#39; = \frac{1}{\sqrt{u^2 + 1}}
$$

$$
(\cosh^{-1} x)&#39; = \frac{1}{\sqrt{u^2 - 1}}
$$

如果不知道上述两个公式，在推导上述等号右边两个函数的的积分的时候，需要用到三角换元法。设$x = \tan \theta$

$$
\int \frac{1}{\sqrt{x^2 + 1}} dx = \int \sec \theta d\theta
$$

如果不记得$\sec\theta$的积分，那还得接着推

$$
\int \sec x d x = \int \frac{\cos x \ dx}{\cos^2 x} = \int \frac{d \sin x}{1 - \sin^2 x}
$$

设$t = \sin x$，那么

$$
\begin{aligned}
&amp; \int \frac{dt}{(1-t)(1+t)} \\ 
=&amp; \int \frac{1}{1+t}dt + \int \frac{1}{1-t}dt \\
=&amp;\frac{1}{2} \ln|1+t| - \frac{1}{2}\ln|1-t| + C \\
=&amp; \frac{1}{2}\ln\left| \frac{1+t}{1-t} \right| + C
\end{aligned}
$$

代回去，得到

$$
\int \sec x = \ln | \sec x + \tan x| + C
$$

使用这一公式，得到我们最后想要求的积分，不过代回之前需要做一些准备

$$
|\cos x| = \frac{1}{\sqrt{\tan^2 x + 1}}
$$

于是就可以代回了

$$
\int \frac{dx}{\sqrt{x^2 + 1}} = \ln\left(\sqrt{x^2 + 1} + x\right) + C
$$

真是大费周章。

## 图像

猜猜哪条对应哪个函数

![](./img/2.png)



        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        阿里云轻量应用服务器开swap——乱水
        
        </title>
        <url>////nth233.top/notes/ali_swap.html</url>
        <search-text>
        
        
            note
        
            云服务
        
            破事水
        
            swap
        
        
        
        之前的云服务器到期了，这次看阿里新加坡的轻量应用服务器价格不错，就买了。但是到手之后发现如果启动mc服务器，服务器的内存有时会有些不足。大概是因为服务器加载新区块的时候可能会突然增加一些内存需求。然而系统内存不够用，服务端就崩掉了。此时一般都会想到开swap文件，方便系统在缺内存的时候把一些进程suspend，swap到交换空间里面。然而谁知道阿里的这个破镜像竟然没有自带`mkswap`和`swapon`这种基础命令。因此需要手动安装。我用debian，所以下面的内容都针对debian（理论上debian系的都一样）
        
        
        
## 起因

之前的云服务器到期了，这次看阿里新加坡的轻量应用服务器价格不错，就买了。但是到手之后发现如果启动mc服务器，服务器的内存有时会有些不足。大概是因为服务器加载新区块的时候可能会突然增加一些内存需求。然而系统内存不够用，服务端就崩掉了。

此时一般都会想到开swap文件，方便系统在缺内存的时候把一些进程suspend，swap到交换空间里面。然而谁知道阿里的这个破镜像竟然没有自带`mkswap`和`swapon`这种基础命令。因此需要手动安装。我用debian，所以下面的内容都针对debian（理论上debian系的都一样）

## 流程

```
sudo apt reinstall util-linux
```

然后新建一个4G大小的空文件

```
sudo fallocate -l 1G /swapfile
```

&gt; 或者也可以用`dd`.
&gt; 
&gt; ```
&gt; sudo dd if=/dev/zero of=/swapfile bs=1024 count=1G
&gt; ```
&gt; 
&gt; `bs`表示一次操作的字节数。
&gt; 
&gt; 有空我可以整理一下`dd`的常见用法。

接着修改权限

```
sudo chmod 600 /swapfile
```

然后`mkswap`

```
sudo mkswap /swapfile
```

接下来就可以启用了

```
sudo swapon /swapfile
```

## 调整`swappiness`

理论上至此应该完成了，但是阿里的镜像中默认把swappiness参数调成了0，这会导致内核根本不会使用swap。所以需要把这个参数调整到大于0的某个值，比如60。数字越高，表示swap使用策略越激进。

```
sudo sysctl vm.swappiness=50
```

## 额外操作

如果要停止使用交换文件，使用`swapoff`。

```
sudo swapoff -v /swapfile
```

另外，按上述方式配置，每次服务器重启都得重新手动启动swap。如果要开机自动启用交换文件，可以修改`/etc/fstab`。添加下面这行，这样每次开机都会自动挂上交换文件。

```
/swapfile	swap	swap	default	0	0
```

## 关于swap的讨论

swap其实并不能完美解决内存不足的问题，一旦涉及到硬盘I/O，很多工作都会变得很慢。不过我的目的只是让mc服务器这个内存占用大户在偶尔需要大量内存的时候，不至于因为内存不足而直接崩掉。那么swap已经让我达到目的了。

## 参考

本文的内容并非十分的“原创”，参考了以下来源

- [Create a Linux Swap File - linuxize](https://linuxize.com/post/create-a-linux-swap-file/)
- [What does swappiness do and how does it affect swap_tendency?](https://access.redhat.com/solutions/103833)
- [util-linux - wikipedia](https://en.wikipedia.org/wiki/Util-linux)

        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        论有线网络的重要性
        
        </title>
        <url>////nth233.top/n233/2022-07-08-论有线网络的重要性.html</url>
        <search-text>
        
        
            233
        
            破事水
        
            网络
        
        
        
        
        
        
        
在这个遍地都是WiFi信号的时代，在家里面拉网线似乎显得有点多次一举。原本我也是这样想的，直到暑假回家，被居民区拥挤不堪的WiFi信号搞得脾气暴躁。

虽然我的房间离路由器有点远，但是肯定在信号覆盖范围以内。理论上是这样，但实际用起来网络就是非常不稳定，时有时无，时而慢，时而非常慢。大概是因为邻居的路由器离我的房间太近了，而且这附近肯定家家都有路由器，信道的争抢显得尤为严重。而且我家路由器功率比不过隔壁，也只支持2.4GHz的频段，在军备竞赛中处于绝对的下风。我不想卷入军备竞赛，因此才决定花几块钱，拉一条丑陋不堪的网线到房间里面。

果然效果立竿见影，仅仅改变连网方式，现在Arch更新系统的速度比原先快了5倍不止，一劳永逸（应该）地解决了无线网络不稳定的问题。电脑连网还是能有线尽量有线为好。

        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        sushi-gen 0.2.7发布
        
        </title>
        <url>////nth233.top/n233/2022-07-04-sushi新版本发布.html</url>
        <search-text>
        
        
            233
        
            破事水
        
            sushi更新
        
        
        
        sushi-gen 0.2.7发布，添加了一个重要的新功能
        
        
        
经过一天的读代码和半天的改代码，sushi-gen的更新完成了。

本次更新添加了增量生成的功能。所谓增量生成，意思就是只生成修改过的页面，之前生成过的页面如果这次没有任何修改，就不会重复生成。实现原理基于文件元数据中的“修改日期”，类似GNU make。这项功能解决了一个痛点，大大提高了blog的生成速度。

另外本次更新精简了sushi-gen的控制台输出。

本次更新还修复了`convert_to_ext`不生效的bug。虽然说blog一般不会用到这个功能。

        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        破事水专栏开辟了
        
        </title>
        <url>////nth233.top/posts/2022-07-04-破事水专栏开辟了.html</url>
        <search-text>
        
        
            瞎写
        
            blog
        
        
        
        
        
[破事水专栏](https://nth233.top/n233/)开辟了。

欢迎[RSS订阅](https://nth233.top/n233/rss.xml)。


        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        第一条破事水
        
        </title>
        <url>////nth233.top/n233/firstn322.html</url>
        <search-text>
        
        
            233
        
            破事水
        
        
        
        第一条破事水
        
        
        
这是第一条破事水！

以后就在这里记录一些既不适合归类到blog（原创性不足、完整度不够）、又不适合放进笔记（知识性不足）、但是却值得公开记录的超短文本，比如各种琐事记录和进度记录。（开辟这个专栏并不只是为了宣示自己的存在，这点我得牢记。）

也许这些文本更适合发在社交媒体上面，但是我不想用微博，推特也少用，发在blog这里有独特的优势，毕竟blog完全由我掌握。所以不管发在哪里，不如都在这里也发一份。

&gt; One must wait until the evening to see how splendid the day has been.

        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        SVD的理解
        
        </title>
        <url>////nth233.top/posts/2022-05-14-SVD的理解/index.html</url>
        <search-text>
        
        
            math
        
            线性代数
        
            SVD
        
        
        
        奇异值分解〔SVD，Singular Value Decomposition〕在不少方面有应用，不过初看的话不太容易理解。本文整理了我对SVD的理解，难免存在不严谨的地方，不过希望可以帮助读者理解SVD。
        
        
        
奇异值分解〔SVD，Singular Value Decomposition〕在不少方面有应用，不过初看的话不太容易理解。本文整理了我对SVD的理解，难免存在不严谨的地方，不过希望可以帮助读者理解SVD。

了解一个方法的**动机**是很重要的。我觉得从优化问题入手，并且借助几何方法，比较容易理解SVD的动机。

## 餐前甜点：一个优化问题

现有$m\times n$矩阵$\bold A$，要找到一个$m$维向量$\bold x$，使二者乘积的模最小，也就是求以下优化问题的解：

$$
\begin{aligned}
 &amp;\min \ ||\bold A \bold x|| \\
&amp;\mathrm{s.t.} ||\bold x|| = 1
\end{aligned}
$$

&gt; 如果用线性变换的方式表述问题，线性变换$A \in \mathcal{L}(V,W)$，$x \in V$，求$x$使$||Ax||$最小。

### 问题的转化

可以注意到，最小化$||\bold A \bold x||$其实就是最小化$||\bold A \bold x||^2$，稍一改写，其实就是

$$
||\bold A \bold x||^2 = ||(\bold A\bold x)^T(\bold A \bold x)|| = ||\bold x^T (\bold A^T \bold A) \bold x||
$$

可以注意到$\bold A^T \bold A$是个对称方阵（如果看作是算子，那么是个「自伴算子」），因为它的转置和自身相等。于是接下来重点放在$\bold A^T\bold A$这个「性质良好」的矩阵上，将其记为$\bold M$。

$$
(\bold A^T \bold A)^T = \bold A^T (\bold A^T)^T = \bold A^T \bold A
$$

任何对称方阵都对应一个**二次型**，而这里，我们最小化问题的目标函数正是$\bold M$对应的二次型。

### 具体实例的可视化

在开始介绍SVD之前，可以先来观察几个实例。

比如说我们假定：

$$
\bold M = \begin{pmatrix} 2 &amp; 0 \\ 0 &amp; 1\end{pmatrix}
$$

在二维平面可视化这个矩阵对应的线性变换是很容易的，$y$方向上不动，$x$方向上拉伸到原先的两倍。我们限定了$||\bold x|| =1$，其实就是限定了在**单位圆**上找点。因此我们关心单位圆被这个线性变换映射成了什么图形。

答案是椭圆。如图，单位圆上的点被映射到椭圆上，如果说$\bold x$的图像是单位圆，那么$\bold M \bold x$的图像就是图中的椭圆，很显然，从图中可以看出，$\bold x = (0, \pm 1)^T$的时候，映射后的向量模最小。

![第一个例子](example0.png)

&gt; 本例比较简单，如果一定要计算才放心的话，高中数学的方法尚可解决。

上面那个实例中$\bold M$是对角阵。如果$\bold M$不是对角阵是什么情况？下面来看第二个实例。

假设有

$$
\bold M = \begin{pmatrix}
2 &amp; 1 \\ 1 &amp; 1
\end{pmatrix}
$$

$\bold M\bold x$的图像依旧是椭圆，下图中$\bold u$被映射到$\bold v$，方向发生了改变。经过$\bold M$的映射，只有特征向量的方向不会发生改变，因为如果$\bold v$是特征向量，则有$\bold M\bold v = \lambda \bold v$。而恰恰就是特征向量的方向缩小或扩张得最厉害，可以对着下图验证一下。。

![第二个例子](example1.png)

&gt; 为什么还是椭圆？
&gt; 
&gt; 这涉及到一个关键的事实：如果我们重新找一对标准正交基，那么$\bold M$在新的基下可以写成一个对角矩阵，那么在新的基下（或者说，新的座标系下），$\bold M\bold x$的方程可以写成标准椭圆方程。
&gt; 
&gt; 为什么可以换座标系这样求解？可以注意到，旧的基显然是标准正交基，如果新的基也是标准正交基，那么在这两个基之间进行变换，其实相当于只是做了一下旋转+轴对称，**没有改变向量的模长**，因此在新的基下求解是可行的。想象一下，把上图的蓝色椭圆“摆正”之后再进行求解。
&gt; 
&gt; 那么为什么可以找到让$\bold M$对角化的标准正交基呢？因为$\bold M$的几个**特征向量恰恰是相互正交**的！读者可以就本例的$\bold M$验证一下。这涉及到**谱定理**，稍后将证明。

&gt; 读者不妨考虑一下如果对称矩阵$\bold M$不满秩的情况（或者说线性变换把高维空间压缩到低维空间是怎样的情况），映射的结果其实是一个退化的椭圆。

到这里，我们大致有解决问题的思路了：找到映射后的椭圆，然后把它摆正，然后容易知道横向和纵向总是“拉伸”或者“压缩”最显著的方向，据此可以求解。这种思想可以推广到高维。

## 谱定理

上面的注解提到了谱定理。谱定理保证了$\bold M$在某个标准正交基下是对角矩阵，也就是可以**正交对角化**。

因此作为SVD的准备，需要先证明谱定理〔the spectral theorem〕。

我们可以从两个不同的角度表述谱定理。

&gt; 本文中谱定理特指「**实**谱定理」，简单说就是针对实数构成的矩阵／实向量空间。

#### 表述

可以这样表述谱定理。

&gt; $n \times n$的矩阵$A$
&gt; 
&gt; 1. $A$有$n$个实特征值（算上重数）
&gt; 2. $A$的特征向量正交
&gt; 3. $A$可以被正交对角化

也可以这样表述谱定理：

&gt; $T \in \mathcal L(V)$，那么以下条件等价：
&gt; 
&gt; 1. $T$是自伴的
&gt; 
&gt; 2. $V$有一个由$T$的本征向量组成的规范正交基
&gt; 
&gt; 3. $T$有关于$V$的某个规范正交基有对角矩阵

#### 概念准备

定理的表述出现了一些国内教学中不常出现的概念，需要先对这些概念及其性质作出解释。

**算子**：$T \in \mathcal L(V, V)$，也就是从$V$映射到$V$的线性变换，则$T$称为$V$上的算子，记为$T \in \mathcal L(V)$

**伴随**〔adjoint〕：给定$T \in \mathcal L(V, W)$（也就是从向量空间$V$到向量空间$W$的线性映射），如果有$T^*\in (W, V)$，取$v \in V$，$w \in W$，使

$$
\langle Tv, w \rangle = \langle v, T^*w\rangle
$$

那么$T^*$称为$T$的伴随。

可以证明一定存在这样的伴随，具体参考LADR。这里只举LADR中的一个例子，通过这个例子可以感受一下为什么伴随一定存在。

&gt; $T(x_1, x_2, x_3) = (x_2 + x_3, 2x_1)$
&gt; 
&gt; $$
&gt; \begin{aligned}
\langle (x_1, x_2, x_3), T^* (y_1, y_2) \rangle = &amp; \langle T(x_1, x_2, x_3), &gt; (y_1, y_2) \rangle \\
= &amp; \langle (x_2 + 3x_3, 2x_1, (y_1, y_2) \rangle \\
= &amp; x_2y_1 + 3x_3y_1 + 2x_1y_2 \\
= &amp; \langle (x_1, x_2, x_3), (2y_2, y_1, 3y_1) \rangle
\end{aligned}
&gt; $$
&gt; 
&gt; 所以$T^*(y_1, y_2) = (2y_2, y_1, 3y_1)$

**伴随相当于矩阵转置**。对于实线性变换，其伴随对应的矩阵，就是它本身的矩阵的转置。在此不证明。另外，容易证明算子和其伴随有相同的本征向量。

**自伴**〔self-adjoint〕：和自己的伴随相等，称为自伴。**自伴相当于矩阵对称**。

#### 谱定理的简单证明

&gt; 这部分证明可能不严谨，和LADR书上的不同。

如果实线性变换$T\in \mathcal(V)$有$\mathrm{dim} V$个线性无关的本征值，那么谱定理的证明很容易。

在这个条件下，我们来证明自伴算子对于某个标准正交基有对角矩阵。

取$T$的特征向量为基，那么在这个基下，$T$对应的矩阵是个对角矩阵。如果我们对这个基做一下格拉姆-施密特正交化〔Gram-Schmidt Method〕，得到基的就是正交的，而且$T$对应新的基的矩阵就是个上三角矩阵。

&gt; 如果对此不理解，随便找个基，亲手算算，自然就懂了。比如说有一组基$v_1, v_2, \dots , v_n$，$n = \mathrm{dim}V$。$T$关于这组基有的矩阵是对角矩阵，就是说$Tv_k = \lambda_k v_k$。正交化之后得到$u_1, u_2, \dots, u_n$。
&gt; 
&gt; $$
&gt; \begin{aligned}
u_1 &amp;= v_1 \\
u_2 &amp;= v_2 - (v_2\cdot u_1)u_1 \\
u_3 &amp;= v_3 - (v_3\cdot u_2)u_2 - (v_3\cdot u_1)u_1 \\
&amp; \cdots
\end{aligned}
&gt; $$
&gt; 
&gt; 因此$T$对应$u_1, u_2, \dots, u_n$这组基的矩阵
&gt; 
&gt; $$
&gt; \begin{pmatrix}
\lambda_1 &amp; -v_2\cdot u_1 &amp; -v_3\cdot u_1 &amp; \cdots\\
0 &amp; \lambda_2  &amp; -v_3\cdot u_2 &amp; \cdots\\
0 &amp; 0 &amp; \lambda_3 &amp; \cdots \\
\vdots
\end{pmatrix}
&gt; $$
&gt; 
&gt; 是个上三角矩阵。

而对于自伴算子，这个上三角矩阵就是对角矩阵。

考虑算子$T$，其对应的矩阵为$\bold M$，那么$T^*$对应的矩阵是$\bold M^T$（算子伴随相当于矩阵转置）。根据上面的结果，如果取基适当，可以把$\bold M$化为上三角矩阵，对应地，$\bold M^T$就是下三角矩阵。

如果$T$自伴，那么$T = T^*$，那么有$\bold M = \bold M^T$。上三角矩阵和下三角矩阵相等，当且仅当对角线以外的部分全部为0。因此$\bold M$是对角矩阵。

也就是说，我们找到了一组基，使得$T$对应的矩阵是对角矩阵。对这组基做一下标准化，就得到一组标准正交基，归一化不改变向量的方向，$T$关于这组标准正交基的矩阵依然是对角矩阵。即任取一个$w_k = \frac{u_k}{||u_k||}$，有$Tw_k = \mu w_k$。

根据本征向量的定义，这组标准正交基中的每个向量都是$T$的本征向量。

最后一步很容易证明：如果一个线性变换关于某个标准正交基有对角矩阵，则它是自伴矩阵。

至此，我们证明了添加额外条件后的谱定理。

#### 实谱定理的完整证明

要证明完整的实谱定理，关键在于去掉$T$有$n$个本征向量这一假设。但我觉得没有必要把完整的实谱定理的证明放上来，毕竟我们的目标是SVD。对证明感兴趣，可以参阅LADR。

如果要沿着上面的证明证下去，首先得证明$T$作为自伴算子，一定有本征值。接下来，得证明$T$即使没有$\mathrm{dim}V$个本征向量，也能够找到一个标准正交基。基本思想就是将$T$限制到更低维的空间$U$，使他在里面满足上面“青春版”的谱定理，然后不断补充和这些$U$的基正交的向量。

## 主菜：奇异值分解

有了谱定理，接下来的证明会轻松很多。我们**可以**先把**椭圆**“摆正”，然后再进行求解。

### 等距同构和正交矩阵

算子$S\in \mathcal L (V)$是等距同构，当且仅当它保范数，即$||Sv|| = ||v||$

其实就是说，算子对应的矩阵是正交矩阵。这点容易证明。

$$
\begin{aligned}
||Sv||^2 &amp;= ||Sv\cdot Sv|| \\
&amp;= ||v^TS^TSv|| \\
&amp;= ||v||^2 = ||v\cdot v|| = ||v^Tv||
\end{aligned}
$$

所以$S^TS = I$，即$S$是正交矩阵。

### 正算子和半正定矩阵

正算子：$T\in \mathcal L(V)$，且$T$自伴，对任意$v\in V$，$\langle Tv, v\rangle \ge 0$，那么是$T$是正算子。

半正定矩阵：对任意二次型$\bold x$，$\bold x^T \bold A \bold x \ge 0$，那么$\bold A$是半正定矩阵。

正算子的矩阵就是半正定矩阵。

定义正算子$T$的**平方根**R，为满足$R^2 = T$的算子。

可以证明，$T$和$R$的所有本征值非负，前者的本征值是后者对应本征值的平方。据此可以继续证明，正算子的平方根是唯一的，而且是自伴的。

之后把$R$记为$\sqrt{T}$

### 极分解

设$T\in \mathcal L (V)$。那么$T^*T$是正算子。换一种说法，就是说任取矩阵$\bold A$，$\bold A^\bold A$是半正定的对称矩阵。证明不难，我们已经证明了$T^*T$是自伴的，接下来只要证明它满足正算子的定义。

$$
\langle T^*T, v \rangle = \langle Tv, Tv \rangle = ||Tv||^2 \ge 0
$$

然后终于可以引入极分解了！

设$T \in \mathcal L(V)$，那么存在$S \in \mathcal L(V)$，使$T = S\sqrt{T^*T}$

为什么可以这样分解？推导如下：

$$
\begin{aligned}
||Tv||^2 &amp;= \langle Tv, Tv \rangle \\
 &amp;= \langle T^*Tv, v \rangle \\
&amp; = \langle \sqrt{T^*T}\sqrt{T^*T}v, v \rangle \\
&amp;= \langle \sqrt{T^*T}v, \sqrt{T^*T}v \rangle = ||\sqrt{T^*T}v||^2
\end{aligned}
$$

所以有$||Tv|| = ||\sqrt{T^*T}v||$。定义$S_1$为满足以下条件的算子

$$
S_1Tv = \sqrt{T^*T}v
$$

可以证明$S_1$可以扩张为一个等距同构，在此不表，细节参阅LADR。

&gt; 极分解告诉我们，如果一个矩阵没法对角化，没关系，我们把它“旋转”一下可以变成一个对称矩阵，就肯定可以对角化了。旋转不影响范数，也就是保持向量长度不改变，刚好符合我们的要求。

### 奇异值分解

奇异值：$\sqrt{T^*T}$的本征值

终于可以引入奇异值分解了。注意到，根据谱定理，$\sqrt{T^*T}$是可以正交对角化的，求它的本征值即可。也就是说，有正交矩阵$V$

$$
\sqrt{T^*T} = V\Sigma V^T
$$

再使用极分解，就得到了方阵的奇异值分解。下面$S$、$V$、$U$都是正交矩阵。

$$
T = S \sqrt{T^*T} = SV \Sigma V^T = U\Sigma V^T
$$

可以把这个结论推广到方阵以外的矩阵，在需要的地方补0即可。

&gt; 求奇异值不一定要对算子开平方，因为$\sqrt T$和$T$本身有相同的特征向量，前者对应的特征值是后者特征值开平方。

$U$的列向量称为左奇异向量，$V$的列向量称为右奇异向量。

## 餐后消食片：回到优化问题

谱定理告诉我们，映射之后是椭圆、可以把椭圆摆正求解。

而摆正之后，横向和纵向就是拉伸、压缩最显著的地方，拉伸和压缩的倍数就是特征值。奇异值的意义，就是这些倍数。

奇异值分解把这一切串了起来。

现在还差一步没有证明，为什么“横向和纵向就是拉伸、压缩最显著的地方”，在前面我们是通过几何直觉判断出来的，这不利于推广到高维。现在来证明。

所谓横向和纵向，其实就是基的方向。$\bold A$如果有本征值，记最大的为$M$，最小的为$m$。

那么$||\bold A\bold x|| = \sum_1^n \lambda_k x_i \ge m\sum_1^n x_i$。并且这个最小值是可以取到的，当$x=(x_1, x_2, \cdots, x_n)^T$是$m$对应的特征向量的时候，取得这个最小值。最大值同理可得。

----

至此我们已经知道如何求解优化问题，找到$\bold x$，使

$$
\begin{aligned}
 &amp;\min \ ||\bold A \bold x|| \\
&amp;\mathrm{s.t.} ||\bold x|| = 1
\end{aligned}
$$

方法就是，对$\bold A$做奇异值分解得到$A = U\Sigma V$（即求出$\bold A^T\bold A$的特征值，然后逐一开平方），取出最小的特征值，找到它在$U$中对应的奇异向量即为我们想求的。

---

最后再提供一个具体例子。设上面优化问题的$ A$是

$$
A = \begin{pmatrix}
1 &amp; 1 \\ 0 &amp; 1
\end{pmatrix}
$$

$A$是不能对角化的，但是$A^TA$可以。

```python
Lambda, P = np.linalg.eig(np.array([[1, 1], [1, 2]]))
```

得到

```
P = array([[-0.85065081, -0.52573111],
       [ 0.52573111, -0.85065081]])
Lambda = array([0.38196601, 2.61803399])
```

所以$\sqrt{A^TA} = P\sqrt{\Lambda} P^T$，就是

```
np.matmul(P, np.matmul(np.diag(np.sqrt(Lambda)), P.T))
```

得到

```
array([[0.89442719, 0.4472136 ],
       [0.4472136 , 1.34164079]])
```

可以把它的图像画出来，如下图，访问[这里](asset/svd.html)可以进行交互。可以看到只是做了个旋转罢了，这就是极分解做的事情。

![最后一个例子](geogebra-export.png)

顺便可以通过[可交互的图](asset/svd.html)验证一下SVD的结果和画出来的图是否相合。

```python
U, Sigma, VT = np.linalg.svd(np.array([[1, 1], [0,1]]))
```

```
U = array([[ 0.85065081, -0.52573111],
       [ 0.52573111,  0.85065081]])
Sigma = array([1.61803399, 0.61803399])
VT = array([[ 0.52573111,  0.85065081],
       [-0.85065081,  0.52573111]])
```

        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        Jacobian Matrix笔记
        
        </title>
        <url>////nth233.top/notes/jacobian_simple_proof.html</url>
        <search-text>
        
        
            math
        
            雅可比矩阵
        
        
        
        之前学高数的时候最怕的就是用雅可比矩阵〔Jacobian Matrix〕，只觉得形式难记，意义也不明。根本原因就是学的时候*自己没有推*，老师也没有细讲，作业也不怎么需要泳道，于是稀里糊涂就过去了。复习的时候发现只要推一下就不难，不推则永远没法搞懂。
        
        
        
之前学高数的时候最怕的就是用雅可比矩阵〔Jacobian Matrix〕，当时只觉得形式难记，意义也不明。根本原因就是学的时候*自己没有推*，老师也没有细讲，作业也不怎么需要用，于是稀里糊涂就过去了。

复习的时候发现只要推一下就不难，不推则永远没法搞懂。

## 隐函数求导

完整地说是「隐函数存在定理」。对于函数下面方程组确定的隐函数

$$
\begin{cases}
F(x,y,u,v) = 0 \\
G(x,y,u,v) = 0
\end{cases}
$$

如果$F$和$G$在$(x_0, y_0, u_0, v_0)$处连续可微，雅可比行列式$J \ne 0$，那么在这个邻域唯一确定了$u = u(x,y)$和$v = v(x,y)$，只是没有明写出来而已。同时可以得到一系列偏导数的，比如$u_x$。

$$
J = 
\begin{vmatrix}
F_u &amp; F_v \\ G_u &amp; G_v
\end{vmatrix}
$$

那么怎么推呢？定理的前半部分，即“确定隐函数”，在这里不证明（可以先利用单调性，证明双变量的隐函数存在定理，然后用数学归纳法，暂时没看懂怎么归纳）。和计算偏导数相关的部分在这里推导。

对$x$求偏导

$$
\begin{cases}
F_uu_x + F_vv_x = -F_x \\
G_uu_x + G_vv_x = -G_x
\end{cases}
$$

根据克莱姆〔Crame〕法则，可以解这个线性方程组，得到

$$
\begin{cases}
u_x = \frac{1}{J}\begin{vmatrix}-F_x &amp; F_v \\ -G_x &amp; G_v\end{vmatrix} \\
v_x = \frac{1}{J}\begin{vmatrix}F_u &amp; -F_x \\ G_u &amp; -G_x\end{vmatrix}
\end{cases}
$$

如果引入记号

$$
\frac{\partial (F, G)}{\partial (x, y)} = \begin{vmatrix}F_x &amp; F_y \\ G_x &amp; G_y\end{vmatrix}
$$

那么就得到了我们熟悉的结论。

$$
\begin{cases}
u_x = -\frac{1}{J}\frac{\partial (F, G)}{\partial (x, v)} \\ 
v_x = -\frac{1}{J}\frac{\partial (F, G)}{\partial (u, x)}
\end{cases}
$$

同理可以得到$u_y$和$v_y$。

## 重积分换元

$$
\iint_C F(x, y) \ \mathrm{d}x\mathrm{d} y
$$

如果有

$$
\begin{cases}
x = \phi (u, v) \\
y = \psi (u, v)
\end{cases}
$$

那么可以换元（先不细究换元的条件）

$$
\iint_{C&#39;} F(x, y) \left|\frac{\partial (x, y)}{\partial (u, v)}\right| \ \mathrm{d}u\mathrm{d} v
$$

又出现了雅可比式。证明需要引入叉积。

如果考虑微分的方向，面积元$dxdy$实际上是$|\vec {dx} \times \vec {dy}|$

接下来就是要考察换元之后面积元发生了什么变化。

$$
\begin{aligned}
\vec {dx} \times \vec {dy} &amp; = (x_u \vec {du} + x_v \vec{dv}) \times (y_u \vec {du} + y_v \vec{dv}) \\
&amp; = x_uy_v \vec{du}\times \vec{dv} + x_vy_u \vec{du}\times \vec{dv} \\
&amp; = \begin{vmatrix}x_u &amp; x_b \\ y_u &amp; y_v\end{vmatrix} \vec{du}\times \vec{dv} \\
&amp; = \frac{\partial (x, y)}{\partial (u, v)}\vec{du}\times \vec{dv}
\end{aligned}
$$

上面的推导说明，面积元的变化和雅可比式相关。


        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        TCP拥塞控制
        
        </title>
        <url>////nth233.top/notes/tcp-congestion-control.html</url>
        <search-text>
        
        
            computer
        
            计算机网络
        
            TCP/IP
        
        
        
        关于TCP的拥塞控制。本文简要概述了为何要引入拥塞控制，拥塞控制面临的问题，以及TCP拥塞控制相关的标准。
        
        
        
## 为何要引入拥塞控制

首先，如果不进行拥塞控制，控制各个发送端发包的速度，那么网络将拥挤不堪，各方都难以成功发送消息。并且仅仅在网络层控制拥塞是治标不治本的，因为拥塞的根源在于发送端过快的发送速度，给网络层带来巨大负担。

其次，即使引入了流量控制，网络拥塞的问题依然没有得到根本解决。

流量控制和拥塞控制目的不同。流量控制中的窗口反映了接受端的接收能力，但是并没有反映网络的容量，而发送端的发送量应该同时受二者控制。

## 拥塞控制的基本原理

原理：接收方ACK〔应答〕的速率反映了网络传输能力，发送方可以据此控制发送速率。

以下内容假设发送的“包”长度都等于MSS〔最大报文段长度〕。

我们假设网络的容量是当前数据传输的瓶颈（也就是网络传输能力低于发送端的发送能力，也低于接受端的接收能力，此时便是拥塞控制应该发挥作用的时候）。发送端每秒发送$n$个包，接收端每秒接收$m$个包，网络层每秒传输却只能传输$k$个包，$m &lt; n &lt; k$。

如果发送端每秒发出$n$个包，经过网络层之后，接收方每秒也只能接收到$k$个包。接收每收到一个包，就发回一个ACK，所以发送端每秒收到$k$个ACK。因此发送方可以知道网络当前的容量是每秒钟$k$个包。调整发送速率到每秒$k$个包，就算是进行了拥塞控制。

&gt; 滑动窗口反映了接收方的接收能力，因此发送方可以知道现在的传输瓶颈究竟是网络传输能力，还是接收方的接收能力。

## 拥塞控制的难题

和TCP计时器控制一样，协议必须面对多变的网络环境。网络传输能力时时刻刻都在发生变化，因此拥塞控制必须动态地适应这一变化，及时“收敛”到最佳的发送速度上去。这便是TCP拥塞控制要解决的问题。

## TCP的拥塞控制

&gt; 这部分内容在[RFC 2851](https://www.rfc-editor.org/rfc/rfc2581.html)有详细、清晰的说明，我只是RFC的搬运工罢了。RFC的讲解比很多教材清晰明了，建议阅读。

拥塞控制涉及到4个关键的算法：慢开始，拥塞避免，快速重传，快速恢复。

涉及一些定义：

1. `SMSS`：发送方最大报文段长度
2. `IW`：初始拥塞窗口大小，三次握手之后使用这个作为拥塞窗口的初值
3. `FlightSize`：已经发出但是未应答的包的个数

涉及几个关键的状态变量：

1. `cwnd`：拥塞窗口大小。不同实现方式中含义不同，有的按「全长包」的个数计算，有的按字节数计算
2. `rwnd`：接收方的窗口大小
3. `ssthresh`：决定「慢开始」算法和「拥塞避免」算法的选用

### 慢开始和拥塞避免

首先，设置`cwnd`初值为`IW`，`ssthresh`初值为一个任意大的值。然后进入慢开始阶段。

#### 慢开始阶段

慢开始阶段，每收到一个ACK，便让`cwnd`至多增加`SMSS`。如果按「全长包个数」计算，就是加一。

慢开始算法一点也不“慢”。考虑上述算法的表现，慢开始阶段，每个RTT〔往返时间〕`cwnd`都倍增一次。当`cwnd`大于或者等于`ssthresh`的时候，进入拥塞避免阶段。

&gt; 在`cwnd`和`ssthresh`相等的时候，标准并没有规定用哪一算法，因此取决于具体的TCP实现。

#### 拥塞避免阶段

拥塞避免阶段，每个RTT内`cwnd`增加`SMSS`。如果按「全长包个数」计算，就是`cwnd`在每个RTT增加1。当「发现拥塞」的时候，拥塞避免阶段结束。

&gt; 实际中不好统计RTT。因此可以对于每个不重复的ACK，执行一次
&gt; 
&gt; `cwnd` = `SMSS` * `SMSS` / `cwnd`

#### 「发现拥塞」

当「超时重传」的现象出现，我们就认为拥塞发生了。这就是「发现拥塞」的方式。

当发现拥塞的时候，将`ssthresh`重新设置为以下值。

`ssthresh` = max(`FlightSize` / 2, 2 * `SMSS`)

&gt; 实际上是将发送窗口折半，但是至少可以发送两个包。如果传输速率受制于网络传输能力，那么其实就是把`ssthresh`设置为`cwnd`的一半。
&gt; 
&gt; 但是为什么不能直接设置为`cwnd`的一半？标准说这样可能会使`ssthresh`超过`rwnd`。

&gt; Tanenbaum的教材中直接就说设为当前`cwnd`的一半。

重设`ssthresh`之后，`cwnd`回到初始值重新进行慢开始。

### 快速重传和快速恢复

引入这两个算法是为了加快收敛速度。

当接收方收到失序的报文段时，应立即回复一个“重复的ACK”，指明期望接收的序列号应该是多少。当失序的情况发生，意味着网络传输能力的不足。发送方通过观察重复的ACK，可以作出一些操作来控制拥塞。当然，网络错误也有可能造成重复ACK。

当发送端收到第三个重复的ACK时，按照之前发现拥塞的算法重设`ssthresh`（如果按照教材上的说法，就是折半`cwnd`）。然后立即重发可能丢失的包，不必等超时重传（这就是快速重传）。接下来，设置`cwnd`为`3*SMSS+ssthresh`（如果按照全长包来计算，就是`cwnd`设为`3+ssthresh`。

&gt; 为什么要人为使`cwnd`“膨胀”3？因为三个重复ACK意味着接收方收到了三个失序的包，或者说，有三个包实际上已经离开网络了。

重传之后，每收到一个重复的ACK，`cwnd`就增加一个`SMSS`，或者从全长包个数的角度说，就是增加1。

&gt; 同上，意味着又有一个包离开网络了。

收到下一个ACK的时候，进行一次“收缩”，将`cwnd`设为`ssthresh`（这就是快速恢复）。接下来因为`cwnd &gt;= ssthresh`，因此应该使用拥塞避免算法。

## TCP拥塞控制的表现

如果记录每个RTT传输的包数，将得到一张锯齿状的折线图。图片来自WikiCommons。

![Illustration of TCP’s Congestion Avoidance based on this image. author: Fleshgrinder](../assets/img/post/TCP_Slow-Start_and_Congestion_Avoidance.svg)

## 更多拥塞控制的方法

1. 引入SACK〔选择性ACK〕。允许声明哪些「区间」的字节已经收到。更有利于高效地重传

2. 引入ECN〔显性拥塞通知〕。网络是否拥塞，网络层自己本身最清楚，ECN允许网络层给传输层反馈，直接告知拥塞情况。

## 参考资料

1. RFC 2851

2. Tanenbaum, A.S. and Wetherall, D.J: *Computer Networks 5th edition*



        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        一道积分：利用分部积分和三角换元
        
        </title>
        <url>////nth233.top/notes/mathproblem1.html</url>
        <search-text>
        
        
            math
        
            积分
        
        
        
        利用分部积分和三角换元，也许是硬算
        
        
        
求积分

$$
\int \frac{x\ln(x+\sqrt{1+x^2})}{(1+x^2)^2}dx
$$

---

解：

$$
\begin{aligned}
&amp; \int \frac{x\ln(x+\sqrt{1+x^2})}{(1+x^2)^2}dx \\
= &amp; \int\frac{\ln(x+\sqrt{1+x^2})}{2(1+x^2)^2}d(x^2)\\
= &amp;\int\frac{\ln(x+\sqrt{1+x^2})}{2(1+x^2)^2}d(x^2+1) \\
= &amp; -\frac{1}{2}\int \ln(x+\sqrt{1+x^2})d\left(\frac{1}{1+x^2} \right) \\
= &amp; -\ln(x+\sqrt{1+x^2})\cdot \frac{1}{1+x^2}
 + \frac{1}{2}\int \frac{1}{1+x^2}\cdot \frac{1+\frac{x}{\sqrt{1+x^2}}}{1+\sqrt{1+x^2}}dx \\
= &amp; -\frac{1}{2}\frac{\ln(x+\sqrt{1+x^2})}{1+x^2}
+ \frac{1}{2}\int \frac{1}{(1+x^2)^{\frac{3}{2}}}dx
\end{aligned} 
$$

另解 $\int \frac{1}{(1+x^2)^{\frac{3}{2}}}dx$

$$
\begin{aligned}
&amp; \int \frac{1}{(1+x^2)^{\frac{3}{2}}}dx \\
=&amp; \int \frac{1}{(1+\tan^2\theta)^{\frac{3}{2}}} d\tan\theta \\
\overset{x = \tan\theta}{=} &amp; \int \frac{1}{\sec^3\theta}\sec^2 \theta d\theta
= \int \cos\theta d\theta \\
=&amp; \sin\theta
\end{aligned} 
$$

有

$$
\begin{aligned}
x^2 = \frac{\sin^2\theta}{1-\sin^2\theta}
\Leftrightarrow x^2 -x^2\sin^2\theta - \sin^2\theta = 0 \Leftrightarrow \sin^2\theta = \frac{x^2}{1+x^2}
\end{aligned}
$$

故（可能需要分类讨论？）

$$
\sin\theta = \frac{x}{\sqrt{1+x^2}}
$$

得原积分

$$
-\frac{1}{2}\frac{\ln(x+\sqrt{1+x^2})}{1+x^2} + \frac{x}{2\sqrt{1+x^2}}
$$































        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        为什么我积出来和答案不一样？——关于arcsin的积分
        
        </title>
        <url>////nth233.top/notes/mathproblem2/index.html</url>
        <search-text>
        
        
            math
        
            积分
        
        
        
        arcsin的神奇性质
        
        
        
## 起因

求积分

$$
\int \frac{dx}{\sqrt{x(1-x)}}
$$

---

## 解法

### 解法一：答案的解法

$$
\begin{aligned}
&amp;\int \frac{dx}{\sqrt{x(1-x)}} = 2\int \frac{dx}{2\sqrt{x}\cdot\sqrt{1-(\sqrt{x})^2}} \\
= &amp; \int \frac{d(\sqrt{x})}{\sqrt{1-(\sqrt{x})^2}} = \arcsin{\sqrt{x}}  + C\\
\end{aligned}
$$

嗯，对，没有任何毛病，$t=\sqrt{x}$的换元也很巧妙。

### 解法二：我起初的解法

$$
\begin{aligned}
&amp; \int \frac{dx}{\sqrt{x-x^2}} \\
= &amp; \int \frac{dx}{\sqrt{\frac{1}{4} - \left(x^2-\frac{1}{2} \right)}} \\
= &amp; \int \frac{d(2x-1)}{\sqrt{1-(2x-1)^2}} = \arcsin{(2x-1)} + C
\end{aligned}
$$

很暴力，直接配方，但是似乎也找不出毛病，积分结果和上面看起来完全不同。（因为一开始我画错了图，所以甚至以为不是同一个函数）。求导一下，发现导函数和答案得到的一样。

### 解法三：Wolfram Alpha的解法

$$
\begin{aligned}
&amp; \int \frac{dx}{\sqrt{1-x^2}} \\
= &amp; \int \frac{dx}{\sqrt{\frac{1}{4} - \left(\frac{1}{2} - x^2 \right)}} \\
= &amp; -2\int \frac{d(\sqrt{1-x})}{1 - (\sqrt{1-x})^2} \\
= &amp; -2\arcsin{\sqrt{1-x}} + C
\end{aligned}
$$

思路诡异，但是没毛病，也许这就是机器和人的差别吧。可是凭什么说这个函数和前面两个函数是一样的？虽说求导结果一样。

## 函数图像

求导结果一样就意味着函数图像应该形状相同。其实也确实是相同的，用GeoGebra画出来的图如下。

![](geogebra.png)

ps. 一开始我画错图了，导致我一直被图误导

---

## 证明

关于答案和wolframalpha的结果，使用对称性可破。

关于我的结果和答案，则需要使用半角公式。也就是证明$2\arcsin\sqrt{x} - \arcsin(2x-1) = C$

证明：

首先，设

$$
\begin{aligned}
&amp; y_1 = 2\arcsin\sqrt{x} \\
&amp; y_2 = \arcsin(2x-1)
\end{aligned}
$$

那么有

$$
x = \sin^2\frac{y_1}{2} = \frac{1 + \sin y_2}{2}
$$

另有

$$
\sin^2 \frac{y_1}{2} = \frac{1-\cos{y_1}}{2}
$$

故

$$
1-\cos{y_1} = 1 + \sin y_2 \Leftrightarrow \sin y_2 = -\cos y_1 = \sin (y_1 + \frac{\pi}{2} + 2k\pi)
$$

所以

$$
y_2 = y_1 + (4k+1)\frac{\pi}{2}
$$

证毕。对于这个情况，$k=-1$。

---

## 总结

不仅仅涉及三角函数的积分可能没有所谓”最简“的结果，涉及反三角函数的积分可能也没有”最简“的结果，但正确结果之间肯定是相互等价的，这点大可放心。

三角函数的半角公式应用到反三角函数中，可以得到一波稀奇古怪的公式。

$$
\arcsin(2x^2-1) = 2\arcsin x - \frac{\pi}{2}
$$

        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        考研真题词单
        
        </title>
        <url>////nth233.top/notes/kydc.html</url>
        <search-text>
        
        
            word
        
            考研
        
            English
        
        
        
        记录写题碰到的生词，以真题为主。尽量日更，若没有日更，请催更。
        
        
        
记录写题碰到的生词，以真题为主。尽量日更，若没有日更，请催更。

## 2013, 2014, 2004

[PDF](/notes/kydc-assets/2013.pdf)

## 2012

&gt; 2022-05-04 created
&gt; 2022-05-08 updated

1. legitimacy n. 合法性，正统性
2. code n. 法典，法规；代码，密码
3. framer n. 组成者
4. envision vt. 想象，展望
5. resort n. 度假圣地；诉诸，采取
6. evade vi. 逃脱，逃避；回避 &quot;evaded the real issues&quot;
7. amiable adj. 和蔼的，亲切的 /&#39;eimi.abl/
8. lest conj. 〈正式〉以免 &quot;hesitant to speak out lest he be fired&quot;
9. exert vt. 施加，运用，行使 &quot;the force is exerted sideways&quot; &quot;the force is exerted sideways&quot; &quot;exerted a bad influence on his students&quot;
10. plead vi. /pled/ 抗辩，辩护，陈述案情，恳求 &quot;plead not guilty&quot;
11. steer vt. &amp; vi. 掌舵，引导
12. virtuous adj. 品行端正的，德高望重的 /verchu.es/ - virtue
13. haze n. 烟雾，迷雾；vt. 使笼罩在雾中
14. stun n. 震惊；晕眩；vt. 使昏迷，打昏
15. stunning adj. 令人震惊的，极有魅力的
16. affirm vt. 断言；申明；
17. defy vt. 蔑视，违抗；使无法 &quot;defy public opinion&quot; &quot;in trouble for defying a court order&quot; &quot;the paintings defy classification&quot; &quot;defied us to name a better movie&quot;
18. deception n. 欺骗；骗术 - deceive
19. impulse n. 脉冲；冲动；动力 - impulsive - impulsion
20. fleeting adj. 飞逝的，短暂的 &quot;... the often fleeting nature of fame and fortune ...&quot; - fleet adj. 快速的，敏捷的 n. fleet 船队，车队 - fleet of foot 走得快的
21. visionary adj. 有远见的，（复数）visionaries 幻想家，有远见者 - vision
22. explicate vt. 详细分析，解释 - explicatory/explicable adj. - explication, eplicator n.
23. bewilder vt. 使迷惑，使糊涂 &quot;bewildered by the city&#39;s maze of roads&quot; &quot;His decision bewildered her&quot; - bewilderment
24. courtship n. 求爱期
25. innate adj. 先天的，固有的，天然的
26. dictate vt. 命令；支配，影响；n. 命令 &quot;Choices is often dictated by availability&quot; - dictator 独裁者
27. lineage n. 血统 /liniidj/

### 词组

1. code of conduct 行动准则
2. resort to 诉诸于，采取 &quot;have resort to outside help&quot; 


## 2015

&gt; 2022-04-21 created
&gt; 2022-05-04 corrected

1. kinship n. 亲属关系
2. disruptive adj. 捣乱的，扰乱性的；革新的 &quot;a disruptive weather pattern&quot; - disrupt, disruption
3. surpass vt. 超过
4. abdicate vt. 退位，逊位；失职
5. monachy n. 君主制 /mArn.aki/
6. transcendent adj. 超凡的，玄奥的
7. infest vt. 滋生，昆虫群集 /in&#39;fest/ &quot;a slum infested with crime&quot;
8. strive vi. 努力=endeavor，力争=contend &quot;strive to finish a project&quot;
9. intrusive adj. 不受欢迎的，打扰的；【地质】侵入岩
10. aristocratic adj. 贵族的
11. reckless adj. 不顾后果的；草率的，冒失的，鲁莽的
12. discern vt. 辨认出，觉察 &quot;discerned a figure approaching through the fog&quot; &quot;discern right from wrong&quot; &quot;unable to discern his motives&quot;
13. lame adj. 跛的，瘸的
14. refrain vi. &amp; vt. 克制，抑制
15. sweeping adj. 影响广泛的
16. manuscript n. 手稿
17. editorial n. 社论
18. impel vt. 驱使，促使
19. reproduction n. 复制，重现，繁殖
20. literate adj. 识字的；精通的
21. diminish vt. 使变少/变小/变弱
22. dearth n. 缺乏，不足 &quot;a dearth of evidence&quot;
23. revelation n. 揭露，透露；出人意料的发现
24. doctrine n. 信条，学说，主义，学说 - doctrinaire
25. distort
26. assimilate vt. 吸收，使同化 &quot;Students need to assimilate new concepts.&quot; &quot;… the belief that tolerant hosts would be able to assimilate immigrants of whatever creed or colour.&quot;
27. discourse n. 论文，论述，谈话，争论
28. discord n. 不和，纷争，【音】不和谐
29. mouthpiece n. 吹嘴

### 词组

1. strive against ...
2. refrain from ... 

## 2011

&gt; 2022-04-13 created
&gt; 2022-04-21 updated

1. conceivably adv. 可以想到的
1. conceive vt. &amp; vi. 构想，想象，怀孕 conceive of ..., &quot;I cannot ~ that he acted alone.&quot; - conception
2. renewable adj. 可更新的，可再生的
3. conversely adv. 相反地，反之［用于引出相反的陈述］- converse v. 对话 n. 逆否命题 adj. 顺序相反的，逆否的
4. precede vt. &amp; vi. 先于……
5. sobersided adj. 稳重的 - sober
6. formidable adj. 可怕的，令人敬畏的，难以对付的 a ~ opponent
7. unpretentious adj. 不矫饰的
8. troupe n. 班子（演员、歌手）
9. vibrant adj. 震动的，有声有色的，生气勃勃的，鲜艳的
10. revitalize
11. repertoire n. （总称某人的）可表演项目
12. hitherto adv. :up to this or that time &quot;reveals some ~ unknown facts about her life&quot;
13. cloak vt. 掩盖
14. scrutinize vt. &amp; vi. 仔细审查 &quot;I closely ~d my opponent&#39;s every move.&quot; - scrutiny
15. prevalent adj. 流行的，盛行的 =widespread, dominant 
16. abound v. 富于 abound in/with ... - abundance
17. turbulent adj. 动荡的 - turbulence 紊流
18. deputy n. 副手，代理，（某些国家的）议员
19. spur vt. 刺激 n. 马刺
20. disgrace vt. 使……蒙羞 n. 耻辱 &quot;He felt he had ~d himself by failing at school.&quot; &quot;His table manners are a ~.&quot;
21. board n. 董事会
22. infancy n. 婴儿期
23. hostage n. 人质
24. stakeholder n. 参与者，利益相关人
25. leverage n. 杠杆 vt. 发挥杠杆作用，利用
26. provocative adj. 煽动性的
27. provoke vt. 煽动，挑衅
28. rear v. 抚养 =raise n. 后方
29. gratification n. 满足，满意，奖励
30. procreation n. 生殖
31. glamorous adj. 迷人的
32. discipline n. 纪律，训练
33. canon n. 规则，标准，准则；（名家）真迹；经典作品；卡农 - canonical adj. 权威的，标准的
34. post n. 邮政；岗位，哨所；柱、杆 v. 发布；邮寄；安置（士兵），委派
35. holistic adj. 【医】功能整体性的
36. inquire v. 询问；调查 &quot;inquired about the horses&quot; BrE=enquire - inquiry
37. embark vi. 登船，登机；开始，着手

### 词组

1. make the jump 跳槽
2. provoke sb. to do sth.
3. inquire into ... = search into ... = investigate ...
4. embark on ... 着手

## 2016

&gt; 2022-04-12 created

1. adorn v. 美化，装饰  adorn ... with ...
2. bribery n. 行贿
3. charter n. 章程
4. diffuse v. 弥散，扩散，漫射；adj. 不清楚的
5. disregard vt. 不理会，不顾
6. ditch n. 沟，渠；v. [informal]抛弃
7. endorse vt. （公开）赞同，支持；宣传；［在支票背面］背书
8. incentive n. 刺激，鼓励 &quot;There is no ~ *for* people to save fuel.&quot;
9. incite vt. 鼓动，煽动，教唆  ~ sb to do sth
10. intangible adj. 难以形容的，不易度量的，无形的［资产］&quot;Leadership is an ~ asset to a company.&quot; - tangible
11. lenient adj. 温和的，不严厉的
12. mortal adj. 终有一死的；n. 凡人
13. nostalgia n. 怀旧，恋旧，恋家 /no&#39;stAdj.a/ &quot;A wave of ~ swept over me when I saw my childhood home.&quot;
14. obsess vt &amp; vi. 使着迷 /.eb&#39;ses/ &quot;He was ~ed *with* the idea.&quot; &quot;He&#39;s always ~ing over money.&quot;
15. physique n. 体型 /fi&#39;zeek/
16. premise n. 前提，假定 premised on ... 基于...，根据...
17. priest n. 教士，祭司 /preest/ - pritetess 女祭司
18. prosecute vt. 起诉，控告，检举 
19. rip n. 撕扯；欺骗；偷窃； &quot;Fire ~ped through the house.&quot;
20. ritual n. 仪式，习惯，例行公事；adj. 例行的 /richyUl/ &quot;Her visit became a ~.&quot;
21. rustle v. 沙沙作响
22. sermon n. 布道
23. veto n. 否决权；vt. 否决  have the right of veto
24. whence adv. 从哪里，从何处 =from where
25. whereas conj. 尽管，然而；鉴于 /,we.e&#39;Az/ =although, while on the contrary
26. whereby conj. 凭此，由于 &quot;They introduce a new system ~ all employees must undergo regular training.&quot;

### 词组

1. bank on 指望 =rely on
2. clear up 放晴
3. rip sb. off
4. let rip at sb. 对某人忘乎所以地说/做
5. let rip 无拘无束地行动 [所有关于let的词组](https://www.merriam-webster.com/dictionary/let)

        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        Blog迁移之路的终点
        
        </title>
        <url>////nth233.top/posts/2022-04-08-迁移之路的终点.html</url>
        <search-text>
        
        
            blog
        
            sushi
        
            ssg
        
        
        
        从一开始写博客开始，我就不断地更换博客生成器，先是Jekyll，然后是Hexo，之后用了一年的Hugo，因为数学公式渲染的问题又回到Jekyll。终于我忍不住了，自己写（不如说是组装）了一个博客生成器——sushi。
        
        
        
从一开始写博客开始，我就不断地更换博客生成器，先是Jekyll，然后是Hexo，之后用了一年的Hugo，因为数学公式渲染的问题又回到Jekyll。终于我忍不住了，自己写（不如说是组装）了一个博客生成器——sushi。

之前多次更换生成器，有时是因为盲从（比如从Hexo换成Hugo），有时是因为喜欢的主题只能用于另一个生成器（比如从Jekyll换成Hexo），不过更多时候是因为不顺手。对于其他生成器来说来说，我一直没法解决使用相对路径插图的问题，也没法解决生成期间渲染KaTeX公式的问题。Jekyll因为一些奇奇怪怪的原因在本地没法使用，并且我不熟悉Ruby，也不想花太多精力学习，一直没有能力排查。终于到了上个月，我终于受不了缓慢的数学公式加载、极不顺手的插图方式，决定自己写一个生成器。肝了几周之后终于组装出了[sushi](https://crates.io/crates/sushi-gen)。

虽然sushi还存在一些问题，但我想我不会再迁移了，因为sushi的定制难度要低于我用过的其他生成器。下面几点是sushi已经实现的设计目标：

1. 渲染器（converter）由用户指定，而且由用户提供。用户把渲染器的可执行文件放到一个文件夹中，然后在配置文件中指定那些文件使用那个渲染器。这使得使用pandoc非常容易，我可以用tex写博客，也可以用markdown，或者别的pandoc支持的语言。借助pandoc filter，我还能实现KaTeX公式的静态渲染，大大提高了页面的加载速度。~~对我而言，Hugo最大的问题就是和Goldmark绑定，对其他渲染器的支持不佳，导致我不能自定义markdown语法。~~
2. 不改变站点的结构。比方说一个文件在`posts/aaa/test`文件夹里面，那么无论它是什么文件，在生成的站点中，sushi会确保它依然在这个位置。这点使得我可以随心所欲地使用相对路径，不会有奇奇怪怪的插图问题。
3. 使用liquid模板语言，但是无视博文中出现的liquid标签。
4. 支持自定义的分类法（taxonomy）
5. 不区分所谓“post”和普通的页面文件。站点结构除了少数几个配置相关的文件夹和文件之外，完全由用户自定义

这几点总结起来，就是sushi不管生成方式、部署方式、主题，只管按要求“套模板”。使得sushi的可定制性优于其他生成器。当然这也式sushi也存在一些问题：

1. 几乎没有默认配置，所有东西都需要自定义，没有默认主题。即使你使用starter，也无法避免自己配置一些东西
2. 因为使用了用户提供的渲染器，因此如果你和我一样给pandoc加了各种各样的filter，那么站点的生成速度会比较慢
3. 没有“一键部署”，部署博客需要自己写脚本。（比如说可以自己写Makefile）
4. 虽然跨平台，但是因为需要用户提供可执行文件作为converter，因此跨平台体验很一般。
5. 也许存在一些没有被发现的bug。
6. 分页器虽然能用，但是不太好用
7. 虽然标榜可定制性，但是几个默认的配置文件夹和配置文件不允许改名

但是上述问题我一点都不在意。我更关心“能否轻松自定义”，不太关心能否开箱即用。因为个人博客的页面数量不多，我觉得hugo的那种速度没有必要的。跨平台问题并不难解决。分页器难用，但其实并不需要经常用。因为测试不是太彻底，因此可能有一些bug，但是我会持续进行维护，如果有bug也欢迎到[github仓库](https://github.com/fpg2012/sushi)提交issue或者PR。

综上，sushi对我而言就是完美的博客生成器了（毕竟是自己写的）。如果你和我有相似的需求，我强烈推荐使用sushi（虽然目前sushi只有我写的两个主题（[letter](https://github.com/fpg2012/sushi-theme-letter)和[empty](https://github.com/fpg2012/sushi-theme-empty)，如果不喜欢，你可能得自己写主题）。

Blog的迁移之路，终于到了一个终点……

&gt; ps. 关于我的生成器的起名，我觉得「苏轼」很符合博客的气质，而且「sushi」容易发音，如果加上音调，变成sūshì，也不会和「寿司」相混，于是就这样定下来了。不过很可惜gnome有个命令行工具也叫`sushi`，因此我不得已把命令改成了`ssushi`。crates.io上已经有`sushi`这个crate了，我改名成ssushi又不利于搜索，所以最终，在crates.io上，我这个项目名为`sushi-gen`。

        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        About
        
        </title>
        <url>////nth233.top/README.html</url>
        <search-text>
        
        
            about
        
            friends
        
        
        
        
        
我是nth233（又fpg2012），在这里写些无用的东西。

四处辗转，几番折腾，用了hugo、jekyll，最后竟然自己写了一个[生成器](https://github.com/fpg2012/sushi)。

若要联系我，请发送邮件至我的邮箱[fpg2012@yeah.net](mailto:fpg2012@yeah.net)。

是为about，以上。

---

开坑计划可以在此查看：[开坑计划](//nth233.top/plan)

欢迎在本页面催更。

---

## Friends

- [Chipen&#39;s Blog](https://zsiothsu.github.io)

        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        About
        
        </title>
        <url>////nth233.top/about/index.html</url>
        <search-text>
        
        
            about
        
            friends
        
        
        
        
        
我是nth233（又fpg2012），在这里写些无用的东西。

四处辗转，几番折腾，用了hugo、jekyll，最后竟然自己写了一个[生成器](https://github.com/fpg2012/sushi)。

若要联系我，请发送邮件至我的邮箱[fpg2012@yeah.net](mailto:fpg2012@yeah.net)。

是为about，以上。

---

开坑计划可以在此查看：[开坑计划](//nth233.top/plan)

欢迎在本页面催更。

---

## Friends

- [Chipen&#39;s Blog](https://zsiothsu.github.io)

        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        来一局线上卡卡颂！——抽牌器+共享画板
        
        </title>
        <url>////nth233.top/posts/2022-04-04-carcasonne.html</url>
        <search-text>
        
        
            Carcasonne
        
            桌游
        
            联机
        
            drawpile
        
            共享画板
        
            卡卡颂
        
        
        
        上个月某日，某人在某群里提到想要在线上玩卡卡颂〔Carcasonne〕。然而卡卡颂官方电子版在steam上价格不低，我又不想上某宝买steam上的桌游模拟器，于是想着不如用点低级的方法「组装」出一个卡卡颂来。游玩卡卡颂时，大概只有四种动作是必要的：抽取土地块，摆放土地块，收放随从，计分。只要有了牌，后三种都可以借由在线画板／白板实现，比方说drawpile。因此关键的问题就在于如何抽牌。
        
        
        
## TL;DR

### 配置Drawpile

到[drawpile官网](https://drawpile.net/)下载并安装最新的drawpile。~~然后联系我开服~~。

开服之后选择菜单中的`Session`，选择`Join`，在最下方输入服务端地址，然后连接。

### 抽牌器的使用

访问[抽牌器页面](https://carcasonne.herokuapp.com)。（不要过度使用，免费版的heroku有时长限制）

1. 输入名字和游戏创建者给的`game code`加入游戏。如果`game code`放空，将建立新游戏

2. 点击加入或创建之后，最下方的在线列表将显示所有在线的玩家（~~如果显示「offline」，请联系我修bug~~~）

3. 如果你是创建者，`draw code`框中应该有一份`draw code`，你可以在初始土地块摆放好之后立即抽牌。如果你不是创建者，等轮到你的时候向上家讨要`draw code`。抽完牌之后记得把`draw code`告诉下家。

具体的界面如下：

![界面](/assets/img/post/carcasonne_.png)

1. 玩家名，允许重名（~~但是你不觉得重名会很麻烦吗~~）
2. `game code`，一般是6位十六进制数，也就是只包含`0~9`、`A~F`这几个字符。如果在`game code`前面添加一个`:`字符，那么将进入调试模式，WebSocket连接将不使用SSL（便于本地调试）。
3. 如果`game code`为空，那么按钮内容是`New`，否则是`Join`。前者代表将新建游戏。
4. 土地块代码。遵循「上-右-下-左-备注」的顺序进行编码，`F`表示草地，`R`表示道路，`C`表示城市，`K`表示修道院。备注表明土地块四边中的哪几个边内容是相联通的。如果备注是`K`，那么表示中间是修道院。如果备注以`a`，结尾，说明城市带有盾牌。
5. 上一个抽牌的人和剩余牌数。「base」代表「没人抽牌，现在这张牌是初始块」
6. 土地块图片。图片加载可能比较缓慢，因此需要时刻检查图片和代码是否匹配。
7. `draw code`，一般是4位十六进制数
8. 为什么没有8？
9. 抽牌按钮
10. 在线玩家列表

&gt; Tip：如果忘了上一张牌是什么，可以按F12，然后打开浏览器的Console查看。

所有人离开之后，游戏将被清除掉。

### 进行游戏

drawpile和抽牌器都准备就绪之后，就可以打起语音电话开始游戏了。具体方法就是把抽牌器抽出的牌复制到drawpile里面摆放，简单粗暴，~~但是有效~~。

## 前因后果

上个月某日，某人在某群里提到想要在线上玩卡卡颂〔Carcasonne〕。然而卡卡颂官方电子版在steam上价格不低，我又不想上某宝买steam上的桌游模拟器，于是想着不如用点低级的方法「组装」出一个卡卡颂来。

游玩卡卡颂时，大概只有四种动作是必要的：抽取土地块，摆放土地块，收放随从，计分。只要有了牌，后三种都可以借由在线画板／白板实现，比方说drawpile。因此关键的问题就在于如何抽牌。

### 如何抽牌？

抽牌不仅得有序，抽牌结果还得同步到所有客户端，并且抽牌得是随机的。drawpile的确勉勉强强可以实现，但是体验会很差（提前把所有牌有序摆放到一个图层，然后再建一个图层盖住，所有玩家各自生成随机数进行抽取），手撸一个抽牌器几乎是不可避免的。

抽牌器不仅仅只是一个多端共享的随机数生成器，我还要求它有以下功能：

1. 支持多局游戏同时在服务端上进行

2. 尽可能确保抽牌有序，减小误操作的影响

3. 掉线可以重连，可以看到有那些人在线

4. 界面不丑

5. 引用的外部依赖越少越好，页面加载越快越好

6. 代码简短

最后我用tornado写了一个几百行的服务端，并且除了tornado之外，没有任何其他依赖。因为要支持多个游戏同时进行，就需要有一个游戏的唯一标识，所以引入了`game code`。为了保证抽牌有序，我决定阻止一个人连续抽两张牌，以防止网络延迟高的时候玩家狂点抽牌按钮，带来意想不到的结果。另外还引入`draw code`，每次抽牌都需要凭证，刚刚抽完牌的人不能再抽牌，但是手上会获得一个`draw code`，他需要把这个`draw code`发给下一个行动的玩家，这样就最大限度地确保抽牌有序。

为了精简页面，只用了原生的HTML+CSS+JS来写前端，目前拖慢页面加载速度的是两个webfont（为了美观，我最终还是用了webfont）。

抽牌程序[已经挂上github了](https://github.com/fpg2012/kks-draw)。

把服务端挂到heroku上，抽牌器就算是完成了（当然，还是有些bug要修）。

### Drawpile

确保已经安装了`drawpile-srv`。执行`drawpile-srv`，如果使用默认配置，它就会开始监听本地的27750端口，把这个端口用frp转发出去，外界就可以正常访问了。

也可以选择在服务器上直接部署drawpile服务器，可以参考[drawpile的文档](https://drawpile.net/help/server-howto/)。但是因为我服务器上的系统是远古版本的CentOS（服务商的锅），搞起来有点麻烦，所以我最后还是选择比较简单的内网穿透。

### 开发插曲

一开始我打算把抽牌器部署到腾讯云服务器上，但是因为我没有备案，所以腾讯会限制IP访问（最后变成只有我能连接）。我原以为只有HTTP协议会受到限制，但是实测WebSocket也会（可能是因为WebSocket连接也是从HTTP请求开始的）。把服务端改挂到heroku上就完美解决了，为了这个小东西备案实在是不值得。

转到heroku上之后，发现还是无法抽牌，这导致我们[第一次游戏](https://www.bilibili.com/video/BV1g3411H7Ys)只能由我抽牌，然后由我把牌复制到drawpile里面，其他玩家再进行移动。排查原因，发现是连接被heroku切断了，55秒没有数据交互，heroku就认为连接被限制，然后掐断连接，但偏偏实践中两次抽牌间隔往往要超过55秒。查了一下tornado的文档，设置`websocket_ping_interval=40`之后就解决了这个问题。

&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=425317475&amp;bvid=BV1g3411H7Ys&amp;cid=566006509&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; style=&quot;width: 100%;aspect-ratio: 9/6;&quot;&gt; &lt;/iframe&gt;


        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        「地牢探险指南」——原版《Rogue》游戏规则翻译
        
        </title>
        <url>////nth233.top/posts/2022-03-04-rogue.html</url>
        <search-text>
        
        
            rogue
        
            roguelike
        
            游戏规则
        
            翻译
        
        
        
        我很喜欢roguelike游戏，因此决定玩玩Rogue，也就是所有roguelike的鼻祖，纯度最高的roguelike。然而真正启动Rogue之后我发现没有文档完全不知如何上手。因此决定翻译。
        
        
        
&gt; 直接看翻译部分，请[点此跳转](#地牢探险指南)

## 前言

![](/assets/img/post/rogue.png)

&gt; Rogue  is  a computer fantasy game with a new twist.  It is crt oriented and the object of the game is to survive the attacks of various monsters and get a lot of gold, rather  than the puzzle solving orientation of most computer fantasy games.
&gt; 
&gt; —— man page of *Rogue*

### 为什么有这篇翻译？

我很喜欢roguelike游戏，因此决定玩玩Rogue，也就是所有roguelike的鼻祖，纯度最高的roguelike。然而真正启动Rogue之后我发现没有文档完全不知如何上手。因此决定翻译。

### Rogue的出现

上世纪70年代末，C语言刚刚出现，电子游戏尚是新鲜事物。那时的游戏只能运行在笨重的大型机上，微型机的出现要等到1981年。

在这样的背景下，1977年前后，William Crowther和Don Woods在PDP-10大型机上开发了《洞穴冒险》〔*Colossal Cave Adventure*〕，一个纯文字冒险游戏。这一游戏启发了当时正在UCSC学习的Toy，而此人不久后结交了在UCSC学习游戏设计、准备成为桌游设计师的Wichman。Wichman十分喜欢《地牢&amp;恶龙》〔*Dungeons &amp; Dragon*〕这款桌游。两人苦于当时的冒险游戏可重玩性太弱，决定自己开发一款游戏，而前面提到的两款游戏为Rogue提供了灵感。

1980年，UC Berkeley开发的BSD Unix在UC校园中普及开来，其中附带了Arnold开发的著名的curses库，使得在命令行显示图形化的界面成为可能（其实就是通过各种字符来拼凑出“图形界面”）。

各方面条件都已成熟，于是1980年，Rogue出现了，并且风靡一时。Rogue留下的游戏体裁更是经久不衰，形成了现在所谓的**roguelike**游戏，比如《以撒的重生》。

### 现在如何玩到「初版」Rogue

显然不可能回到大型机玩Rogue，现在能玩到的Rogue严格上说都不是「初版」。

如果是在Arch Linux上，软件仓库中就有Rogue，一条命令即可安装。

```
pacman -S rogue
```

一条命令即可执行。

```
rogue
```

如果在Windows下就有点麻烦了，也许需要先装个Dosbox，然后运行DOS移植版的Rogue。或者也可以运行其他的复刻版。

各种版本的Rogue可以在[The Roguelike Archive](https://britzl.github.io/roguearchive/)找到。

### 关于翻译的说明

本人不是专业译者，难免有翻译不妥的地方，如有疏漏，恳请指正。

翻译的原文来自[FreeBSD的文档](https://docs.freebsd.org/44doc/usd/30.rogue/paper.pdf)。大家点开就会发现，原文颇有论文的感觉，从摘要到致谢一应俱全。

&gt; 翻译中如出现引用框，则代表注脚。「——译者注」表示译者的吐槽。

翻译的内容遵循[知识共享署名-相同方式共享许可协议](https://creativecommons.org/licenses/by-sa/3.0/deed.zh)（CC BY-SA 3.0）授权。

-----

# 地牢探险指南

Michael C. Toy

Kenneth C. R. C. Arnold。

Computer Systems Research Group  

Department of Electrical Engineering and Computer Science  

University of California  

Berkeley, California 94720

**摘要**：***Rogue***是一个基于CRT显示器的可视奇幻游戏，运行于UNIX分时系统上。本文阐述rogue的玩法，为可能迷失在毁灭地牢中的冒险者提供些许提示。

## 简介

你是一个学徒，刚刚从本地的勇者名下毕业。经过艰苦卓绝的训练，你完成了所有练习，终于能够开始一场艰险的冒险之旅。作为对你的试炼，冒险者公会派你去「毁灭之地牢」。此行的任务，是从地牢中取出「焉得护符」〔Amulte of Yendor〕并归来。完成任务的奖励是公会的正式会员身份，另外还有你拿回的所有战利品。

作为冒险的准备，公会给予你一支附魔法杖，一把弓和一袋箭。这些武器皆来自遥远的黑暗山脉，曾是那里恶龙的私藏。另外，你还穿着精灵打造的盔甲，并且带上了足以支撑你到达地牢入口的干粮。准备万全，只差一场告别。你向你的亲友告别（也许是永别），然后也不回地踏上冒险之路。

启程之后，你度过了平平无奇的数日，最后来到古代废墟，也就是「毁灭之地牢」的入口的所在地。此时已及深夜，你于是在洞口露营。拂晓，你清点武器，穿上盔甲，吃掉所剩无几的食物，只身进入空无一人的黑暗地牢。

&gt; 「焉得护符」〔Amulte of Yendor〕，命名中的「焉得」〔Yendor〕来自「Rodney」一词的反拼。根据[reddit的说法](https://www.reddit.com/r/roguelikes/comments/3t5dw9/who_is_rodney/)，「得焉」〔Rodney〕似乎是Rogue的原名。——译者注

## 发生了什么？

你刚刚启动了rogue。你的目标是尽可能多拿财宝，找到「焉得护符」，然后活着出来。屏幕上显示了你的位置和你到过的房间，还有你当前所在的层数。

Rogue和多数奇幻类电子游戏不同，命令的输入只需一两次击键，且执行结果图形化地显示在屏幕上，而非只是用文字说明。另外一个比较显著的区别点在于，一般的游戏通关之后就不再有趣，但Rogue可以反复通关，每次都不同。即便作者们也依然觉得乐趣无穷。

## 屏幕上显示的是什么？

想要畅玩Rogue，首先需了解显示方式。Rogue的屏显内容替代了传统的「你可以看到……」的文字说明。下面是一个游戏截图样例。

```
                          ------------
                          |..........+
                          |..@....]..|
                          |....B.....|
                          |..........|
                          -----+------
Level: 1 Gold: 0 Hp: 12(12) Str: 16(16) Arm: 4 Exp: 1/0
```

&gt; 游玩游戏需要至少24行×80列的显示屏。如果显示屏更大，那么只会使用24行×80列来显示地图。

### 底栏

底栏显示了一些关于现状的信息。

| 信息    | 意义                            |
| ----- | ----------------------------- |
| Level | 此数字代表你向下走了几层，从1开始计数，随深入地牢而提高  |
| Gold  | 当前金币数                         |
| Hp    | 当前生命值和最大生命值。休息可以回复之。          |
| Str   | 当前力量和历史最大力量。数字越大越大越强，最大99。    |
| Arm   | 当前护甲值。越大则护甲越有效。               |
| Exp   | 当前经验等级和经验点数。经验越高法术攻击力和法术抗性越高。 |

### 顶栏

顶栏用于显示图形无法说明的信息。看见`--More--`时，按`&lt;空格&gt;`可以继续阅读。

### 屏幕主体

主体部分显示已经探索的本层地图。每个符号都有其含义。

| 符号       | 意义         |
| -------- | ---------- |
| `@`      | 玩家         |
| `-`，`\|` | 墙          |
| `+`      | 门          |
| `.`      | 地板         |
| `#`      | 通道         |
| `*`      | 金          |
| `)`      | 武器         |
| `]`      | 护甲         |
| `!`      | 魔药         |
| `?`      | 纸，通常是魔法卷轴  |
| `=`      | 戒指         |
| `/`      | 法杖         |
| `^`      | 陷阱         |
| `%`      | 阶梯，通往下一层   |
| `:`      | 食物         |
| `A-Z`    | 大写字母代表敌对生物 |

## 命令

命令通常为一两个字符，多数命令都可以通过在前面输入数字的方式执行多次（比如输入`10s`代表执行10次`s`命令，也就是10次搜查）。少数命令次数没有意义，输入的次数将被忽略。按`&lt;Esc&gt;`可以取消数字在内的所有“前缀命令”。按`?`可以查看命令列表。

| 命令           | 说明                                                       |
| ------------ | -------------------------------------------------------- |
| `?`          | 帮助。用于询问命令的用法。输入`*`列出所有命令。                                |
| `/`          | 「屏幕上显示的是什么？」指令。用于询问某个显示符的意义。                             |
| `h`、`H`、`^H` | 左移。大写表示左移直到遇见某物。`^H`（即`&lt;Ctrl&gt;`+`&lt;H&gt;`）表示左移直到墙。其他移动命令以此类推。 |
| `j`          | 下移                                                       |
| `k`          | 上移                                                       |
| `l`          | 右移                                                       |
| `y`          | 左上移                                                      |
| `u`          | 右上移                                                      |
| `b`          | 左下移                                                      |
| `n`          | 右下移                                                      |
| `t`          | 抛出指令。前缀指令，后接移动指令代表抛出方向。                                  |
| `f`          | 战斗直到一方死亡。前缀指令，后接移动指令代表攻击方向。                              |
| `m`          | 不拾取。前缀指令，后接移动指令。                                         |
| `z`          | 施法。前缀指令，后接移动指令代表施法方向。                                    |
| `^`          | 辨别陷阱。前缀指令，后接移动指令代表方向。                                    |
| `s`          | 搜查陷阱和隐藏门。检查和你邻接的每一格。                                     |
| `&gt;`          | 进入下一层。仅站在台阶上时有效。                                         |
| `&lt;`          | 回到上一层。仅取得「焉得护符」且站在台阶上时有效。                                |
| `.`          | 什么也不做，休息。                                                |
| `,`          | 拾取。                                                      |
| `i`          | 物品清单。列出背包中的所有物品。                                         |
| `I`          | 可选物品清单。解释背包中某个物品的作用。                                     |
| `q`          | 饮用〔quaff〕魔药                                              |
| `r`          | 阅读卷轴                                                     |
| `e`          | 进食                                                       |
| `w`          | 装备武器。从背包中选取武器替换当前武器。                                     |
| `W`          | 穿上盔甲                                                     |
| `T`          | 卸下盔甲                                                     |
| `P`          | 戴上戒指                                                     |
| `R`          | 摘下戒指                                                     |
| `d`          | 丢弃物品。从背包中选取物品放到地上。                                       |
| `c`          | 命名。魔药和卷轴默认以性状或标题命名，使用之后会才能知道其作用。但是在使用前可以为其命名，便于你区分。      |
| `o`          | 检查游戏设置。将在后文详细说明。                                         |
| `&lt;Esc&gt;`      | 取消                                                       |
| `Q`          | 退出                                                       |
| `S`          | 存档                                                       |
| `v`          | 显示版本号                                                    |
| `)`          | 显示当前武器                                                   |
| `]`          | 显示当前护甲                                                   |
| `=`          | 显示当前戒指                                                   |

## 房间

房间在你进入后将被点亮。离开房间后，里面所有的怪物将不再显示。在黑暗的走廊中只能看见周身一格。

## 战斗

尝试走进怪物即为攻击。怪物有时不会主动进攻，但请保持谨慎。

## 物品

走进物品即为获取，若背包已满，程序会告诉你无法拾取。

许多前缀命令会提示你选取物品，如果你改变主意，可以按`&lt;Esc&gt;`取消命令。

一些物品，如武器、护甲，易于区分；而另一些物品，如魔药，卷轴等，难以从外观区分，需要为他们贴上标签。每次游戏时，相同的标签总是代表同类物品。当然，默认标签是随机生成的，且每次游戏都不同。

在你使用了带标签的物品后，标签会根据其作用发生更改。你也可以手动重命名，便于之后记住。

### 武器

一部分武器一次可以获取一批，比如箭，而且无需装备；另一部分武器一次只能获取一个，比如弓。后者在使用前需先装备。要射箭，则需要先装备弓。若当前武器是被诅咒过的，那么不能替换。相关命令有`w`和`t`。

### 护甲

地牢中的护甲有若干种类，有一些是附魔过的，还有一些是诅咒过的，当然还有普通的。不同的护甲有不同的护甲值。护甲值越高，护甲抵御攻击的效果越好。下面是普通护甲的护甲值列表。

| 类型                                  | 护甲值 |
| ----------------------------------- | --- |
| 无                                   | 0   |
| 皮革甲〔Leather armor〕                  | 2   |
| 带钉皮甲〔Studded leather〕／锁甲〔Ring mail〕 | 3   |
| 鳞甲〔Scale mail〕                      | 4   |
| 链甲〔Chain mail〕                      | 5   |
| 带甲〔Banded mail〕／板甲〔Splint mail〕     | 6   |
| 铠甲〔Plate mail〕                      | 7   |

附魔后的护甲值将高于普通护甲，诅咒后的则反之。收到诅咒的护甲不能脱下。但是并非所有抵御正常护甲值的护甲都是被诅咒过的。

相关命令有`W`和`T`。

### 卷轴

标题用未知语言写就。阅读之后卷轴将消失。使用`r`阅读。

&gt; 实际上标题使用的是外蒙一个仅有27人的部落的方言。（当然你不该知道这些）

### 魔药

初始标签标明瓶中液体的性状（比如颜色）。饮用后消失。使用`q`饮用。

&gt; 原文此处有笔误，误将potion写作scroll。——译者注

### 法器

法器按照其材料进行区分。施法（远程法术攻击）的工具。一般使用前需要指定方向。法器使用前带有一定的法力，法力耗尽之后就会变成普通的木头或者铁棒。使用`z`施法。

### 戒指

戒指相当有用，法力能常驻其中。有害的指环通常有更强的法力。多数指环会导致你需要更频繁地进食，这取决于指环的类型。相关命令`P`和`R`。

### 食物

前行的必需品。太久不进食会导致虚弱和晕眩，甚至可能会饿死。

## 游戏设置

调整游戏选项有两种方法：

1. 使用`o`命令

2. 设置`ROGUEOPTS`环境变量，由逗号分隔的选项组成，比如

```
% setenv ROGUEOPTS &quot;jump,nopassgo,name=Blue Meanie&quot;
```

&gt; sh用户应这样设置环境变量：
&gt; 
&gt; ```
&gt; $ ROGUEOPTS=&quot;jump,nopassgo,name=Blue Meanie&quot;
&gt; $ export ROGUEOPTS
&gt; ```

&gt; Version 6系统上没有和`ROGUEOPTS`等价的功能。

选项列表如下。

| 选项                 | 说明                       |
| ------------------ | ------------------------ |
| jump[nojump]       | 直到移动结束后才刷新界面，节省CPU资源     |
| passgo[nopassgo]   | 自动走到通道另一头，如果通道中有岔路，则会停下。 |
| skull[skull]       | 在游戏结束时显示墓碑               |
| name[account name] | 主角的名字                    |
| fruit[slime-mold]  | 水果命名列表                   |
| file[~/rogue.save] | 默认存档位置                   |

## 计分

Rogue会记录一个得分榜。当你退出时，会带出所有的金币进入下一次游戏。死亡时，则只能带出90%的金币，余下的10%交给地牢巫师作为费用。所以，如果生命值不足，战斗前请三思。

如果你想看本机的排行榜，却不想进入游戏，可以使用`-s`命令行选项。

```
% rogue -s
```

&gt; 地牢巫师名为瓦里·“奇迹”·拜格〔Wally the Wonder Badger〕，要向他捐赠不少钱他才会现身。

## 致谢

Rogue最初由Glenn Wichman和Michael Toy构想。Ken Arnold和Michael Toy优化了界面，添加了大量功能。同时感谢Bob Arnold, Michelle Busch, Andy Hatcher, Kipp Hickman, Mark Horton, Daniel Jensen, Bill Joy, Joe Kalash, Steve Maurer, Marty McNary, Jan Miller, and Scott Nelson的点子和帮助，还要感谢大量忽略了工作、学习、生活在玩rogue的人向我们报告bug、抱怨、建议。当然还要感谢母亲。

公有领域版本的rogue由Timothy Stoehr编写，和Berkeley UNIX一同发行。

        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        没有图形界面也要录屏：/dev/fb0和ffmpeg
        
        </title>
        <url>////nth233.top/posts/2022-02-27-使用ffmpeg录制TTY命令行.html</url>
        <search-text>
        
        
            FFmpeg
        
            Framebuffer
        
            命令行
        
            linux
        
        
        
        「录屏」一词，说起来仿佛是图形界面的专属。现有的趁手录屏工具很多也的确需要桌面环境才能工作。比方说常用的obs。如果在tty中执行obs的录屏命令，很遗憾，无效。obs会提示cannot connect to display。大概是因为运行obs需要显示一个Qt窗口。好在tty下录屏并非毫无办法，ffmpeg提供了一条路，直接读取Linux的framebuffer：`/dev/fb*`。
        
        
        
「录屏」一词，说起来仿佛是图形界面的专属。现有的趁手录屏工具很多也的确需要桌面环境才能工作。比方说常用的obs。如果在tty中执行obs的录屏命令：

```
obs --startrecording
```

很遗憾，无效。obs会提示&quot;cannot connect to display&quot;。大概是因为运行obs需要显示一个Qt窗口。

好在tty下录屏并非毫无办法，ffmpeg提供了一条路，直接读取Linux的framebuffer：`/dev/fb*`。

&gt; 切换tty，一般是按`ctrl`+`alt`+`F1~F6`，对应tty1到6。我的机器上tty1和tty2对应桌面环境。

## /dev/fb*

UNIX操作系统最重要的设计原则之一就是“一切皆文件”。Linux继承了这个优点，将一系列设备抽象为设备文件，放置在`/dev`目录下。

显示设备也不例外。图形显示器被抽象为一个帧缓冲〔framebuffer〕文件，也就是本节标题中的`/dev/fb*`，在我的机器上是`/dev/fb0`，如果电脑连接了多个显示器，或许还会有`/dev/fb1`等等。要获取显示的内容，可以直接读取此文件；要操作显示的内容，也可以直接修改此文件——这个文件充当了程序员和Linux间的接口，抽象了底层的图形操作，对用户空间的程序编写者隐藏细节。

我们可以认为`/dev/fb*`当中存放了屏幕上各个像素的颜色。只要能够不断读取这些信息，转化成视频格式，录屏就完成了。

这当然可以实现，比如我们打开tty。

```
cp /dev/fb0 test
```

然后做一些操作，让屏幕显得不同。接着执行：

```
cat test &gt;&gt; /dev/fb0
```

我们会发现屏幕变回去了。实际上我们实现了截图。

[这篇博文](https://cmcenroe.me/2018/01/30/fbclock.html)讲解了利用帧缓冲设备和mmap实现像素级操作屏幕像素的方法。

## 使用FFmpeg进行录制

要把一系列图片编码成一段视频，FFmpeg应该是最合适的工具。不过实际上不必先获取大量“截图”再生成视频，FFmpeg可以直接从`/dev/fb*`获取输入，然后我们只要设定输出格式为mp4（或者其他视频格式），就实现了tty下录屏的方法。

比如：

```
ffmpeg -f fbdev -i /dev/fb0 screenrecord.mp4
```

`-f`指定了输入格式是`fbdev`，也就是帧缓冲设备〔framebuffer device〕的格式，`-i`指定输入，最后指定输出，ffmpeg会自动选择输出格式。

如果没有意外，按下回车就立刻开始录屏了。（要注意权限问题）

如果录屏的时候要做其他事情怎么办？我的办法是切换到另一个tty，简单粗暴。

## 不只是录屏

FFmpeg不仅仅可以读取帧缓冲设备，还可以修改它。完全可以使用它在tty下播放视频。

```
ffmpeg -i screenrecord.mp4 -pix_fmt bgra -f fbdev /dev/fb0
```

会发现刚才录制的视频开始播起来了。fbdev的颜色格式似乎一般是BGRA，不同于RGBA。

## 参考

[Programming the Linux Framebuffer · C. McEnroe](https://cmcenroe.me/2018/01/30/fbclock.html)

[FFmpeg Documentation](https://ffmpeg.org/documentation.html)

[Linux内核关于帧缓冲设备的文档](https://www.kernel.org/doc/html/latest/fb/framebuffer.html)

[关于ffmpeg如何输出到framebuffer的问答](http://unix.stackexchange.com/questions/342815/how-to-send-ffmpeg-output-to-framebuffer)

        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        SIMD与RISC-V的向量扩展
        
        </title>
        <url>////nth233.top/posts/2022-01-09-RISC-V的向量扩展.html</url>
        <search-text>
        
        
            体系结构
        
            归纳整理
        
            ISA
        
            SIMD
        
        
        
        体系结构
        
        
        
&gt;  原是体系结构的“课程研究报告”。不过既然已经花了那么多时间搜集资料，写出来的东西只当成作业上交未免有点浪费。

虽然RISC-V的向量扩展（V-extension）目前还在草案阶段，但是已经基本成型了。出于对RISC-V的兴趣，我决定以其向量扩展为研究学习主题。

我原先以为RISC-V向量扩展的的设计会类似Intel的SSE、AVX指令集，但是查找资料的结果告诉我并非如此。与SIMD指令的路子不同，RISC-V选择了向量处理，类似上课讲过CRAY向量机的处理方式。RISC-V文档中，压缩整型扩展（P扩展）被砍掉了，另外提出了向量扩展（V扩展）。关于这点，Patterson（RISC-V的发起人之一，《计算机体系结构：量化方法》的作者之一，图灵奖得主）甚至还专门写了一篇很有意思的文章，批评SIMD指令并不是一个好设计。

SIMD是Flynn分类法中”单指令多数据“的简写，为何这一数据级并行的基本思路会受到Patterson的批判？下面我简要概括一下Patterson等人的理由。

## SIMD指令为什么「被认为是有害的」？

在发表于SIGARCH上的《**SIMD Instructions** Considered Harmful》一文中，Patterson和Waterman提出了以下理由，说明为什么SIMD指令的出发点看似仅仅是划分寄存器，允许同时对不同部分进行运算，但是却”好心办了坏事“，带来不少害处。

1. 对于元素宽度不同的划分方式，SIMD指令集需要提供不同的指令，硬件也有些复杂

2. 当SIMD寄存器改进得更宽（宽一倍），为了兼容性，指令数量也几乎需要翻倍

3. SIMD指令带来的复杂程度，与带来的性能提升或许并不匹配

SIMD指令本质上缺乏灵活性，因此随着指令架构的演进不可避免地变得非常庞大、复杂。比如，Intel的IA-32从1978年至今从80条指令演化到了1400条指令，这么大数量的增加很大程度上是为了SIMD指令。对比Intel的指令集文档和RISC-V的文档页数，前者不仅分成好几卷，一卷基本上就有几千页，后者总共核心内容只有几十页，总共加在一起应该也没有500页。SIMD指令很大程度上使得指令级非常复杂，并且复杂程度很可能随着架构演进，还要继续增加。

关于第三点，两位作者对一个平凡而简单的程序进行了分析，统计指令的数量，假设n=1000

```
    void daxpy(size_t n, double a, const double x[], double y[])
    {
     for (size_t i = 0; i &lt; n; i++) {
       y[i] = a*x[i] + y[i];
     }
    }
```

![](https://www.sigarch.org/wp-content/uploads/2017/09/SIMDHarmfulTable2.jpg)

使用CRAY式向量流水线的RV32V在n=1000时几乎是完胜使用SIMD的前两者。据此测试结果，两位作者不得不对SIMD指令这种方式带来的提升提出质疑，并认为SIMD指令不是一个好思路。

当然对SIMD指令的批判并不意味着SIMD一无是处，在图像处理中，彩色像素几乎总是包含三个值（RGB），经常需要对这三个值做相同的操作，这种情况下SIMD就是非常好的方案。按照我个人的理解，两位作者意指传统的SIMD**指令**带来的代价太大，而不是SIMD这一**思路**本身无用。

RISC-V的向量扩展和粗暴地添加指令和硬件不同。Eirk Engheim的文章对这种动机进行了进一步说明：“用向量架构，可以更优雅地实现数据级并行。”

## RISC-V的向量指令扩展

我尝试阅读了RISC-V向量指令扩展的细则（spec），虽说不能完全掌握其使用，但是对其灵活性有更直接的感受。

### 基本概念

向量扩展指令集添加了若干个CSR（控制状态寄存器），定义了一些基本的控制状态，比如向量开始位置、向量数据类型、向量长度等等。其中我觉得最重要的是`vtype`寄存器，灵活性就体现于此，后面具体说明。

还有32个向量寄存器`v0-v31`，每个寄存器都有VLEN个位。

### 向量指令扩展如何处理向量

![Processing elements two vectors with just one ALU. Normally there will be more ALUs to process multiple elements in parallel.](https://miro.medium.com/proxy/1*n2UKrFFCFVAfuqiealwtQA.png)

如图（图来自Erik Engheim的文章），不同于SIMD，一次只使用一个ALU，只对一对元素进行操作，但是向量寄存器可以很长。

具体实现中在`vtype`寄存器中的`[5:3]`位表示`vsew[2:0]`，`[2:0]`位表示`vlmul[2:0]`。前者设置SEW（选中元素宽度），后者设置LMUL（分组因子）。

SEW表示了一个向量寄存器中有多少个元素，如果SEW是16，那么向量的每个元素就有16个位，向量包含的元素个数就是VLEN/16。

LMUL表示分组方案，上面提到向量寄存器可以很长，但是实际上「很多向量」和「很长的向量」不能同时取得，分组就是一种折衷方案（compromise），当LMUL是1的时候，不分组；当LMUL是2的时候，两个向量一组，比如，v0和v1被接在一起了，v2和v3接在一起，向量长度相比不分组就长了一倍。LMUL取4、8以此类推。LMUL还可以取分数，缩短向量长度。具体的分组方法和接法在spec中有图表说明。

我觉得SEW和LMUL的设置就是RISC-V向量扩展灵活性的核心。通过在CSR`vtype`中设置这两个参数，就能调整机器看待向量的方式，**可长可短，可宽可窄，按需设置**。另外CSR必须用专门的指令进行修改，spec中说明这可以简化CSR的管理。

### 具体的向量指令

使用`vsetvl`系列指令设置`vtype`寄存器。spec中建议汇编器使用一些预先定义的名字来表示LMUL。比如

```
vsetvli t0, a0, e8, m2  # SEW= 8, LMUL=2
```

从内存中加载向量使用`vl`系列指令，写回内存中使用`vs`系列指令。加载和写回都有三种寻址方式，如同课上说过的，unit-stride（单位步长）、stride（常数步长）、indexed（索引）。第一种指定位置开始，一次取一个元素。第二种从指定位置开始，先取一个元素，然后走一个给定的步长后再取下一个元素（适合行主序存储时取列），索引则需要提供另一个向量提供各个元素的偏移量（适合稀疏的数据）。

spec举例如下。`vd`代表目标向量寄存器。`(rs1)`代表主存中的地址，用一个通用寄存器给出，`vm`是掩码，此处不讨论。

```
vle8.v vd, (rs1), vm    # 8-bit unit-stride load
vlse8.v vd, (rs1), vm    # 8-bit strided load
vle32.v vd, (rs1), vm    # 32-bit unit-stride load
vlse32.v vd, (rs1), vm    # 32-bit strided load
vluxei8.v vd, (rs1), vs2, vm  # unorderd 8-bit indexed load of SEW data
vluxei32.v vd, (rs1), vs2, vm # unorderd 32-bit indexed load of SEW data
```

写回内存只需将指令换成对应的`vs`系列指令。

向量运算部分，十分简单，不过浮点指令和整型指令是分开的，另外还有一族加宽度的指令，即结果的SEW是操作数SEW的两倍。

以整型加法为例，不仅有向量加向量，还有向量加标量，向量加立即数。减法、乘法、移位都类似。甚至还有取最值（最大值、最小值）的指令。

```
vadd.vv vd, vs2, vs1, vm # vector add vector
vadd.vx vd, vs2, rs1, vm # vector add scalar
vadd.vi vd, vs2, imm, vm # vector add immediate
```

上面提到的掩码可以用于合并向量。掩码实际上也存储在一个向量寄存器中，掩码向量之间可以做逻辑运算。被“掩”住的元素不会发生异常。

### 简单程序

上面`daxpy`函数，Patterson的文章给出了RISC-V指令集和IA-32 AVX的汇编代码

```
# a0 is n, a1 is pointer to x[0], a2 is pointer to y[0], fa0 is a
  0:  li t0, 2&lt;&lt;25
  4:  vsetdcfg t0             # enable 2 64b Fl.Pt. registers
loop:
  8:  setvl  t0, a0           # vl = t0 = min(mvl, n)
  c:  vld    v0, a1           # load vector x
  10:  slli   t1, t0, 3        # t1 = vl * 8 (in bytes)
  14:  vld    v1, a2           # load vector y
  18:  add    a1, a1, t1       # increment pointer to x by vl*8
  1c:  vfmadd v1, v0, fa0, v1  # v1 += v0 * fa0 (y = a * x + y)
  20:  sub    a0, a0, t0       # n -= vl (t0)
  24:  vst    v1, a2           # store Y
  28:  add    a2, a2, t1       # increment pointer to y by vl*8
  2c:  bnez   a0, loop         # repeat if n != 0
  30:  ret                     # return
```

```
# eax is i, n is esi, a is xmm1,
# pointer to x[0] is ebx, pointer to y[0] is ecx
 0: push   esi
 1: push   ebx
 2: mov    esi,[esp+0xc]   # esi = n
 6: mov    ebx,[esp+0x18]  # ebx = x
 a: vmovsd xmm1,[esp+0x10] # xmm1 = a
 10: mov    ecx,[esp+0x1c]  # ecx = y
 14: vmovddup xmm2,xmm1     # xmm2 = {a,a}
 18: mov    eax,esi
 1a: and    eax,0xfffffffc  # eax = floor(n/4)*4
 1d: vinsertf128 ymm2,ymm2,xmm2,0x1 # ymm2 = {a,a,a,a}
 23: je     3e              # if n &lt; 4 goto Fringe
 25: xor    edx,edx         # edx = 0
Main Loop:
 27: vmovapd ymm0,[ebx+edx*8] # load 4 elements of x
 2c: vfmadd213pd ymm0,ymm2,[ecx+edx*8] # 4 mul adds
 32: vmovapd [ecx+edx*8],ymm0 # store into 4 elements of y
 37: add    edx,0x4
 3a: cmp    edx,eax          # compare to n
 3c: jb     27               # repeat loop if &lt; n
Fringe:
 3e: cmp    esi,eax          # any fringe elements?
 40: jbe    59               # if (n mod 4) == 0 go to Done
Fringe Loop:
 42: vmovsd xmm0,[ebx+eax*8] # load element of x
 47: vfmadd213sd xmm0,xmm1,[ecx+eax*8] # 1 mul add
 4d: vmovsd [ecx+eax*8],xmm0 # store into element of y
 52: add    eax,0x1          # increment Fringe count
 55: cmp    esi,eax          # compare Loop and Fringe counts
 57: jne    42 &lt;daxpy+0x42&gt;  # repeat FringeLoop if != 0
Done:
 59: pop    ebx              # function epilogue
 5a: pop    esi
 5b: ret
```

后者在真正开始计算前需要做很多准备工作，但是循环体中的指令少；前者整体更简洁，但是循环体中的指令多。但是依靠向量指令和流水线，后者可以规避这一点。看完程序之后我不得不同意RISC-V确实更加优雅。

## 总结

我没有预料到对RISC-V指令的学习会引出这么多有趣的内容，看似人畜无害的SIMD居然会引发这么多争论。

看完资料后我在想，是否真的是向量指令**永远**优于SIMD指令？我觉得如果向量长度很短，向量处理指令未必能够更快，SIMD指令也许更好。因此，对SIMD指令和向量指令的优劣对比都是综合比较的结果，并不是一方全方面完胜另一方。至于谁的trade-off更优，也许只有实际应用才能告诉我们答案。

## 参考文献

- Patterson和Waterman的文章 https://www.sigarch.org/simd-instructions-considered-harmful/https://www.sigarch.org/simd-instructions-considered-harmful/

- Eirk Engheim的文章 https://medium.com/swlh/risc-v-vector-instructions-vs-arm-and-x86-simd-8c9b17963a31

- RISC-V V-extension SPEC https://github.com/riscv/riscv-v-spec



        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        Material Design 相关组件笔记
        
        </title>
        <url>////nth233.top/posts/2021-12-03-Material Design笔记.html</url>
        <search-text>
        
        
            笔记
        
            归纳整理
        
            安卓
        
            Material Design
        
        
        
        整理自《第一行代码》，原文过于啰嗦不便查阅，故摘抄整理之。
        
        
        
&gt; 整理自《第一行代码》，原文过于啰嗦不便查阅，故摘抄整理之。理解肤浅，有错见谅。
&gt; 
&gt; 插图均来自[material.io](material.io)，侵删。

## 工具栏 Toolbar

### 如何使用Toolbar？

1. 修改主题（在`res/values/style.xml`中）为`Theme.AppCompact.NoActionBar`（深色）或`Theme.AppCompact.Light.NoActionBar`（浅色），目的是隐藏默认的`ActionBar`

2. 设置颜色，即`ColorPrimary`等属性（在`res/values/style.xml`中）

3. 在布局中引入`Toolbar`（包为`androidx.appcompat.widget.Toolbar`）

4. 布局应该重设命名空间为`xmlns:app`

5. `Activity`中调用`setSupportActionBar(toolbar)`

&gt; 使用`app`命名空间，而不是`android`，是为了兼容老版本，防止和旧控件冲突

### 如何配置Toolbar显示的内容？

1. 文字：修改`AndroidManifest.xml`，当中`&lt;application&gt;`标签下，可以设置对应Activity的的标题栏文字

2. 增加按钮
   
   1. 新建Menu Resource，添加`&lt;item&gt;`和对应的action按钮，`android:id`、`android:icon`、`android:title`分别设定id、图标和文字
   
   2. 设置`app:showAsAction`指定按钮的显示位置，`always`、`ifRoom`、`never`分别对应「永远显示」、「无空间则进菜单」和「永远在菜单中」
   
   3. 设置按钮的事件：`override onOptionItemSelected(item: Menu Item)`

&gt; 更高级的Toolbar——可折叠工具栏CollapsingToolbarLayout

## 抽屉布局 DrawerLayout

1. 直接使用`DrawerLayout`，其下第一个子控件为主界面，第二个子控件为抽屉中的内容（`layout_gravity`最好设为`start`）

2. 在`Toolbar`最左侧添加菜单按钮「Home按钮」：在Activity中，设置
   
   ```kotlin
   supportActionBar?.let {
       it.setDisplayHomeAsUpEnabled(true) // 启用菜单按钮
       it.setHomeAsUpIndicator(R.drawable.ic_menu) // 图标
   }
   ```
   
   然后在重写的`onOptionsItemSelected`中，当菜单按钮被按下时唤出抽屉
   
   ```kotlin
   // ...
   when (item.itemId) {
       // home按钮的id永远是home
       android.R.id.home -&gt; drawerLayout.openDrawer(GravityCompat.START)
   }
   // ...
   ```

## 导航视图 NavigationView

![](https://lh3.googleusercontent.com/W4QDMYeNtcm37g2JfKKj5lv8rJ6KGLb9vZdYUNEpjixpHDjjQ_hPrwnj5Ruo1ZYHyukHLRQCtXrzQV6gLzRSNE-w60QYjFcUZZ_2=w1064-v0)

导航视图适合与抽屉布局一起使用。

包括两个部分：`headerLayout`和`menu`。分别需要定义对应部分的布局。menu还需要有个xml文件定义菜单中的具体项目。

设置完成所需的xml后，将`NavigationView`添加到`DrawerLayout`中。

要处理对应的点击事件，只要调用`NavigationView`对象的`setNavigationItemSelectedListener`进行设置，比如

```kotlin
navView.setNavigationItemSelectedListener {
    drawerLayout.closeDrawers()
    true // 表示事件已经被处理
}
```

## 悬浮按钮 FloatingActionButton

相当简单，在布局中加入`&lt;com.google.android.material.floatingactionbutton.FloatingActionButton&gt;`，设置对应的图标和其他属性。设置`app:elevation`可以调整z轴上的「悬浮高度」。

&gt; 默认颜色为`colorAccent`

点击事件和`Button`没有区别。`setOnClickListener`，相当简单。

## 「快餐店」 SnackBar

SnackBar一定程度上可以替代「吐司」Toast。相比Toast，用户不仅仅是被动接受通知，而是可以给出一定反馈。

![Example of snackbar on a mobile screen](https://lh3.googleusercontent.com/-osHhhWWYPzLb8UmhUU1pmmd2q-bUj1vU8raFKcPtAxDPMdRlGixw31rhd1EcOiW6guvgFZAflH7rFF1b-D45Pk-SFmPGiBg9BpazQ=w1064-v0)

用法类似Toast，比如

```kotlin
Snackbar.make(view, &quot;Can&#39;t send photo&quot;, Snakebar.LENGTH_SHORT)
    .setAction(&quot;Retry&quot;) {
        // retry
    }.show()
}
```

## 协调布局 CoordinatorLayout

增强版的`FrameLayout`，具有一定Material Design相关的能力。比如Snakebar弹出的时候不会覆盖住「悬浮按钮」，而是会将悬浮按钮「挤」上去。

## 卡片视图 MaterialCardView

原先的卡片加了点阴影。略。

## 应用栏布局 AppBarLayout

使用协调布局时，Toolbar会被主体部分遮盖。因此引入应用栏布局。使用时将Toolbar包裹到AppBarLayout当中即可保证Toolbar不被遮挡。而且可以顺带通过调整`app:layout_scrollFlags`来实现向上滚动自动隐藏Toolbar的功能。

## 下拉刷新布局 SwipeRefreshLayout

Material Design风格的下拉刷新。使用的时候可以把RecyclerView包裹到下拉刷新布局中。

假设`SwipeRefreshLayout`的id为`swipeRefresh`，那么用例如下

```kotlin
swipeRefresh.setColorSchemeResources(R.color.colorPrimary)
swipeRefresh.setOnRefreshListener {
    // 刷新逻辑
    myRefresh(adapter)
}
```

```kotlin
private fun myRefresh(adapter: XXXAdapter) {
    thread {
        // Thread.sleep(2000)
        runOnUiThread {
            // ...
            adapter.notifyDataSetChanged()
            swipeRefresh.isRefreshing = false;
        }
    }
}
```

下拉自动开始刷新（显示刷新进度条，并用`thread`函数开新线程执行刷新逻辑），刷新完成后，用`runOnUiThread`回到界面线程并停止刷新（隐藏刷新进度条）。

## 其他种种部件

上[material.io](material.io)应有尽有。



        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        抄几首戴望舒的诗
        
        </title>
        <url>////nth233.top/posts/2021-10-01-抄几首戴望舒的诗.html</url>
        <search-text>
        
        
            抄
        
            诗
        
        
        
        国庆前偶然在图书馆的还书架上瞥见一本戴望舒的诗集，薄薄一册，顺手便借过来，打算晚课的时候偷偷看。没想到就这样打开的新世界的大门，当晚的情绪久久不能平复。除了诗行间渗透着的情感，精妙的用词、独特的比喻、极具冲击力的对比给我一种解谜般的快感也是我喜欢这些诗的原因。
        
        
        
国庆前偶然在图书馆的还书架上瞥见一本戴望舒的诗集，薄薄一册，顺手便借过来，打算晚课的时候偷偷看。没想到就这样打开的新世界的大门，当晚的情绪久久不能平复。除了诗行间渗透着的情感，精妙的用词、独特的比喻、极具冲击力的对比给我一种解谜般的快感也是我喜欢这些诗的原因。

我先前不喜欢所谓现代诗，主要原因是它们格式过于“混乱”，有些甚至难读。但这个诗集改变了我的看法。朗朗上口固然更好，但这不是诗歌成功传情达意、营造诗境的必要条件。

&gt; 诗的韵律不在字的抑扬顿挫上，而在诗的情绪的抑扬顿挫上，即在诗情的程度上。

诗抛弃了「字的韵律」还是诗，而且能形成一种独特的风格。

望舒前期大概高频词是寂寞和悒郁，后期则是苦难。

----

《凝泪出门》

&gt; 昏昏的灯
&gt; 
&gt; 溟溟的雨
&gt; 
&gt; 沉沉的未晓天：
&gt; 
&gt; 凄凉的情绪
&gt; 
&gt; 将我的愁怀占住
&gt; 
&gt; 〔……〕

叠词开头，让我想到李清照。

---

《山行》

&gt; 见了你朝霞的颜色，
&gt; 
&gt; 便感到我落月的沉哀，
&gt; 
&gt; 〔……〕

所有的修辞中我最爱对比。

&gt; 〔……〕
&gt;
&gt; 我们彳亍在微茫的山径，
&gt; 
&gt; 让梦香吹上了征衣，
&gt; 
&gt; 和那朝霞，和那啼鸟，
&gt; 
&gt; 和你不尽的缠绵意。

---

《残叶之歌》

&gt; 〔……〕

微风与残叶的爱。微风终将离去，残叶却情愿被吹上长空。

---

《夜》

&gt; 夜是清爽而温暖，
&gt;
&gt; 飘过的风带着青春和爱的香味；
&gt;
&gt; 我的头是靠在你裸着的膝上，
&gt;
&gt; 你想微笑，而我却想啜泣。
&gt;
&gt; &lt;br&gt;
&gt;
&gt;
&gt; 温柔是缢死在你的发丝上，
&gt;
&gt; 它是那么长，那么细，那么香；
&gt;
&gt; 但是我怕着，怕着那飘过的风
&gt;
&gt; 要把我们的青春带去。
&gt;
&gt; &lt;br&gt;
&gt;
&gt;
&gt; 我们只是被年海的波涛
&gt;
&gt; 挟着飘去的可怜的沉舟，
&gt;
&gt; 不要讲古旧的绮腻风光了，
&gt;
&gt; 纵然你有柔情，我有眼泪。
&gt;
&gt; &lt;br&gt;
&gt;
&gt;
&gt; 我是害怕那飘过的风，
&gt;
&gt; 那带去了别人的青春和爱的风，
&gt;
&gt; 它也会带去我们底，
&gt;
&gt; 然后丝丝地吹入了凋谢的蔷薇花丛。

---

《独自的时候》

&gt; 房间里充满过晴朗的笑声，
&gt;
&gt; 正如花园里充满过百合或素馨，
&gt;
&gt; 人在满积的梦的灰尘中抽烟，
&gt;
&gt; 沉想着凋残了的音乐。

「高阁客竟去，小园花乱飞。」

这首诗让我想到李商隐。

---

《秋》

&gt; 我对它没有爱也没有恐惧，
&gt;
&gt; 你知道它所带来的东西的重量，
&gt;
&gt; 我是微笑着，安坐在我的窗前，
&gt;
&gt; 当飘风带着恐吓的口气来说：
&gt;
&gt; ​	秋天来了，望舒先生！

秋天的肃杀。

~~《秋声赋》~~

---

《对于天的怀乡病》

&gt; 〔……〕
&gt;
&gt; 怀乡病，哦，我啊，
&gt; 
&gt; 我也许是这类人之一吧；
&gt; 
&gt; 我呢，我渴望着回返
&gt; 
&gt; 到那个天，到那个如此青的天，
&gt; 
&gt; 在那里我可以生活又可以死灭，
&gt; 
&gt; 像在母亲的怀里，
&gt; 
&gt; 一个孩子欢笑又啼泣。
&gt;
&gt; 〔……〕

有时我的脑海也会突然闪过十年前那个世界的模样，那时的世界和现在大不相同。不仅是风貌不相同。那时「理想」是模糊的，但「追求理想」却是明确的。

那时似乎所有的一切都充满憧憬。

那是「故乡」。

---

《印像》

&gt; 〔……〕
&gt;
&gt; 林梢闪着的颓唐的残阳，
&gt; 
&gt; 它轻轻地敛去了
&gt; 
&gt; 跟着脸上浅浅的微笑。

太朦胧了。

---

《到我这里来》

&gt; 到我这里来，假如你还存在着，
&gt; 
&gt; 全裸着，披散了你的发丝：
&gt; 
&gt; 我将对你说只有那只有我们两人懂得的话。
&gt;
&gt; 〔……〕

前面充分渲染了欲望，突然一个「可是，啊，你是不存在着了」，欲望变成了徒然等待，气氛瞬间变得凄凉。

---

《烦忧》

&gt; 说是寂寞的秋的悒郁，
&gt;
&gt; 说是辽远海的怀念。
&gt;
&gt; 假如有人问我烦忧的原故，
&gt;
&gt; 我不敢说出你的名字。
&gt;
&gt; &lt;br&gt;
&gt;
&gt;
&gt; 我不敢说出你的名字，
&gt;
&gt; 假如有人问我烦忧的原故。
&gt;
&gt; 说是辽远海的怀念，
&gt;
&gt; 说是寂寞的秋的悒郁。

最爱。

---

《款步》

&gt; 这里是爱我们的苍翠的松鼠，
&gt;
&gt; 它曾经遮过你的羞涩和我的胆怯，
&gt;
&gt; 我们的这个同谋者是有一个好记心的，
&gt;
&gt; 现在，它还在向我们说着旧话，但并不揶揄。
&gt;
&gt; &lt;br&gt;
&gt;
&gt;
&gt; 还有那多嘴的深草间的小溪，
&gt;
&gt; 我不知道它今天为什么缄默；
&gt;
&gt; 我不看见它，或许它已换一条路走了，
&gt;
&gt; 饶舌着，施施然绕着小村而去了。
&gt;
&gt;
&gt; 〔……〕

很有趣。

---

《过时》

&gt; 说我是一个在怅惜着，
&gt;
&gt; 怅惜着好往日的少年吧，
&gt;
&gt; 我唱着我崭新的小曲，
&gt;
&gt; 而你却揶揄：多么“过时！”
&gt;
&gt; &lt;br&gt;
&gt;
&gt; 是呀，过时了，我的“单恋女”
&gt;
&gt; 都已经变作妇人或是母亲，
&gt;
&gt; 而我，我还可怜地年轻——
&gt;
&gt; 年轻？不吧，有点靠不住。
&gt;
&gt; &lt;br&gt;
&gt;
&gt; 是呀，年轻是有点靠不住，
&gt;
&gt; 说我是有一点老了吧！
&gt;
&gt; 你只看我拿手杖的姿态
&gt;
&gt; 它会告诉你一切；而我的眼睛亦然。
&gt;
&gt; &lt;br&gt;
&gt;
&gt; 老实说，我是一个年轻的老人了：
&gt;
&gt; 对于秋草秋风是太年轻了，
&gt;
&gt; 而对于春月春花却太老了。

少年与老者，主人公的两个形象对比起来极具冲击性。手杖告诉了我们一切，也揭露了其背后的故事。读来有种解谜的快感。

---

《妾薄命》

&gt; 明天的梦已凝成了冰柱；
&gt;
&gt; 还会有温煦的太阳吗？
&gt;
&gt; 纵然有温煦的太阳，跟着檐溜，
&gt;
&gt; 去寻碎梦的玎𤤮吧！

很像唐代的宫怨诗。但着后面梦碎的比喻很新奇，很美。

---

《少年行》

&gt; 是簪花的老人呢，
&gt;
&gt; 灰暗的篱笆披着茑萝；
&gt;
&gt; &lt;br&gt;
&gt;
&gt; 旧曲在颤动的枝叶间死了，
&gt;
&gt; 新锐的蝉用单调的生命赓续。
&gt;
&gt; &lt;br&gt;
&gt;
&gt; 结客寻欢都成了后悔，
&gt;
&gt; 还要学少年的行蹊吗？
&gt;
&gt; &lt;br&gt;
&gt;
&gt; 平静的天，平静的阳光下，
&gt;
&gt; 烂熟的果子平静地落下来了。

题目是《少年行》，但是描写的却是老人。老人也曾是少年，颓唐悔恨的「当下」，暗示了怎样的「当年」。

~~有种唐诗的感觉。~~

---

《旅思》

&gt; 〔……〕
&gt;
&gt; 栈石星饭的岁月，
&gt;
&gt; 骤山骤水的行程：
&gt;
&gt; 只有旅途的促织声，
&gt;
&gt; 给旅人尝一点家乡的风味。

那么你是为了什么而旅行呢？

寻梦？

旅途的终点，梦之所在，竟是故乡。

~~有种唐诗的感觉~~

---

《眼》

这首诗很新奇。

什么东西如同深渊、如同大海、奔涌着百川、翻腾着大浪、星辰出入其中？

是你的眼。

而我，是你眼里的星空。

---

《我思想》

&gt; 我思想，故我是蝴蝶……

庄生梦蝶

苇草

笛卡尔

---

《白蝴蝶》

&gt; 给什么智慧给我，
&gt;
&gt; 小小的白蝴蝶，
&gt;
&gt; 翻开了空白之页，
&gt;
&gt; 合上了空白之页？
&gt;
&gt; &lt;br&gt;
&gt;
&gt; 翻开的书页：
&gt;
&gt; 寂寞；
&gt;
&gt; 合上的书页：
&gt;
&gt; 寂寞。

新奇。

---

《狱中题壁》《我用残损的手掌》《等待》

&gt; 〔……〕

苦难的岁月。《等待》有两首，一首是后方的心声，一首是前线的呐喊。~~杜甫~~

---

《过旧居》（初稿）

&gt; 静掩的窗子隔住尘封的幸福，
&gt;
&gt; 寂寞的温暖饱和着辽远的炊烟——
&gt;
&gt; 陌生的声音还是解冻的呼唤？……
&gt;
&gt; 挹泪的过客在往昔生活了一瞬间。

我个人偏爱初稿，终稿反而不那么有感觉。

「在往昔生活了一瞬间」。看见的旧居，仿佛曾经的岁月。

曾经的主人，如今的过客。窗内的温馨，窗外的严冬。


        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        从8086到x64
        
        </title>
        <url>////nth233.top/posts/2021-07-01-从8086到x64.html</url>
        <search-text>
        
        
            折腾记录
        
            汇编
        
            x64
        
        
        
        相信所有学习过「计算机组成原理与汇编语言」课程的人都受过8086的折磨：少得可怜的寄存器、远古开发环境、远古命令行调试器`debug`、复古的DOS操作系统，还有一点……**实机不能运行**。如果说前面几点还勉强可以忍受，那么最后一点实在是忍无可忍。8086已经是古玩了，Intel和微软的向前兼容也有限度，这导致了现在流行的64位操作系统上根本无法直接运行为8086编写的代码。于是为了继续教8086，现在国内大量学校使用某部分功能收费的IDE进行教学，写出来的东西也只能在Dosbox里面打转。但是，脱离实机的运行环境，学得再多也难对实践有太多助益。
        
        
        
相信所有学习过「计算机组成原理与汇编语言」课程的人都受过8086的折磨：少得可怜的寄存器、远古开发环境、远古命令行调试器`debug`、复古的DOS操作系统，还有一点……**实机不能运行**。如果说前面几点还勉强可以忍受，那么最后一点实在是忍无可忍。8086已经是古玩了，Intel和微软的向前兼容也有限度，这导致了现在流行的64位操作系统上根本无法直接运行为8086编写的代码。于是为了继续教8086，现在国内大量学校使用某部分功能收费的IDE进行教学，写出来的东西也只能在Dosbox里面打转。但是，脱离实机的运行环境，学得再多也难对实践有太多助益。

好在从8086转到x64不困难。基础的指令基本相同，寄存器的名字也一脉相承，而且还干掉了分段和8086奇葩的20根地址线，使得编写程序更简单了（相当于以前的`flat`格式。而且转到x64还能带来生态上的改进：更先进易用的操作系统和更与时俱进的调试器，效率得以大幅提升。

&gt; 之所以给新手教8086的指令集，一般都说是因为「8086简单」。然而和它的兄弟8088相比，8086还复杂了一些，和RISC架构的几个指令集相比，8086更是一点也不简单，甚至和x64相比，8086也只是显得简陋，基础的指令集并不显得更“简单”。并且在当下，8086已经严重过时，使得学习难度变得更高。
&gt;
&gt; 过去给新手教8086，或许只是因为这个架构具有里程碑意义，而且在容易找到可以运行的实机（得益于Intel和微软的垄断地位）。现在给新手教8086，也许只是因为懒于改革而已。实际上应该新手适合学x64（有实机）或者RISC-V（简单）。

## 第一步：寄存器和指令

### 寄存器

在基础的指令集上，实际上没有什么改变的；寄存器也只是改了个名、加了些新的。首先，在`ax`、`bx`、`cx`、`dx`、`si`、`di`这几个8086的通用寄存器前面加上`r`，就得到相应的64位寄存器，比如`rax`、`rdi`。原先的名字依然可以使用，不过得到的是这几个通用寄存器的低16位。把`r`换成`e`，就得到64位寄存器的低32位，比如`eax`，这是i386的遗产。`ah`、`al`这几个8位寄存器仍然可以使用，含义和以前相同。`flags`现在叫做`rflags`，它也是64位宽，不过高32位尚未使用，低32位和32位的`eflags`相同，低16位和之前的`flags`相同。

另外，x64引入了`r8`到`r15`8个新通用寄存器，都是64位宽。后面加上`d`表示取其低32位，加上`w`代表取其低16位，加上`b`代表取其低8位（在intel格式中用`l`）。注意，不存在`r8h`这个寄存器，传统的高8位寄存器`ah`、`bh`、`ch`、`dh`不能和`r8b`这些寄存器同时出现在一条指令里。

&gt; `d`代表双字（doubleword，32位），`w`代表字（word，16位），`b`代表字节（byte）。后面还会提到`q`，代表肆字（quadword，64位）。「肆字」这个叫法是我自己编的，译法参照化学中的「碳碳叁键」。

`ip`现在叫做`rip`。

你会发现我没有提到`ds`、`cs`等段寄存器，没错，他们被干掉了。长模式下段寄存器无用。

此外还有80位宽的浮点数寄存器`fpr0`到`fpr7`，他们的低64位用于MMX寄存器，更具体的内容这里不赘述，因为编写简单的程序似乎不怎么会用到，具体可以查看Intel或AMD的文档。

### 指令

指令实际上没有什么不同。原先的指令被全数保留，即使有细微的差别，通过查文档也可以解决。

所有的指令后面加上`q`、`d`、`w`、`b`可以指明后面操作数的宽度。不过一般不需要手动加，汇编器会自动做。比如下面两条指令其实没有什么差别。

```
addq rax, 100
add rax, 100
```

乘法指令和除法指令也和以前几乎一样。

```
mul bx
mul rbx
```

第一条指令会把`ax`乘`bx`结果的高位存在`dx`中，低位存在`ax`中；类似地，第二条指令会把`rax`乘`rbx`的结果存在`rdx`:`rax`中。

另外还有一点值得注意，寻址的时候应该使用64位寄存器。比如

```
mov ax, word ptr [rsp + 8]
```

把`rsp`换成`sp`则是不对的。

## 第二步：操作系统和汇编器

由于笔者使用Linux，因此下面的内容只针对Linux操作系统。实际上Windows下也只是换汤不换药，改成Windows的系统调用即可。

汇编器我选择了GAS（GNU Assembler），很多发行装好就自带binutils了，其中就包括了GAS。使用命令`as`就可以调用GAS。链接器自然也使用binutils的`ld`。GAS默认使用AT&amp;T的汇编格式，立即数前加`$`，寄存器名字前加`%`，源操作数在前，目标操作数在后。不过我实在难以习惯，还是使用intel的格式。

### 调用约定

Linux继承了System V的调用约定（calling conventions），`rdi`存放第一个参数，`rsi`存放第二个参数，`rdx`存放第三个参数，`r10`存放第四个参数，`r8`存放第五个参数，`r9`存放第六参数。第一个返回值存在`rax`中，第二个返回值存在`rdx`中。按照约定，被调用者保证调用后`rbx`、`r12`到`r15`、`rbp`和`rsp` 内容不变。

详见下图

![System V Calling Convention](/assets/img/post/calling.png)

### 系统调用

系统调用除了要按照上面的调用约定进行调用外，还需要往`rax`中放入系统调用号。下面的最常用的两个系统调用：

| `rax` | System Call | `rdi`           | `rsi`           | `rdx`        |
| ----- | ----------- | --------------- | --------------- | ------------ |
| 0     | sys_read    | unsigned int fd | char *buf       | size_t count |
| 1     | sys_write   | unsigned int fd | const char *buf | size_t count |
| 60    | sys_exit    | int error_code  |                 |              |

`read`和`write`返回值都是实际读/写的字节数。`exit`结束程序，可以设定程序退出后返回的错误码，`0`表示正常。

准备好相关参数，就可以使用`syscall`指令直接进行系统调用。比如下面的代码，把`rsi`指向的内容输出到标准输出中。（UNIX中一切皆文件，`stdin`的文件描述符为0，`stdout`为1，`stderr`为2）

```
lea rsi, msg # msg为要输出的字符串的标号
mov rdi, 1
mov rax, 1
mov rdx, 5 # 输出五个字符
syscall # 系统调用
```

如果`msg`的位置指向字符串`helloworld\0`，那么调用后将输出`hello`。

类似地，下面的代码用于终止程序

```
mov rax, 60
mov rdi, 0
syscall
```

相当于DOS下8086的

```
mov ax, 4c00h
int 21h
```

### GAS代码格式

MASM中里面需要用`xxx segment`和`xxx ends`来定义各种段，GAS中不需要。

`.data`后面的内容就是数据段的内容，`.text`后的内容就是代码段的内容。程序的入口为`_start`，为了让汇编器找到`_start`，需要将其设为外部文件可见的，使用`.global _start`即可。`#`之后的内容为单行注释。

于是一个典型的程序框架如下：

```
.intel_syntax noprefix # 启用intel格式
.data
# 数据段中的一些定义

.text
.global _start

_start:
    # 一些代码
    
    # 终止程序
    mov rax, 60
    mov rdi, 0
    syscall
end
# end 之后的东西会被汇编器忽略
```

GAS中有一些常用的宏。

|                    | 作用                                  |
| ------------------ | ------------------------------------- |
| `.ascii`           | 后跟字符串                            |
| `.asciz`           | 后跟字符串，自动以0结尾               |
| `.byte`            | 后跟一个字节                          |
| `.rept x`和`.endr` | 把`.rept`和`.endr`之间的内容重复`x`遍 |

本文只是概述，更多内容可以参考GAS的文档。

至此，我们可以开始写第一个程序了。

## 第三步：Hello World!

这里直接给出程序。

```
.intel_syntax noprefix
.data
msg: .ascii &quot;Hello World!\n&quot;
.equ msg_len, .-msg

.text
.global _start
_start:
    lea rsi, msg
    mov rdi, 1
    mov rax, 1
    mov rdx, msg_len
    syscall

    mov rax, 60
    mov rdi, 0
    syscall
.end

```

第四行的`.equ msglen, .-msg`定义了一个新符号`msglen`，`.-msg`代表当前地址减去`msg`的偏移量，即为字符串的长度。

编写完成后命名为`helloworld.s`，然后调用下面的命令进行汇编。`-g`是为了便生成调试信息，可以去掉。

```
as -g helloworld.s -o helloworld.o
```

然后链接。

```
ld helloworld.o -o helloworld
```

此时应该会得到一个可执行文件`helloworld`，执行之，即可获得预期的结果：终端输出了`Hello World!`。

只写个Helloworld略有一点乏味，下面的程序读取用户输入的数字，转成二进制输出，把`0`输出为绿色。其中使用了颜色代码`\033[0;32m`（绿色）和`\033[0m`（默认颜色）。绿色代码后的字符全部显示为绿色，默认颜色同理。

```
.intel_syntax noprefix
.data
input_buffer:
.rept 40 
	.byte 0 
.endr
output_buffer:
.rept 100
	.byte 0
.endr
msg1: .asciz &quot;input a num (hex): &quot;
msg2: .asciz &quot;binary: &quot;
color_start: .asciz &quot;\033[0;32m&quot;
color_reset: .asciz &quot;\033[0m&quot;
lf: .ascii &quot;\n&quot;


.text
.global _start

# output LF
_newline:
	mov rax, 1
	mov rdi, 2
	lea rsi, lf
	mov rdx, 1
	syscall
	ret
	
# rdi - string to insert
# rsi - buffer begin
# rdx - pos
_insert_into_buffer:
	xor rax, rax
insert_into_buffer_loop:
	mov al, byte ptr [rdi]
	inc rdi
	cmp al, 0
	jz insert_into_buffer_loop_end
	mov byte ptr [rsi+rdx], al
	inc rdx
	jmp insert_into_buffer_loop
insert_into_buffer_loop_end:
	ret
	
# output rbx in binary
_output_bin:
	push r12
    xor rcx, rcx
output_bin_loop:

	inc rcx
	mov r10, rbx
	and r10, 1
	add r10B, &#39;0&#39;
	push r10
	sar rbx, 1
	cmp rbx, 0
	jnz output_bin_loop

	xor rdx, rdx
output_bin_loop2:
	pop rax
	mov byte ptr [rdx+output_buffer], al
	cmp al, &#39;1&#39;
	jz output_bin_loop2_even
	mov r12b, byte ptr [rdx+output_buffer]
	lea rdi, color_start
	lea rsi, output_buffer
	call _insert_into_buffer

	mov byte ptr [rdx+output_buffer], r12b
	inc rdx

	lea rdi, color_reset
	lea rsi, output_buffer
	call _insert_into_buffer
	jmp output_bin_loop2_odd
output_bin_loop2_even:
	inc rdx
output_bin_loop2_odd:
	loop output_bin_loop2
	
	lea rsi, output_buffer
	mov rax, 1
	mov rdi, 1
	syscall

	pop r12
	ret

# read line into input buffer
_read_into_buffer:
	push r12
	lea rsi, input_buffer
read_into_buffer_loop:
	mov rax, 0
	mov rdx, 1
	syscall
	mov r12b, byte ptr [rsi]
	inc rsi
	cmp r12b, &#39;\n&#39;
	jnz read_into_buffer_loop
	
	mov byte ptr [rsi], 0
	mov rax, rsi
	sub rax, offset input_buffer
	dec rax
	pop r12
	ret

# parse input buffer, write result into rax
# rdi - start of string
# rdx - length
_parse_input:
	mov rcx, rdx
	xor rbx, rbx
	xor rax, rax
parse_input_loop:
	mov bl, byte ptr [rdi]
	cmp bl, &#39;A&#39;
	jge parse_input_le
	# less then 10
	sub bl, &#39;0&#39;
	jmp parse_input_le_end
parse_input_le:
	sub bl, &#39;A&#39;
	add bl, 10
parse_input_le_end:
	shl rax, 4
	add rax, rbx
	inc rdi
	loop parse_input_loop
	ret

# calc length, and print the string in rsi
_myputs:
	mov r10, rsi
	xor rdx, rdx
myputs_loop:
	mov bl, byte ptr [rsi]
	cmp bl, 0
	jz myputs_loop_end
	inc rdx
	inc rsi
	jmp myputs_loop
myputs_loop_end:
	mov rax, 1
	mov rdi, 1
	mov rsi, r10
	syscall
	ret
	
_start:
read_input:
	lea rsi, msg1
	call _myputs
	call _read_into_buffer
	mov rdx, rax
	lea rdi, input_buffer
	call _parse_input
	push rax
	
output_in_bin:
	lea rsi, msg2
	call _myputs
	pop rbx
	call _output_bin
	call _newline

	# exit
	mov rax, 60
	mov rdi, 0
	syscall
.end

```

应有以下运行结果

![x64result](/assets/img/post/x64result.png)

## 第四步：用`gdb`调试

GDB（GNU Debugger）对应MASM的debug，由于提供了TUI界面，要比DOS下的debug好用不知道多少倍。

```
gdb -tui xxx
```

如是即可使用gdb的TUI界面。具体用法已经超出了本文的范畴，网上资料也不少，暂时先不填坑。这里就放一张图。

![gdb](/assets/img/post/gdbtui.png)

## 参考

1. [x64介绍](https://software.intel.com/content/www/us/en/develop/articles/introduction-to-x64-assembly.html)
2. [System V ABI](https://gitlab.com/x86-psABIs/x86-64-ABI)
3. [微软的调用约定](https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-160)
4. [GAS的文档](http://web.mit.edu/gnu/doc/html/as_7.html)
5. [Linux系统调用号表](https://github.com/torvalds/linux/blob/master/arch/x86/entry/syscalls/syscall_64.tbl)
6. [一份整理好的Linux系统调用表](http://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/)
7. [Intel的文档](www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html)
8. [关于x86汇编的Wikibook](https://en.wikibooks.org/wiki/X86_Assembly)，建议阅读


        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        《后来的事》
        
        </title>
        <url>////nth233.top/posts/2021-04-29-《后来的事》.html</url>
        <search-text>
        
        
            读书笔记
        
        
        
        20世纪初明治年间，电车通勤在东京已是常事。日俄战争业已结束多年，西方文化早如海啸一般涌入日本，处处呈现一股新旧交错的感觉。实业有所发展，而且很有趣的是，那时「几十块钱」还是大钱。主人公代助，年已三十，但是仍然没有工作，尚未结婚，生活全靠父兄帮持，定期去老家父兄那里取钱，啃老族一般。但颇有自己的思想，深受西方文化影响，讲究理性和逻辑，对社会有自己的看法。经常看看外文书，偶尔去听听音乐等等。十分胆小，怕死，怕地震，常常摸着自己的胸部感受心跳。骨子里带着一种妥协的倾向。由于家底殷实，常常可以和上层人物接触。
        
        
        


&gt; 夏目漱石

&gt; 现代人的乖谬。

20世纪初明治年间，电车通勤在东京已是常事。日俄战争业已结束多年，西方文化早如海啸一般涌入日本，处处呈现一股新旧交错的感觉。实业有所发展，而且很有趣的是，那时「几十块钱」还是大钱。

主人公代助，年已三十，但是仍然没有工作，尚未结婚，生活全靠父兄帮持，定期去老家父兄那里取钱，啃老族一般。但颇有自己的思想，深受西方文化影响，讲究理性和逻辑，对社会有自己的看法。经常看看外文书，偶尔去听听音乐等等。十分胆小，怕死，怕地震，常常摸着自己的胸部感受心跳。骨子里带着一种妥协的倾向。由于家底殷实，常常可以和上层人物接触。

可以用代助和父亲的对话来描述代助当前的状态：

&gt; “到了三十岁，还像个游民似的无所事事，实在不成体统呐。”
&gt;
&gt; 代助决不是无所事事，他只是在思考自己和那些不必因为职业有失体面、有颇多闲暇的上等人的问题。父亲每次这么说的时候，代助就觉得实在遗憾——自己没有虚度岁月，而是生活得极有意义，并且有所收获，自己在思想情趣上结出了丰硕的成果；然而父亲那样简单的头脑，竟然一点没有注意到。

代助的父亲长井得，年轻时是武士，为藩主效力。后来赶上维新，从事实业，撑起不错的家底。深受儒家思想影响，常读汉诗。常常和代助讲大道理，令代助觉得虚伪。由于代助30岁仍然没有工作和结婚的意愿，父亲怕影响家族名声，加之恐实业不兴、黑幕曝出（日糖事件），略着急，希望代助可以和恩人女儿的女儿——佐川家的姑娘结婚。父亲希望代助按父亲的计划行事，然而受过新教育的代助不愿如此。

哥哥诚吾，状态和父亲相似，毕业后在父亲的会社工作，也就是经营实业，但是不太在乎那些旧道德。已经娶妻生子。但是很忙，常不在家。和父亲不同，哥哥相信代助不糊涂，有自己的打算。

嫂子梅子，是「过去的天保风气和当代的明治风气天衣无缝地融为一体的人物」。和代助合得来。由于经常有人找哥哥帮忙被拒，出于善心，嫂子经常偷偷借钱出去帮忙。

昔日的同学好友平冈，毕业后进入银行业，但后来发展不顺，帮上级背锅，担负债务。辞职来到东京重新开始，自然要找代助帮忙安顿。故事便从冬春之际两人见面开始。两人见面，竟觉得双方已有很大的隔阂。平冈待业一段时间后，去报社工作，情况十分困窘。

平冈的妻子三千代，昔日代助同学的妹妹。在代助的撮合下和平冈结为夫妻，婚后生活不甚愉快（至少从代助这个方面来看如此）。然而其实三千代和代助二人初次见面起就相互喜欢。但代助当时骨子里的妥协起作用，反而撮合二人结婚。搬来东京后，由于代助的高频出现，导致夫妇隔阂加深。三千代从到达东京起脸色就不佳，生病，同时感到寂寞。和代助互送白百合，这是二人共同的回忆。

其他角色都是陪衬，比如门野，家里的书僮，似乎纯粹是为了便于情节发展而加入的。还有寺尾，似乎纯粹是为了吐槽文坛而添加的。

一面是对三千代的怜悯和爱，另一面是家族的催婚，这对矛盾贯穿整个情节。前者被代助视为「自然」的爱，而后者则被认为是反自然的妥协。随着故事的发展，家族，特别是父兄，劝婚的耐心有限，不断撮合、紧逼；另一边，由于代助的重新出现，三千代产生了对平冈的离心力，和代助反而相互吸引，平冈夫妇矛盾深化，生活日益窘迫，不时来借钱。

最终，代助不得不在二者之间作出选择，要么选择佐川家的姑娘，最大限度保持现在的生活，继续和三千代维持「非正式关系」，要么和三千代私奔，违背道德，断绝和家族的联系（当然原文没有直接说是「私奔」）。代助必须在虚伪的前者和所谓「自然」的后者作出选择。

代助为何不去工作？一方面是家里有钱，不像平冈、寺尾那样受生活重压。另一方面其实是惧怕这种「为生活而劳动」。代助在心里这样为自己辩护，要「为劳动而劳动」，但是能让自己「为劳动而劳动」的职业还没有出现。代助追求一种逻辑、一种朴实的诚信，厌恶虚伪，不喜欢父亲那样把「镀金的东西冒充成真金」，希望「在黄铜就是黄铜的情况下，去忍受人们对黄铜的蔑视」。也就是认为「真诚的烂」优于「虚伪的好」。

因此代助觉得进入新世纪后人心在沦丧，「生活欲的高压促使了道义欲的崩溃」。他觉得当时的教育是在愚民，导致整体的神经衰落，「除了自己干的事情之外，什么也不想」，因为「劳顿使他们无法思想，精神困惫和身体衰落，不幸同时降临，而且道德的败坏也接踵而至」，简直是「暗无天日」。人们从学校学到旧道德和新道德，出社会后却得把这种道德从心里击碎，这被代助认为是新时代的滑稽剧之一。

在双重压力渐渐增大之下，代助的这套逻辑渐渐显得与现实脱节和矛盾。代助要么牺牲自己的理念，妥协于家人，要么坚持自己的理念，不和「自然」相抗，但是因此会断了家里的经济供给，最后妥协于生活。最后代助选择了自然。

&gt; 自己为什么不能早点回到这「自然」中去呢？为什么一开始就同这「自然」相对抗呢？代助在雨中、在百合花香中、在重现的昔日情景中，找到了纯真无邪的和平的生命。这生命里里外外不存在着欲念，不存在得失，不存在压抑自身的道德成见，像行云流水一般自由自在。一切自由，一切美好。

首先，代助向三千代交代，二人达成一致，同时三千代病情的急剧加重、夫妻的矛盾深化使得代助有了紧迫感。因此，一方面，代助想向家族交代，隐晦地询问梅子，梅子认为有喜欢的人自然可以追求（当然代助没有明说是别人的妻子），但是一直没有机会，最后也没有明说，只是直接拒绝了婚事，父亲生气，父子关系断绝。另一方面，代助出于「真诚」，向平冈交代，「开诚公布」地同平冈当面传达了自己的意思，情节达到高潮。平冈大火，内心很难理解，却平静的表示「会有一天把三千代交给你」，但要求代助在那之前不要访问他家，然后二人绝交。此时代助明白，三千代命已不久。之后平冈写信给代助父亲，父亲大怒，嫂子落泪，哥哥前来询问，代助没有解释，全盘承认，兄弟关系破裂，代助和家族的关系彻底瓦解。

&gt; “你这个人一点气魄也没有。”哥哥又说了，“平时说话起来比别人振振有词，到紧要关头，竟然哑口无言了，背地里却干着有伤父兄名誉的勾当。你以往受的教育都哪儿去了？”

最后，代助失去了经济来源，只剩嫂子之前寄来的最后一个月的钱和自己的藏书。代助此时焦头烂额，头脑已经不清醒了，在酷暑中，眼前红颜色的东西和酷暑辉映，扭曲如火舌，头脑发热发晕……

夏目漱石的心理描写实在细腻，其实整本书几乎都是靠代助的心理活动串起来的。从内向外，慢慢揭示代助的内心和代助眼中的近代社会。细腻的心理描写下，情节、对话、动作描写都相形见绌，显得单薄了。环境描写看起来让人很舒服，特别是在关键的时刻插入环境描写，气氛一下就出来了，比如大雨天同三千代的交谈（这个场景我印象深刻）。

看完之后，我觉得代助的矛盾其实本质在于对责任和现实的消极逃避，在于一种惰性/惯性。他那些大道理、那些消极哲学虽然有些方面言之有理，但其实也不过是换了一种方式为自己的欲念找理由罢了，这是代助的软弱和胆小的本性。我觉得，虽然责任和承诺是一切社会关系中不愉快的来源，但是社会关系天然存在着责任，而人又是社会关系的总和，这是不可能逃得掉的。代助追求道义，但却是一种与现实完全不同的道义，他觉得自然是最高的道义，试图摒弃一切 「虚伪」，遵从自己内心。然而这种所谓的摒弃虚伪却使他走上了反道义的路。

看书的时候我常常把自己带入代助中去。现在的学生似乎和以前的有闲阶层类似，可不必工作，只需学习，有一定的知识储备，具备理性，想得更多，最后一起带来的就是代助的这种矛盾的思想。但我似乎也没法从这种思想中摆脱出，我依然想不通为何人们总是只追求物质，而无视长远的幸福，年轻时为了钱和所谓地位拼命学习加班工作，争着做「人上人」，内卷到最后活得还不如一个扫地大爷圆满、有意义。职业选择上，一路上软弱地妥协，抛弃兴趣和理想，或者本就没有兴趣和理想，而且既惧怕不稳定，又惧怕闲暇不足，更惧怕物质基础的消失。道义上我到现在依然十分厌恶虚伪和官僚，但是和以前的那种厌恶不同了，或许礼节和委婉不在虚伪的范畴之内，「虚伪」可能只是人自保的措施罢了。现在，我正处于代助矛盾激化前的状态，有时我会觉得未来是在走下坡路，至少在某些我不愿放弃的方面走下坡路。所以我总是逃避，不愿意失去现在手里紧握着的美好时光。也许未来没有那么悲观，但是有一点可以肯定：

当下的状态是不稳定的，有一天，我也必须作出选择，即使必须走下坡路。


        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        理由
        
        </title>
        <url>////nth233.top/posts/2021-04-20-理由.html</url>
        <search-text>
        
        
            瞎写
        
            blog
        
        
        
        
        
最近翻了很多人的blog，渐渐不知道blog应该写什么东西了。这种迷失感从一开始就存在。

看到有些博主，理由之一是「你是为了别人创作」。有时他们也会把自己的文章发到多个站点、尽可能地在优化自己的搜索引擎排名，并尽量保持高产。

「为了别人创作」，这话当然不假，要不然全部都写进日记了，也不会发到blog里面来。但是如果「为了别人创作」是写blog第一性的理由，这未免把本身值得享受的事情，变得好像是一种累赘。N年之前我还在追问我是为了什么而努力？追求什么东西？我现在也没有彻底想通，但是至少也排除了一个答案，那就是「为了别人」，至少最大的理由不是「为了别人」：不是为了「给别人看」、也不是为了「服务别人」。「为了别人创作」，好像如同小学生写作文一样，需要调整文中的「真情实感」，未免要在坦诚上打折。

孟德尔的成就，在他死去多年才被“重新发现和理解”。即使生前不受重视，孟德尔却说过：

&gt; 我的科学研究给了我**极大的满足**，而且我相信，**过不了多久**世人将会承认我的研究成果。

这句话我无论读多少遍都觉得感慨。「给了我极大的满足」。

类似的，梁任公说：

&gt; 我生平最受用的有两句话：一是“责任心”，二是“**趣味**”。

我想，分享探索中的趣味，对自身的满足，才应是第一性的精神动力。而对于blog这种具有潜在公开性的东西，还应有责任心，确保写出的东西自己基本满意，至少对自己有意义。即使不可能做到，也应尽力追求。


        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        Arduino和linux串口通信
        
        </title>
        <url>////nth233.top/posts/2021-04-14-Arduino和linux串口通信.html</url>
        <search-text>
        
        
            arduino
        
            串口
        
            posix
        
            linux
        
        
        
        手头有一块（伪）Arduino Uno，现在需要把上面测到的电压数据发送到电脑上了。我知道Arduino官方提供了`Serial.write`和`Serial.read`，利用这些函数可以方便地通过串口发数据给电脑，在Arduino IDE提供的串口监视器上显示出来。但我现在需要自己处理数据，需要让Arduino直接和我的程序通信。对此我毫无头绪。一番搜索尝试之后算是找到了办法。
        
        
        
## 前因

手头有一块（伪）Arduino Uno，现在需要把上面测到的电压数据发送到电脑上了。我知道Arduino官方提供了`Serial.write`和`Serial.read`，利用这些函数可以方便地通过串口发数据给电脑，在Arduino IDE提供的串口监视器上显示出来。但我现在需要自己处理数据，需要让Arduino直接和我的程序通信。对此我毫无头绪。一番搜索尝试之后算是找到了办法。

## 线

我的Arduino UNO和计算机连接的依赖一根USB线，一头是type-B，一头是type-A，通过这个USB提供了虚拟串口，可以假想Arduino和计算机用一条RS-232串行总线连接起来了。利用这个串口，Arduino就可以和计算机通信。

连接到计算机的Arduino被linux包装成一个文件，我这里是`/dev/ttyACM0`，只要对这个文件进行响应的读写，就可以实现通信。但是毕竟串口和硬盘上的文件本质上不同，还是得通过系统对其进行终端控制。linux提供了`termios.h`，里面用一个结构体保存了终端控制的各种属性，属于POSIX标准。很多东西看起来是上一个时代的遗存，从UNIX和电传打字机的时代一直继承到了现在。

## `struct termio`

### 结构体内容

`struct termio`里面保存了终端的各种属性。

1. `c_iflag` 设置输入模式，比如要不要流量控制、要不要对输入字节进行特殊处理
2. `c_oflag` 设置输出模式，比如要不要对输出字节进行特殊处理
3. `c_cflag` 设置控制模式，比如一个字节多宽，有没有奇偶校验位，有几个终止位，要不要进行载波检测，要不要读数据
4. `c_lflag` 设置局部模式（我也不知道为什么叫Local Mode），比如要不要回传、要不要使用标准模式（Canonical Mode，似乎是一行一行读）
5. `c_cc` 一个数组，包含一些特殊设置，比如一次最少读几个字符

前面几个flag都是通过位运算进行控制的，把对应的位设为1则启用，否则禁用。

上面一些设置似乎只和以前的调制解调器有关，比如流量控制、载波监听什么的，对于我们和Arduino通信来说是没什么用的，我们不需要操作系统对我们的数据做太多的处理，因此使用的时候需要禁用掉大多数配置。

对于`c_cc`数组，里面`c_cc[VMIN]`表示一次读写几个字符，如果没有读到这么多字符，`read`系统调用（前面写了，串口在linux看来是个文件）就会一直阻塞，直到超时为止，最大位255（毕竟无符号的8位能表示的最大整数不过如此）。`c_cc[VTIME]`保存了超时信息（timeout），也就是多久算超时，单位是十分秒（0.1秒，decisecond）。

### 具体的配置

参考网上的资料，对于`c_cflag`，禁用`PARENB`、`CSTOPB`，意思是禁用奇偶校验，只用一个停止位。启用`CS8`、`CREAD`和`CLOCAL`，字节8位长（现在真的还有什么设备字节长度不是8位吗？），可以读写。对于`c_lflag`，禁用`ICANON`、`ECHO`、`ECHOE`、`ECHONL`、`ISIG`，禁用标准模式、任何回传、信号字节。对于`c_iflag`，禁用`IXOFF`、`IXON`、`IXANY`，不要流量控制；禁用`IGNBRK`、`BRKINT`、`PARMRK`、`ISTRIP`、`INLCR`、`IGNCR`、`ICRNL`，我们要原始数据，不要特殊处理。对于`c_oflag`，禁用`OPOST`、`ONLCR`，不要特殊处理。

我这里`VMIN`设置为2，因为我配置了我的Arduino一次发送两个字节。VTIME我随便设置了一个值。

波特率也需要设置。使用`cfsetispeed`和`cfsetospeed`可以分别设置读写的波特率。我这里全部设为9600Hz，也就是B9600。

在看了Qt的`QSerialPort`和rust的`serialport` crate之后，我发现还是操作系统提供的接口最为详细完备。

### 总体大致流程

先`open`对应的文件（我这里是`/dev/ttyACM0`），然后利用`tcgetattr`获得终端控制的结构体，对其进行设置，接下来就和普通的文件一样，可以从里面`read`数据了。最后再关闭文件。

## C程序

```c
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;

#include &lt;fcntl.h&gt;
#include &lt;errno.h&gt;
#include &lt;termios.h&gt;
#include &lt;unistd.h&gt;

// handle memory in different ways
// convert two char into a uint16_t
union Convert {
    char buffer[2];
    uint16_t num;
};

int main() {
    int serial_port = open(&quot;/dev/ttyACM0&quot;, O_RDWR);
    if(serial_port &lt; 0) {
        printf(&quot;Error %i from open: %s\n&quot;, errno, strerror(errno));
        exit(0);
    }
    struct termios tty;
    if(tcgetattr(serial_port, &amp;tty) != 0) {
        printf(&quot;Error %i from tcgetattr: %s\n&quot;, errno, strerror(errno));
    }
    tty.c_cflag &amp;= ~PARENB;
    tty.c_cflag &amp;= ~CSTOPB;
    tty.c_cflag |= CS8;
    tty.c_cflag |= CREAD | CLOCAL;
    tty.c_lflag &amp;= ~ICANON;
    tty.c_lflag &amp;= ~ECHO;
    tty.c_lflag &amp;= ~ECHOE;
    tty.c_lflag &amp;= ~ECHONL;
    tty.c_lflag &amp;= ~ISIG;
    tty.c_iflag &amp;= ~(IXON | IXOFF | IXANY);
    tty.c_iflag &amp;= ~(IGNBRK|BRKINT|PARMRK|ISTRIP|INLCR|IGNCR|ICRNL);
    tty.c_oflag &amp;= ~OPOST;
    tty.c_oflag &amp;= ~ONLCR;
    tty.c_cc[VTIME] = 20;
    tty.c_cc[VMIN] = 2;
    cfsetispeed(&amp;tty, B9600);
    cfsetospeed(&amp;tty, B9600);
    char read_buf[20]; // buffer to use
    union Convert temp;
    while(1) {
        int n = read(serial_port, &amp;read_buf, sizeof(read_buf));
        // ! should handle error here
        // but in my case, error rarely arises
        temp.buffer[0] = read_buf[0];
        temp.buffer[1] = read_buf[1];
        printf(&quot;%x\n&quot;, (int)temp.num);
    }
    close(serial_port);
}
```

Arduino方面程序如下。这里要注意，不要用`Serial.println`，Arduino的库会因此在后面加上`\r\n`。

```c
union Convert {
  char buffer[2];
  uint16_t num;
};

void setup() {
  Serial.begin(9600);
}
 
void loop() {
  delay(5);
  Convert temp;
  temp.num = analogRead(A0);
  Serial.write(temp.buffer, 2);
}
```

经测最终是可以读到数据的，而且速度很快，不会出现速度不匹配的问题。

## 其他方法

我还尝试使用了Qt的`QSerialPort`来读串口，那个用起来比直接调POSIX接口简单多了。但是不知道为什么，有的时候只读了一个字节，有的时候按我要求读了两个字节，但是高字节和低字节反了。用法可以参考Qt文档。

rust有个crate，`serialport`，也很不错，对底层的操作进行了封装。我最终的程序就是用了这个crate。（因为rust有很方便的线程库，写起来没有C语言这么累人）

## 参考资料

没有这些参考资料我真的写不出这个程序。

1. [Serial Programming Guide for POSIX Operating Systems](https://www.cmrr.umn.edu/~strupp/serial.html#CONTENTS)
2. [Linux Serial Ports Using C/C++](https://blog.mbedded.ninja/programming/operating-systems/linux/linux-serial-ports-using-c-cpp/)
3. [termios(3) - Linux man page](https://linux.die.net/man/3/termios)
4. [Computer terminal - Wikipedia](https://en.wikipedia.org/wiki/Computer_terminal#:~:text=A%20computer%20terminal%20is%20an,a%20computer%20screen%20by%20decades.)
5. [Crate serialport](https://docs.rs/serialport/4.0.1/serialport/)
6. [QSerialPort Class](https://doc.qt.io/qt-5/qserialport.html)dui

        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        解金字塔魔方
        
        </title>
        <url>////nth233.top/posts/2021-04-04-解金字塔魔方.html</url>
        <search-text>
        
        
            瞎写
        
            魔方
        
        
        
        班长来串寝，带来两个魔方，跟我另一个玩魔方的舍友讨论得热烈。他们给了我一个「简单」的三阶金字塔，并说「你拼好一个面他就还原了，拼不好就再拼，总是会还原的」。我的魔方水平限于三阶还原一个面，听他们这么说便尝试了一下，结果费了好大劲才拼出一个面。但慢慢我找到一点技巧，算是摸到了三阶金字塔的门槛。
        
        
        


&gt; 不懂魔方。本文推出的方法可能很慢很蠢，实测速度还不如暴力。不过毕竟是自己推出来的，还是记录一下。

班长来串寝，带来两个魔方，跟我另一个玩魔方的舍友讨论得热烈。他们给了我一个「简单」的三阶金字塔，并说「你拼好一个面他就还原了，拼不好就再拼，总是会还原的」。

我的魔方水平限于三阶还原一个面，听他们这么说便尝试了一下，结果费了好大劲才拼出一个面。但慢慢我找到一点技巧，算是摸到了三阶金字塔的门槛。

## 定义

首先定义三种块：

1. 有三个面的为角块（A）
2. 有两个面的为棱块（B）
3. 只有一个面的为中心块（C）

![三种块](/assets/img/post/cube1.png)

## 简单的预处理

当晚，我得到一个「准基本操作」，还原一个面：

1. 把角块（A）还原（找到有相同颜色面的三个角，把同色的面转到一个平面上）
2. 把中心块（B）还原（中心块是和角块相邻的块，一开始我甚至不知道这点）（转动角块下面的那一层，相邻的中心块还原）
3. 把其余的棱块凑上去

到这个时候，还原其他三个面的角块和中心块是分分钟的事情了。

将上面两步结合起来，就得到了「预处理」操作：

1. 还原所有角块和中心块
2. 还原一个面
3. 把还原好的面变成底面

预处理后，我们称红色中心块和角块所在的面为「红面」，其他面以此类推。

其实预处理之后，暴力破解已经很容易了。不过我不满足于此，因为我不知道为什么能还原……经常是转着转着莫名其妙就还原了。到了第二天的操作系统课我还是在乱转。

## 预处理后还有什么需要还原？

回去后我发现，预处理后就只剩下棱块的排列和方向的问题了。

### 排列问题的解决

所谓「排列问题」，指两个棱块位置互换了，比如红蓝交界的棱块和红绿交界的棱块互换位置；所谓「方向问题」，指棱块的位置对了，但方向不对，比如，红蓝棱块位于红蓝面交界上，但是棱块的红面在魔方的蓝面上，棱块的蓝面在魔方的红面上。

我发现不可能出现只有一个棱块方向错误的情况（不过我没有证明）。解决了棱块的排列问题和方向问题，金字塔魔方的还原就解决了。

然而怎么解决这几个问题呢？我起初毫无头绪，只是在瞎转魔方找感觉，感觉得找到几个基本操作才行。一开始我找的基本操作是「转顶部角块」、「顶部角块和其下层」、「翻转整个魔方，换一个面做正面」。然而这几个操作太过于基本，虽然确实可以构成所有操作，但是对于实践没有什么指导意义，用这几个基本操作来思考，可以说是寸步难行，试了一个小时都没有头绪。不过过程中我发现了解决方向问题的一个方法，下面再表述。

#### 四个基本操作

后来我观察我还原一个面的过程，发现有一个操作至关重要，这个操作可以使一个面的三个棱块互换。这个操作我起初只知道怎么做，但不知道应该怎么表述（用上面那三个基本操作来表述就太过繁琐了）。大概是一个面转一下，接过另一个面的棱块，再转回去。后来我发现用角块和其相邻层的旋转作为基本操作比较简便。四个基本操作定义如下图。

![基本操作](/assets/img/post/cube2.png)

从四个基本操作出发，可以很好地表述四种面上的三轮换。起初我只找到了下面的$\alpha$，并绞尽脑汁想$\alpha$怎么用，但是都徒劳。直到我用纸笔描述了一下，顺藤摸瓜找到其他三个。我称下面为四个「面三轮换」操作。

1. $\alpha = p^{-1}kpk^{-1}$，效果是右面的三个棱块顺时针轮换（从右往左看）
2. $\beta = p^{-1}ipi^{-1}$，效果是左面的三个棱块逆时针轮换（从左往右看）
3. $\gamma = i^{-1}kik^{-1}$，效果是正面的三个棱块逆时针轮换（从前往后看）
4. $\delta = p^{-1}jpj^{-1}$，效果是底面三个棱块逆时针轮换（从下往上看）

对棱块进行命名和编号，如图。

![棱块命名](/assets/img/post/cube3.png)

上左、上右、上后、下左、下右、下前分别标为1到6。于是四种操作的效果如下图。

![四种面三轮换](/assets/img/post/cube4.png)

根据排列的知识和上面的标号，我发现排列问题已经被解决了。当我们完成预处理后，实际上只剩三个上棱块需要还原，由于只有三个棱块，因此，无非只有三种情况：

1. 三个块位置都正确
2. 三个块位置都不正确（轮换）
3. 一个块位置正确，另外两个块互换

对于2、3情况，如果情况是可还原的，就一定可以利用几个面三轮换操作还原。如果以排列的方式表述这个问题，无非如下：

利用排列，可表述四个面三轮换。

$$
\alpha = \begin{pmatrix}1 &amp; 2 &amp; 3 &amp;4 &amp; 5 &amp; 6 \\ 1 &amp; 5 &amp; 2 &amp; 4 &amp; 3 &amp; 6\end{pmatrix}
$$

$$
\beta = \begin{pmatrix}1 &amp; 2 &amp; 3 &amp;4 &amp; 5 &amp; 6 \\ 3 &amp; 1 &amp; 4 &amp; 1 &amp; 5 &amp; 6\end{pmatrix}
$$

$$
\gamma = \begin{pmatrix}1 &amp; 2 &amp; 3 &amp;4 &amp; 5 &amp; 6 \\ 6 &amp; 1 &amp; 3 &amp; 4 &amp; 5 &amp; 2\end{pmatrix}
$$

$$
\delta = \begin{pmatrix}1 &amp; 2 &amp; 3 &amp;4 &amp; 5 &amp; 6 \\ 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6\end{pmatrix}
$$

对于情况2，我们只需用上面四者合成$\omega$即可，称$\omega$为「角三轮换」：

$$
\omega = \begin{pmatrix}1 &amp; 2 &amp; 3 &amp;4 &amp; 5 &amp; 6 \\ 2 &amp; 3 &amp; 1 &amp; 4 &amp; 5 &amp; 6\end{pmatrix}
$$

对于情况3，我们只需用上面四者合成$\sigma$即可，称$\sigma$为「棱块对换」：

$$
\sigma = \begin{pmatrix}1 &amp; 2 &amp; 3 &amp;4 &amp; 5 &amp; 6 \\ 2 &amp; 1 &amp; 3 &amp; 4 &amp; 5 &amp; 6\end{pmatrix}
$$

#### 求解推公式

那么如何求解呢？我选择使用程序枚举。

程序如下：

```cpp
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;utility&gt;
#include &lt;string&gt;

using namespace std;

void print_arr(int arr[6]) {
    for(int i = 0;i &lt; 6;++i) {
        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
}

struct Arrangement {
    Arrangement(const initializer_list&lt;int&gt; l, string name = &quot;&quot;) : name(name) {
        int i = 0;
        for(auto item : l) {
            arrange[i] = item - 1;
            ++i;
        }
    }
    Arrangement(const Arrangement &amp;arr) : name(arr.name) {
        for(int i = 0;i &lt; 6;++i) {
            arrange[i] = arr.arrange[i];
        }
    }
    Arrangement(int arr[6], string name = &quot;&quot;) : name(name) {
        for(int i = 0;i &lt; 6;++i) {
            arrange[i] = arr[i];
        }
    }
    int arrange[6];
    std::string name;
    void apply(int array[6]) const {
        int temp[6];
        for(int i = 0;i &lt; 6;++i) {
            temp[arrange[i]] = array[i];
        }
        for(int i = 0;i &lt; 6;++i) {
            array[i] = temp[i];
        }
    }
    void print() const {
        cout &lt;&lt; &quot;Arrangement &quot; &lt;&lt; name &lt;&lt; &quot; : (&quot; &lt;&lt; endl;
        int temp[6] = {1, 2, 3, 4, 5, 6};
        print_arr(temp);
        apply(temp);
        print_arr(temp);
        cout &lt;&lt; &quot;)&quot; &lt;&lt; endl;
    }
    bool operator&lt;(const Arrangement &amp;b) const {
        for(int i = 0;i &lt; 6;++i) {
            if(arrange[i] &lt; b.arrange[i]) {
                return true;
            }
            else if(arrange[i] &gt; b.arrange[i]) {
                return false;
            }
            else {
                continue;
            }
        }
        return false;
    }
    bool operator==(const Arrangement &amp;b) const {
        for(int i = 0;i &lt; 6;++i) {
            if(arrange[i] != b.arrange[i]) {
                return false;
            }
        }
        return true;
    }
    Arrangement operator*(const Arrangement &amp;b) const {
        int temp[6];
        for(int i = 0;i &lt; 6;++i) {
            temp[i] = b.arrange[arrange[i]];
        }
        return Arrangement(temp, name + b.name);
    }
};

Arrangement alpha{1, 3, 5, 4, 2, 6}, beta{4, 2, 1, 3, 5, 6}, gamma{2, 6, 3, 4, 5, 1}, delta{1, 2, 3, 6, 4, 5};
std::set&lt;Arrangement&gt; s;

void enumarate_all() {
    int new_size = 0;
    while(true) {
        std::set&lt;Arrangement&gt; new_set;
        for(auto a : s) {
            for(auto b : s) {
                auto temp = a*b;
                if(s.find(temp) == s.end()) {
                    cout &lt;&lt; &quot;find new OP&quot; &lt;&lt; endl;
                    a.print();
                    cout &lt;&lt; &quot;and&quot; &lt;&lt; endl;
                    b.print();
                    cout &lt;&lt; &quot;forms&quot; &lt;&lt; endl;
                    temp.print();
                    cout &lt;&lt; endl;
                    new_set.emplace(temp);
                }
            }
        }
        new_size = new_set.size();
        if(new_size == 0) {
            break;
        }
        new_size = 0;
        for(auto n : new_set) {
            s.emplace(n);
        }
    }
    cout &lt;&lt; &quot;total: &quot; &lt;&lt; s.size() &lt;&lt; endl;
}

int main() {
    alpha.name = &quot;α&quot;;
    beta.name = &quot;β&quot;;
    gamma.name = &quot;γ&quot;;
    delta.name = &quot;δ&quot;;
    alpha.print();
    beta.print();
    gamma.print();
    delta.print();
    // (alpha * beta).print();
    s.emplace(alpha);
    s.emplace(beta);
    s.emplace(gamma);
    s.emplace(delta);
    enumarate_all();
    return 0;
}
```

程序会输出四个面三轮换组成的所有排列。果然，我在输出中找到了$\omega$和$\omega^{-1}$

```
Arrangement δαγβα : (
1 2 3 4 5 6 
2 3 1 4 5 6 
)
Arrangement δαδδγ : (
1 2 3 4 5 6 
3 1 2 4 5 6 
)
```

由于$\omega^{-1}$看起来更简单，所以我偏爱后者。这就能够解决角三轮换的问题。不过我没有找到棱对换的排列，说明这种现象对于正确的魔方是不可能存在的，实践中确实也没有碰到。至此排列问题解决。

### 方向问题

关于方向问题，我发现我可以同时调换两个块的方向，操作如下，我称为「二倒向」。

$$
s = p^{-1}kpk^{-1}\cdot pj^{-1}p^{-1}j
$$

这个操作把上左和下左两个棱块的方向同时翻转。原理大概是用一次三轮换，把下右、上右、上后轮换一下，再把刚刚从底面换上来的块换回底面，不过执行的「手性」和和刚刚不同。（注意到$\alpha$是轮换右面的三个块，可以有一个**镜像**的操作轮换左面的三个块，这里执行$\alpha$后执行的操作大概是$\delta$的镜像，所以说二者手性不同）。至此方向问题解决（奇数个棱块方向不同是不可能的）。

## 完整的方法

最后，一套方法开发出来了，经测可用。但是……不比暴力快。

1. 预处理
2. 若三个上棱块没有归位，那么就用「角三轮换」使之归位
3. 所有块归位后，若存在方向问题，那么用「二倒向」使之取向正确

        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        最大流
        
        </title>
        <url>////nth233.top/posts/2020-10-22-最大流.html</url>
        <search-text>
        
        
            算法
        
        
        
        关于最大流的笔记
        
        
        
## 一些定义

1. 流网络：有向图，没有反向平行边，源点$s$和汇点$t$分别只有一个

2. 流：一个实值函数$f: V\times V \rightarrow \mathbb{R}$，并且满足以下两条性质：

    1. 容量限制：$0 \le f(u, v) \le c(u, v)$
    2. 流量守恒：$\sum_{v\in V}f(u, v) = \sum_{v\in v}f(v,u)$

    最大流问题中，我们想找到最大的$f(s,t)$

## 两个简单的推广

1. 如果有反向平行边呢？

    很简单，本来是`u-&gt;v, v-&gt;u`，现在添加一个结点`u&#39;`，把图转化为`u-&gt;v, v-&gt;u&#39;, u&#39;-&gt;u`，就去掉了反向平行边

2. 如果有多个源和汇呢？

    也不难，添加一个超级源和超级汇，从其出发的有向边指向真实的源点，并且容量无限大；汇点同理。

## Ford-Fulkerson方法的准备

1. 残存网络$G_f$：给原图添加反向平行边，其容量和正向边的流一样大。原图的正向边容量改为其原容量与流的差（如果为算出新的容量为0，那么就认为这个边不存在），这样一操作，得到的就是所谓的残存网络$G_f$。

    更正式地：

    $$
    c_f(u, v) = \begin{cases}
    c(u, v) - f(u, v) &amp; (u,v)\in E \\
    f(u, v) &amp; (v,u)\in E \\
    0 &amp; \text{Otherwise}
    \end{cases}
    $$

    反向边的存在使得我们在需要的时候可以反向推流，也就是所谓**抵消操作**，来达到全局最优解。

2. 增广路径：残存网络中从源点到汇点的一条简单路径。易知

    $$
    \displaystyle c_f(p) = \min_{(u,v)\in p}c_f(u, v)
    $$
    
3. 找到一条增广路径，我们据此增加原图中的流，然后再更新残存网络$G_f$。这作为一次增广操作。

4. 流网络的切割：将网络的结点分为两个集合$S$和$T$，其中$s \in S$且$t\in T$，并且$S + T = V$（此式蕴含了$S$、$T$不相交）

5. 横跨切割的净流量：连接$S$、$T$的边的流量的和。（如果是反流回来的，那么要加个负号）

6. 切割的容量：连接$S$、$T$的边的容量和

根据上面的定义，可以推得**最大流最小割**定理，也就是最大流的大小和最小的切割容量相等。更具体地，下面三个结论等价：

1. $f$是$G$的最大流
2. $G_f$没有增广路径
3. $\vert f\vert = c(S, T)$

## Ford-Fulkerson方法

简单来说：一直增广，直到无法增广，最终得到的就是最大流，同时也是最小割。

算法的正确性可以通过最大流最小割定理直接得出。算法的复杂度分析在此略去。

### Edmonds-Karp算法

简单来说，每次沿着最短路增广。也就是使用广度优先搜索增广。

算法的正确性是显然的。时间复杂度为$O(VE^2)$，不过我感觉这个上界很松。

关于时间复杂度的分析这里暂时略过，以后再填坑。

&gt;  EK算法虽非最优，但已足以对付绝大多数情况。

### Dinic算法

比EK算法多了一点点东西，并不很复杂。算法分成两个阶段：

1.  BFS分层：一个结点的层树是其到$s$的最短距离
2. DFS增广。增广有条件，每次只找比当前结点高度函数多1的结点进行增广，确保增广路最短

复杂度$O(V^2E)$

#### 两个优化

1. 多路增广：找到一条增广路之后，如果增广容量没有用尽，那么利用残余容量再找一条增广路
2. 当前弧优化：如果一条边已经被增广过，那么就不必对其增广第二次。

## Push-Relabel方法

1. 预流：与普通的流相比，允许结点「存储」一定的流。如果对于一个结点，其流入的流比流出的流多，则称该结点**溢出**。（如果没有结点溢出，那么预流就是流。）

2. 高度函数$h(v)$：$h: V \to \mathbb{N}$，满足

    1. $h(s) = \vert V\vert$
    2. $h(t) = 0$
    3. $\forall(u,v)\in E_f, h(u) \le h(v) + 1$

    高度还是就是push-relabel方法需要一直维护的量。

3. 两个基本操作

    1. Push：如果结点$u$溢出，则将**超额流**推送到$u$的邻接结点（$h(u) = h(v) + 1$且$c(u,v)-f(u,v)\gt 0$）
    2. Relabel：如果结点$u$溢出，且$h(u) \le h(v)$，则将$h(u)$更新为$\displaystyle \min_{(u,v)\in E}h(v) + 1$

&gt; Push-relabel方法正确性的证明，关键在于充分利用高度函数$h$的性质。以及残存网络与流网络的关系。

### 通用预流推进算法

有了上面的准备，便可以引入push-relabel方法（通用预流推进算法）

1. 初始化
    $$
    f(u,v) = \begin{cases}c(u, v) &amp; u = s\\ 0 &amp; u\ne s\end{cases}
    $$

    $$
    h(u) = \begin{cases}\vert V\vert &amp; u = s \\ 0 &amp; u \ne s\end{cases}
    $$

2. 选择结点进行Push和Relabel，直到所有结点都不溢出为止。

### HLPP算法（最高标号预流推进算法）

1. 初始化
2. 选择溢出结点高度最高的结点，并对其进行Push
3. 如果仍然溢出，则relabel，回到步骤2
4. 如果没有溢出结点，算法结束

复杂度$O(V^2\sqrt{E})$

### 两个优化

1. BFS优化：初始化$h(u)$为$u$到$t$的最短距离
2. GAP优化：如果$h(u)=t$的结点个数为0，那么$h(u) \lt t$的结点永远无法推送超额流到$t$。因此，就将超额流送回$s$。（将高度变成$n+1$，以尽快推回$s$。


        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        猫
        
        </title>
        <url>////nth233.top/posts/2020-10-13-emm.html</url>
        <search-text>
        
        
            草稿
        
        
        
        
        


我是一只猫，名字嘛，还没有。按照惯例，现在应该阐明我的来历，然而关于我初生时的种种事情，我一无所知；关于我怎么来到这个学堂，我也只记得一片朦胧：我只记得我在跑，在跳，翻过重重障碍，不怎么地到了这里。也许我那时正好感到困倦，便也就歇在这里了。

不过有一点事实倒是很确定的：我到这里后没多久，一次正在墙边歇息，草丛中突然闪出一只敏捷的同类。尽管很累，出于礼貌，我还是站了起来。

“你是什么猫？”

“没有名字。”

“你从哪里来？”

“不记得了。”

“你要去哪里？还是说你要留下来”

“不知道。先留下来吧。”

我很累了，不想交谈，于是免去了低效又耗能的编造，直接说出了尴尬的实情。好在对面并不十分惊讶，只是冷漠地应了一声，便又离开了。于是我又趴下了。

这便是我脑中最早的清晰记忆。

我也忘了我为什么没有离开，像来时那样跑出去，但不管怎么说，留下来的生活并不坏。这里安全又静谧，偶有人类进出，没有恶狗，不构成打扰。食物也不是问题：中部有座老楼，红砖砌成，中间一颗红星。楼后有很多水缸，里面不知为何竟养着鱼，闲来无事，钩出几条，聊可饱腹。若嫌麻烦，到旁边的某个后厨，一进一出，三餐俱备。再不行，效法夷齐，啃啃草，虽不美味，但也不失为下策。

但是这般宁静的完美生活没几天就被打破了。那时我正趴在草地上，半睡半醒之间，突然有阵铃声把我惊醒。我从未听过这样惊骇的声音。睡也不用睡了，赶紧跑，但我却怎么跑也跑不出去，跑了很远，声音却也不见减小，仿佛声源就是空气本身。终于声音自己停了。

“这是上课铃。”

不知什么时候竟然有只同类在我身后，那是一只老白猫，一动不动地站在后面，仿佛没有听到铃声。对比我惊慌失措、四腿发抖的样子，他镇静得仿佛是个雕塑。

我本想无视他，但转念一想，似乎对方并无恶意，“来而不往，非礼也”。于是转头，往那个“雕塑”靠近。

“新来的。“

我表示肯定。

“怎么称呼？”

我表示不知。

“我是老白，人类取的名。我在这里……”

于是老白开始了他的自述。这只老白猫在这里待了很久，开始是从隔壁的“市政府”迁过来的，最近偶尔也回去看看。他滔滔不绝地反刍各种记忆，就像一个寂寞老者。我对他又平凡又冗长的经历不感兴趣。但他的自述也顺带夹杂着一些关于这里的信息，他顺带解释了所谓上课铃的周期，此处的布局。种种原因，加上对老者的尊重，我最终还是表现得兴奋、感兴趣。

“噢，这样啊。所以这是个学堂，那些长得一模一样的人是学生。”刚才老白提到了这里，我于是追问了起来。”

“是啊，据说是个好高中呐。你不要看他们千人一面，在他们自己的眼里看来可是各不相同，或许还为这种高度同质化的所谓“多样性”沾沾自喜。我之前就……”

我自动忽略了他后面的话。但仿佛他话还没说完，旁边就有人帮我打断了他的话。

“你非人，安知人不同？”

刚才老白说那个地方是图书馆，这只猫就是从图书馆走来的。然而这只图书馆猫的插话没被搭理，于是他自觉无趣，默默离开。

又是一声上课铃，老白戛然而止，似乎有事要办，于是离开了。

---

我虽享受楼后草地的这种静谧，但是在宁静的环境中待久了，毕竟也无聊，因此我终于开始熟悉这片校园了。

在铃声的规制下，我渐渐有了一套日常散步路线。第一节课，去操场抓蝴蝶。第二节课，解决温饱问题。之后则在图书馆附近逛逛。下午呢，哪里人少我去哪里，通常来说还是在草地上待着，从楼间的缝看云从东边来，从西边来，从南边来，从北边来，从四方来。

这种生活我十分享受，若说我live like a king，那不恰当，因为国王不可能有这么自由的生活；相反，应该说as free as air，只有空气和我，有这般的轻盈和自由。

然而一天有还是六个时间段不太舒服，那就是那群穿一模一样的人上下学的时间、以及这群人聚集在操场做古怪动作的时段。有的猫专挑这个时段去讨好人类，在人类面前一副媚态，这种轻浮的行径，为我这种君子不齿。当然嘈杂和聒噪对我也并非完全没有好处，我并不像图书馆猫那么守静恶动，从这乱声之中，我偶尔还是能提取出一点有意思的谈话的。我这次照例又在灌木丛中做着提炼工作。

“我的奶茶券要过期了，今天得赶紧用掉。”

她们在讨论吃喝，好像每天都要品尝各种糖水。

“诶，刚好今天又出了个新品，好像是乌龙咖啡什么的……”

我并不了解糖水的种类，但听名字就觉得是外星生物才会喝的饮料，今天似乎并没有什么有趣的事情。我转身欲走，但这灌木丛空间狭小，转身困难。我好不容易转了身，不料尾巴自己却突出了灌木丛。我立刻把尾巴收回，却已经晚了，那两个三句不离吃喝的女学生已经够到了我的尾巴。

要是在平常，我无论如何也得挣脱。但是这次的灌木丛实在太狭小，不易出去，我只好倒着出来。出于礼貌，我又只好破例接受人类的“抚摸”。从头撸到身子几次，总算结束了。其中一个人掏出一个火腿肠往我嘴巴这送来。如此诚意，我也不好拒绝，只好啃啃。

火腿味道还不赖。

“这么喜欢火腿，你不如就叫‘火腿’吧。”

？？？我怎么就喜欢火腿了。而且为什么喜欢火腿就一定要叫火腿。按照这个逻辑，你就应该改名叫奶茶，另一个人改名叫乌龙咖啡。我很愤怒，奶茶和乌龙咖啡居然把我和吊在菜市场里、摆在商场冰箱里卖的东西相提并论。不过我还是忍住了，若不是在吃火腿，我那时或许早就跑开了。

“它摇头了，火腿好像不喜欢这个名字。”乌龙咖啡这样说到。

然而我摇头只是无心之举，这个动作本身并没有任何的含义，何况是我摇头，不是火腿摇头。人类总是喜欢这样牵强附会。好在这次她猜中了，我暂且不追究责任。

勉强也已算是个巧合，就在我把火腿吃完的那一刻，一阵再正常不过的微风吹过。

“那就叫‘清风’吧。”奶茶突然给我换了个名字。

说罢又抓了几下我的头。这个名字不坏，看在人类关照的份上，我勉强接受。此二人又撸了撸我顺滑的毛之后，总算是走了。

“清风”的名字，渐渐地也传开了。我本不希望旁者这样叫我，但毕竟是人类取的名字，在老白等人眼中似乎等于我的唯一正名。我也不知道为什么名字要由人类取，但旁人既然这样叫，我不得不接受。

于是，就这样莫名其妙地，我被迫成了有名字的猫。

---

夏秋之际，白天的炎热未退，傍晚的温度却已经渐渐减退，空气渐渐干燥，秋风也吹起来了。不过在我们这个地方，天气的这点微妙变化并不能使人与猫的生活方式作出多大改变，绿叶还是绿叶，蓝天还是蓝天，吃饭还是吃饭，空调还是从7点轰鸣到22点，住宿生的小灯有时照样开过12点。

最近几天老白来得少了，事情很少，只好到处散步。而且猫和人一样，越闲，作息越不规律。我闲下来了，定时散步的优良传统就被混沌散步所取代，就像房间从整齐变得混乱、厕所水龙头从好到坏一样自然。

我最近倒是常常去图书馆附近走，那里不像教学楼那么嘈杂，空气中都弥漫着清闲、冷淡的味道，就像图书馆的那只猫。每次到这里来，都看到那几个图书管理员在练字，不紧不慢。桌子旁边叠着某些新到的书等着上架。

“听说那个新校区


        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        概率论数理统计复习笔记
        
        </title>
        <url>////nth233.top/notes/概率论复习笔记.html</url>
        <search-text>
        
        
            math
        
            概率论
        
            数理统计
        
        
        
        陈年概率论笔记
        
        
        
&gt; 很久之前的概率论数理统计笔记，如今为了复习而放上来。也许会有大量错漏（就像我的其他blog一样），但我也懒得逐一校对纠正了。

## Part 1 概率论

### 随机事件和概率

&gt; 随机事件才有概率
&gt; 

#### 基本概念

1. 基本事件、样本点

2. 事件的关系（包含、互斥、相容、对立、相等、独立）

3. 事件的运算（和、积、差）

   &gt; $A-B = A\overline B$

4. 概率的统计定义和公理化定义
   1. 统计定义：从频率出发，实验次数越多，频率越接近概率

   2. 公理化定义：设$E$是一次随机试验，那么对$E$的所有事件赋予一个实数，满足

      1. 非负性
      2. 归一性
      3. 可列可加性

      那么$P(A)$为概率

5. 概率运算的性质

   1. 对立事件和概率为1

   2. 包含关系蕴含着概率大小关系

   3. 概率加法公式：$P(A+B) = P(A) + P(B) - P(A \cap B)$

      &gt; 可列个事件的加法公式

   4. 概率减法公式：$P(A-B) =P(A) - P(A\cap B)$

6. 条件概率：$P(B|A) = \frac{P(AB)}{P(A)}$，在$A$发生的条件下，$B$发生的概率

7. 完备事件组，样本空间的划分

8. 条件概率运算的性质：参考前面概率的性质，只是后面多加一个条件

9. **条件概率相关公式**

   1. 乘法公式：$P(AB) = P(A)P(B|A)$

      &gt; 乘法公式意味着两个事件同时发生，与分别先后发成（如果对顺序没有要求）是等价的

   2. 全概率公式：$P(A) = \sum P(A|B_i)$，$B_1, B_2, \dots ,B_n$是一个划分

      &gt; 全概率公式意味着一个事件有多种不同原因
      &gt;
      &gt; 也可以将事件的划分类比线性空间的一个正交基，全概率公式便是把一个事件的概率表示成多个事件的线性组合。

   3. Bayes公式：$P(B_i | A) = \frac{P(B_i)P(A|B_i)}{P(A)}$，当时左边是后验概率，$P(B_k)$为先验概率

      &gt; 贝叶斯公式意味着一种从结果反推原因，获知已知一个结果已经发生，“更新”原因发生的概率。考虑酒桌上的摇色子游戏。考虑检测中的假阳性和假阴性（涉及到后面的假设检验）

10. 随机事件的独立性：$P(AB) = P(A)P(B)$

11. 两事件独立，则他们的对立事件也独立

12. n重Bernoulli实验

#### 例题

1. 拿枪问题（装信封问题）〔条件概率，减法公式（容斥原理）〕
2. 摸奖问题（抓阄问题）〔摸奖与顺序无关〕
3. 集合概型：等车问题〔画图解决〕

#### Pitfalls and Fallacies

1. $A -B = A\overline B$
2. 独立不等于对立
3. 互斥不等于对立
4. 两个事件同时发生，等价于依次发生且不考虑它们的顺序
5. 摸奖和顺序无关

### 随机变量和概率分布

#### 基本概念

1. 随机变量：$f: \Omega \to \mathbb R$，一个随机事件对应一个实数，那么这个实数便是随机变量

   &gt; 这意味着随机变量是一个数，$f$是一种特殊的映射。对于一个数，研究它的性质就比较容易了。

2. 随机变量的分类

   1. 离散型
   2. 其他（包含连续型，也包含各种缝合怪，主要研究连续型）

   &gt; 对于离散性，研究分布律
   &gt;
   &gt; 对于连续型，研究概率密度函数
   &gt;
   &gt; 两者都可以统一为分布函数

3. 分布律

4. 分布函数：$F(x) = P\{X \le x\}$，二维联合分布：$F(x,y) = P\{X\le x, Y \le y\}$

   &gt; 对于离散性，$F(x)$有很多间断点，间断点的跃度表示概率
   &gt;
   &gt; 对于连续型，$F(x)$可导，导函数为分布函数
   
5. 分布函数的性质

    1. 非负
    2. 右连续（**典型区间**决定的）
    3. 递增
    4. 归一

   

6. 概率密度函数的性质

7. 边缘分布：消灭掉一个维度的随机性（在实数上积分）

8. 条件分布

   $$
   P\{X = x_i | Y = y_i\} = \frac{P\{X = x_i, Y = y_i\}}{P\{Y = y_i\}} = \frac{p_{ij}}{p_{\cdot j}}
   $$

   $$
   \lim_{\epsilon \to 0}P\{X \le x |y - \epsilon \lt Y \le y + \epsilon\} = F_{X|Y}(x|y)
   $$

   可证
   
   $$
   f_{X|Y} = \frac{f(x,y)}{f_Y(y)}
   $$

   &gt; 〔不考，但是有趣〕

9. 随机变量的独立：$F(x,y) = F_X(x)F_Y(y)$，$f(x,y) = f_X(x)f_Y(y)$

   &gt; n维随机变量相互独立，定理与二维雷同。不过两两独立不意味着相互独立。

#### 常见分布

1. 一维

    1. 两点分布

    2. 二项分布：$X\sim B(n, p)$

    3. Poisson分布：$P\{X = k\} = \frac{\lambda^k}{k!}e^{-\lambda}$

      &gt; $e^{-\lambda}$为归一化因子，有了它才能归一
      &gt;
      &gt; $X \sim \pi(\lambda)$
      &gt;
      &gt; ［泊松定理］泊松分布和二项分布的关系
      &gt;
      &gt; 若$np_n \to \lambda$，且$n \to \infty$，那么有$\displaystyle\lim_{n\to\infty} C_n^kp^k_nq^{n-k}_n = \frac{\lambda^k}{k!}e^{-\lambda}$
      &gt;
      &gt; 具体实际操作中，$n \ge 10$，且$p \le 0.1$，那么可以用泊松分布计算二项分布
      &gt;
      &gt; ［实际背景］相同间隔内到达的乘客批数，电话总机某段事件内接收到的呼叫次数。（大概就是与连续时间挂钩的“二项分布”，因为每个时刻发生的「概率」相同）

    4. 几何分布：$P\{X = n\} = p^n$

      &gt; ［实际背景］过红绿灯，在第几个红绿灯前停下。

    5. 均匀分布：$X\sim U(a, b)$

    6. 指数分布：$X\sim e(\theta)$，$\displaystyle f(x) = \begin{cases}\frac{1}\theta e^{-\frac{x}{\theta}} &amp; x\ge 0 \\ 0\end{cases}$

      &gt; ［实际背景］寿命

    7. **正态分布**：$X\sim N(\mu, \sigma^2)$

      &gt; ［实际背景］最广泛的分布，比如测量误差
      &gt;
      &gt; 表达式要记：
      &gt;
      &gt; $$
      &gt; f(x) = \frac{1}{\sqrt{2\pi\sigma}}e^{-\frac{(x-\mu)^2}{2\sigma^2}}
      &gt; $$
      &gt;
      &gt; 图形要记，归一化的证明方法要记（积分前先平方，然后化成二元函数）
      &gt;
      &gt; ［归一化］$\frac{X-\mu}{\sigma}$
   
2. 二维

    1. 均匀

    2. 正态：$X\sim N(\mu_1, \mu_2, \sigma_1^2, \sigma_2^2, \rho)$，其中$\rho$为相关系数。两个维度独立/不相关时，$\rho = 0$.

      &gt; 表达式：如果$X \sim N(0,0,1,1,\rho)$
      &gt;
      &gt; $$
      &gt; f(x,y) = \frac{1}{2\pi\sqrt{1-\rho^2}}e^{-\frac{1}{1-\rho^2}[x^2 + y^2 - 2\rho xy]}
      &gt; $$
      &gt;
      &gt; 验证归一，请配方

3. 随机变量函数的概率

    &gt; 谁是谁的谁
    &gt; 找支撑

    1. 离散型：分布律重写
    
    2. 连续型
    
        1. 图像法
        
        2. 公式法（要求$h(x)$为$g(y)$的反函数
        
        $$
        f_Y(y) = \begin{cases} f_X(h(y)|h&#39;(y)| &amp; \alpha \lt y \lt \beta \\ 0 \end{cases}
        $$
    
        3. 分布函数法
      
    3. 二维
       
        &gt; 如何推导？紧扣定义，找支撑。最后积分、利用独立性化简
       
        1. $Z = X + Y$：卷积公式
        
        $$
         \begin{aligned} 
         F_Z(z) = \iint_{x+y \le z} f(x,y)dxdy &amp; =\int_{-\infty}^{+\infty}dy\int_{-\infty}^{z-y}f(x,y)dx \\
         &amp; = \int_R\int^z_{-\infty}f(u-y,y)dudy
         \end{aligned}
        $$
        
         类似可得概率密度函数的公式。如果$X$、$Y$相互独立，最后可以推得卷积公式
         
        $$
         f_X * f_Y = \int_Rf_X(x)f_Y(z-x)dx
        $$
      
        2. $Z = \max(X,Y)$
        
            很简单，就是分布函数相同
        
        3. $Z = \min(X,Y)$
        
            分布函数分别被1减，然后相乘再被1减
        
        4. $Z = XY$
        
        5. $Z = X/Y$


#### 例题

1. 给概率密度函数求分布函数
2. 判断独立性
3. 求边缘
4. 已知独立性求参数

#### Pitfalls and Fallacies

1. 已知分布函数求概率，无论一维二维都需要割，很麻烦
2. 已知边缘不能反求联合，但是如果补充上条件，便可以得到联合
3. $\int_0^{\infty}e^{-x^2}dx = \frac{\sqrt{\pi}}{2}$

### 随机变量的数值特征

&gt; 本章只有一个东西：数学期望

#### 基本概念

1. 数学期望

    1. 离散型：级数$\sum |x_kp_k|$收敛，那么定义$\sum x_kp_k$为$E(X)$
    2. 连续型：$\int |xf_X(x)|dx$收敛，那么定义$\int xf_X(x)dx$为$E(X)$

    &gt; 绝对收敛是为了保证求和不受求和次序的影响

2. 随机变量函数的数学期望

    $Y = g(X)$

    1. 离散型：$E(Y) = E(g(X)) = \sum g(x_k)p_k$
    2. 连续型：$E(Y) = \int g(x)f(x)dx$
    3. 二维：$Z = g(X, Y)$，$E(Z) = \iint_{R^2}g(x, y)f(x,y)dxdy$

3. **数学期望的性质**

    1. $E(C) = C$
    2. 完美的线性：$E(aX+bY) = aE(X) + bE(Y)$
    3. $E(XY) = E(X)E(Y)$，当且仅当二者不相关时（联系协方差）

4. 矩

    1. $k$阶原点矩：$E(X^k)$
    2. $k$阶中心矩：$E((X-\bar X)^k)$

5. 方差：二阶中心矩，$D(X)$，或$\sigma^2$

6. 方差的性质

    1. $D(C) = 0$
    2. $D(X\pm C) = D(X)$
    3. $D(CX) = C^2D(X)$
    4. $D(X_1 + X_2) = D(X_1) + D(X_2)$，当且仅当二者不相关
    5. 与期望：$D(X) = E(X^2) - E(X)^2$

    &gt; 第五点根据定义可以证明。

7. 协方差：$\mathrm{Cov}(X,Y) = E[(X-\bar X)E(Y - \bar Y)]$

8. 协方差的性质

    1. 交换
    2. 双线性
    3. 与期望的关系：$E(XY) - E(X)E(Y) = \mathrm{Cov}(X, Y)$
    4. 与方差的关系：$D(X \pm Y) = D(X) + D(Y) \pm 2\mathrm{Cov}(X,Y)$

9. 相关系数：标准化的协方差：$\rho_{XY} = \frac{\mathrm{Cov}(X,Y)}{\sqrt{D(X)D(Y)}}$

10. 相关系数与线性相关：$|\rho_{XY}| = 1 \Leftrightarrow P\{Y = a + bX\} = 1$

    &gt; 相关系数仅仅衡量线性关系，不代表两个变量没有其他关系

11. 协方差矩阵、多维正态：略

#### 常见分布的数学期望和方差

1. 均匀分布：$(a+b)/2$，$(b-a)^2/12$
2. 指数分布：$\theta$，$\theta^2$
3. 正态分布：$\mu$，$\sigma^2$
4. 二项分布：$np$、$np(1-p)$
5. 泊松分布：$\lambda$，$\lambda$

### 大数定律和中心极限定理

#### 基本概念

1. 大数定理
    1. Chebyshev不等式［误差的概率有上限］

        条件：已知期望和方差

        $P\{|X - \mu| \ge \epsilon\} \le \sigma^2/\epsilon^2$

        $P\{|X-\mu| \le \epsilon\} \ge 1 - \sigma^2/\epsilon^2$

    2. 「依概率收敛」／「服从大数定理」：$\lim_{n\to\infty}P\{|\bar X_n - a_n| \ge \epsilon\} \le \sigma^2/\epsilon$$
    3. Chebyshev大数定理的特殊情况

        条件：随机变量序列独立，方差有奇性（方差已知且相等）

        这个随机变量序列按概率收敛于期望

        &gt; 由此可以得到两个结论：连续函数保收敛。平均值趋近于期望

    4. Bernoulli大数定理：针对二项分布，频率稳定性

        条件：n次简单重复试验，$n_A$为$A$发生的次数，$p$为$A$发生的概率

        $\left|\frac{n_A}{n} - p\right|$依概率收敛于$1$

        &gt; 使用Chebyshev大数定理证明

    5. Хинчин大数定理

        条件：随机变量序列，独立同分布

        结论和Chebyshev大数定理一样

2. 中心极限定理

    1. Lindbeyg-Levy中心极限定理

        对象：随机变量序列

        条件：独立同分布，期望方差已知
        
        $$
        Y = \frac{\sum X_k - E(\sum X_k)}{\sqrt{D(\sum X_k)}} = \frac{\sum X_k - n\mu}{\sqrt{n}\sigma}
        $$
        
        **和**的标准化随机变量按概率收敛于**标准正态**

    2. de Moivre-Laplace中心极限定理

        对象：二项分布总体
        
        $$
        Y = \frac{X-np}{\sqrt{np(1-p)}}
        $$
        
        趋近于标准正态。

        &gt; 二项分布的极限的标准正态

## Part 2 数理统计

&gt; 五个统计量、四大分布、六大定理

### 基本概念

1. 总体：类，一个随机变量

2. 样本：对象，一次试验的结果，一个随机变量

3. 简单随机样本、简单随机抽样

    1. 代表性：同分布
    2. 独立性：所有样本相互独立

4. 统计量：样本不含参的函数

5. **五个统计量**

    1. 样本均值
    2. **样本方差**：$\frac{n}{n-1}B_2$
    3. 样本标准差
    4. $A_k$，k阶原点矩
    5. $B_k$，k阶中心矩

    &gt; 为何方差这么奇葩？因为他是无偏估计

### 以正态为基础，统计学三大分布

&gt; 龙珑的四大分布

1. 正态分布：后面所有分布的基础

2. $\chi^2$分布：样本平方和的分布

    1. 定义：$\chi^2 = \sum X_i^2$，$\chi^2 \sim \chi^2(n)$，自由度为$n$的$\chi^2$分布

    2. 性质

        1. 期望、方差：$E(\chi^2) = n$，$D(\chi^2) = 2n$

            &gt; 证明出奇的简单，利用独立性！

        2. $\alpha$分位点［一般是上分位点］

        3. 图形不对称

        4. Fisher的定理：$n$够大的时候，$\chi^2_\alpha(n) = \frac{1}{2}(z_\alpha + \sqrt{2n-1})^2$

3. $t$分布

    1. 定义：$T = \frac{X}{\sqrt{\frac{Y}{n}}}$，$T\sim t(n)$（$X$标准正态，$Y$服从$\chi^2$）

        &gt; 标准正态除以一个「等价的」标准正态

    2. 性质

        1. 图形和标准正态相似
        2. 偶函数
        3. $n&gt;30$时，近似标准正态

4. $F$分布

    1. 定义：$F = \frac{U/m}{V/n}$，$U,V$都服从$\chi^2$
    2. 性质
        1. $\frac{1}{F(m,n)} \Leftrightarrow F(n, m)$
        2. $F_{1-\alpha}(n,m) = \frac{1}{F_\alpha(n,m)}$
        3. 图形不对称，和$\chi^2$分布有点像

#### 六大定理

&gt; 分为对**单个**正态总体、和**两个**正态总体均值和方差的估计。又能分成已知方差、未知方差
&gt;
&gt; 均值做差，方差做比

1. 定理一：已知$\sigma^2$对$\mu$的估计

    1. $\bar X \sim N(\mu, \frac{\sigma^2}{n})$
    2. $\frac{\bar X - \mu}{\frac{\sigma}{\sqrt{n}}}\sim N(0,1)$

    &gt; 2是1的标准化。这个定理意味不仅意味着均值趋于方差，而且意味着方差

2. 定理二：未知$\sigma$对$\mu$估计

    $\frac{\bar X - \mu}{\frac{S}{\sqrt{n}}} \sim t(n)$

    &gt; 把$\sigma$换成$S$

3. 定理三：对$\sigma$估计

    $$
    \frac{(n-1)S^2}{\sigma^2} \sim \chi^2(n-1)
    $$

    &gt; 所有的$n-1$都来自这个定理

4. 定理四：$\bar{X}$和$S$独立

    &gt; 使用增量法理解

5. 定理五：两个正态总体均值差的关系

    1. 已知$\sigma^2$

        $$
        \frac{(\bar X - \bar Y) - (\mu_1 - \mu_2)}{\sqrt{\frac{\sigma_1^2}{n^2} + \frac{\sigma_2^2}{m^2}}} \sim N(0, 1)
        $$

    2. 未知$\sigma^2$。把分母换成$S_w(\sqrt{\frac{1}{n_1}+\frac{1}{n_2}})$，服从$t(n + m - 2)$分布

        &gt; $S_w^2 = \frac{(m-1)S_x^2 + (n-1)S_2^2}{(m-1) + (n-1)}$，两者方差的「均值」

6. 定理六：两个正态总体方差比的关系

    $$
    \frac{\frac{S_X^2}{S_Y^2}}{\frac{\sigma_1^2}{\sigma_2^2}}\sim F(m-1, n-1)
    $$

7. 

### 参数估计

#### 概论

1. 如何估计：点估计、区间估计
2. 如何评价：三个评价标准

#### 点估计

##### 矩估计

1. 估计原理：辛钦大数定理，$\bar X^k \overset{P}{\to} E(X^k)$

2. 方法：列方程、解方程，列到方程足够为止，解出来的参数就是估计量。

    $$
    \mu_k(\hat\theta_1, \dots , \hat\theta_m) = \bar X_m
    $$

3. 优点：简单

4. 缺点

    1. 不唯一
    2. 有时不合理（考虑均匀分布）

##### 极大似然估计

&gt; 首选

1. 估计原理：最大似然原理（与小概率原理对立）

2. 方法

    构建似然函数，然后求极大值点。

    似然函数有两种情况

    1. 离散情形下
    
        $$
        L(\theta) = \prod^n_{i=1}P(x_i;\theta)
        $$

    2. 连续情形下
    
        $$
        L(\theta) = \prod^n_{i=1}f(x_i, \theta)
        $$

    &gt; 由于出现累乘，常常需要对$L(\theta)$取对数。不过$\ln$不改变极大值点，因此很方便。

##### 评价

1. 无偏：$E(\hat\theta) = \theta$，基本要求

2. 有效：两个**无偏估计**，方差小的更有效

    &gt; 无偏是有效的前提，都不无偏，那就一定不有效

3. 相合：$\hat\theta \overset{P}{\to} \theta$

    &gt; 无偏和有效是相合的前提

#### 区间估计

&gt; 单侧估计和双侧估计
&gt;
&gt; 都得往正态上靠
&gt;
&gt; 联系定理

1. 置信区间：$\theta$是要估计的未知参数，$\hat\theta_1$、$\hat\theta_2$是两个**统计量**，如果

    $$
    P\{\hat\theta_1 \lt \theta \lt \hat\theta_2 \} = 1-\alpha
    $$
    
    那么随机区间$(\hat\theta_1, \hat\theta_2)$是**置信度**为$1-\alpha$的置信区间，$\alpha$叫**显著性水平**

2. 方法

    1. 正态总体
        1. 双侧
            1. 已知$\sigma$估计$\mu$：$\left(\bar X \pm \frac{\sigma}{\sqrt{n}}z_\frac{\alpha}{2}\right)$，定理分母乘以分位点
            2. 未知$\sigma$也是一样的，不过分布改成t分布
            3. 估计$\sigma^2$，由于估计量放在分母上，所以要注意$1-\alpha/2$和$\alpha/2$的位置关系。定理分子除以分位点。
        2. 单侧：双侧改一改
    2. 非正态：中心极限定理

### 假设检验

1. 基本思想

    1. 证伪
    2. 样本说服力不同
    3. 「差异显著」=「小概率事件发生」几乎是不可能的。如果「差异显著」，就成功证伪

2. 显著性水平：小概率$\alpha$

3. 检验统计量：要检验的量

4. 原假设：$H_0$，默认发生

5. 备择假设：$H_1$，默认不发生

    &gt; $H_0$一般认为是大概率的，$H_1$一般认为是小概率的。同一个问题，假设放置的位置不同，体现着立场不同。
    &gt;
    &gt; 比如：做有罪推定，还是无罪推定？没有证据，是否认为犯罪？假定无恶意，还是假定恶意？
    &gt;
    &gt; 但是这其中并不只是概率的问题，还涉及到价值观、目的。比如，病毒检测，我们不应该放过任何一个潜在的携带者，$H_1$应该放阳性。

    &gt; 研发中，刚刚想出的新方法一般不优于旧方法。
    &gt;
    &gt; $H_0$和$H_1$未必对立

6. 拒绝域：小概率发生的区间，落入拒绝域，则说明「差异显著」，成功证伪。

7. 假设检验可能发生的错误

    &gt; 有两个概率需要控制，一个是冤枉好人的概率，一个是放走坏人的概率。减小一个，就会增大另一个，那么我们应该选择控制哪一个呢？

    1. 弃真概率（第一类错误发生的概率）
    
        $$
        \alpha = P\{\text{拒绝$H_0$}|\text{$H_0$为真}\}
        $$
        
        即为显著性水平。显著性检验只控制弃真概率。

        &gt; 也就是，控制冤枉好人的概率。

    2. 取伪概率（第二类错误发生的概率）
    
        $$
        \beta = P\{\text{接受$H_0$} | \text{$H_0$为假}\}
        $$
        
        检验功效$1-\beta$

        &gt; 考虑病毒检测，如果一个检测方式，如果检测得到阳性，那么大概率是有病，那么这种检测功效是不错的。（即便可能存在一大批假阴性）。

8. 双侧检验：$H_1: ??? \ne ???$

9. 单边检验

10. 与置信区间的关系

        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        自用英語音標
        
        </title>
        <url>////nth233.top/posts/2020-04-12-自用英語音標.html</url>
        <search-text>
        
        
            语言
        
            音标
        
        
        
        不管是英语的音标还是IPA，都不太容易输入。有些比较容易输入的音标又不够简洁，甚至不太容易看懂。为了方便在我背的单词旁边标上音标，搞了一个背单词够用的不太准确的音标。
        
        
        
不管是英语的音标还是IPA，都不太容易输入。有些比较容易输入的音标又不够简洁，甚至不太容易看懂。为了方便在我背的单词旁边标上音标，搞了一个背单词够用的不太准确的音标。

## 音的对应关系

### 辅音

/m/ =&gt; m

/n/ =&gt; n

/ŋ/ =&gt; ng

/p/ =&gt; p

/b/ =&gt; b

/t/ =&gt; t

/k/ =&gt; k

/g/ =&gt; g

/f/ =&gt; f

/v/ =&gt; v

/d/ =&gt; d

/s/ =&gt; s

/z/ =&gt; z

/h/ =&gt; h

/l/ =&gt; l [^3]

/ɹ/ =&gt; r

/j/ =&gt; y

/w/ =&gt; w

/ʒ/ =&gt; j

/ʃ/ =&gt; sh

/tʃ/ =&gt; ch

/dʒ/ =&gt; dj

/θ/ =&gt; th

/ð/ =&gt; dh

### 元音

&gt;   大写字母都表示长音

/iː/ =&gt; ee/I

/ɪ/ =&gt; i

/e/ =&gt; e

/ɑː/ =&gt; a/aa/ah

/ɒ/ =&gt; o

/æ/ =&gt; A

/ɔː/ =&gt; O

/uː/ =&gt; U/oo[^4]

/ʊ/ =&gt; u

/ʌ/ =&gt; .u

/ɜː/ =&gt; er

/ə/ =&gt; .a/.e [^1]

/eɪ/ =&gt; ei

/əʊ/ =&gt; ou/.eu[^2]

/aɪ/ =&gt; ai

/aʊ/ =&gt; au

/ɔɪ/ =&gt; oi

/ɪə/ =&gt; i.a

/eə/ =&gt; e.a/e.a[^4]

/ʊə/ =&gt; u.a/u.e[^4]

[^1]: 建议：原单词是这个音对应的字母是a就用.a，否则用.e
[^2]: 建议使用ou
[^3]: 不区分clear L和dark L
[^4]: 建议使用前者

## 重音的标法

用`,`表示次重音，用`&#39;`表示重音。如果重音在单词第一个音节，则可以不标（当然为了表示强调也可以标）。

## 一些例子

&gt;   写出来的音标和原单词的相似度挺高的。很容易看懂。

example [egzampl]/[egzAmpl]

recognize [rekognaiz]

shut [sh.ut]

bird [berd]

shepherd [‘sheperd]

several [‘sevrl]

human [hyUm.an]

foot [foot]

curve [kerv]

sheep [sheep]

yes [yes]

shit [shit]

comprehensive [,kom/pri’hen/siv]

jam [djAm]

draw [drO]

fuck [f.uk]

comma [kom.a]

zoom [zoom]

cute [kyUt]

the [dh.a] / [dhee]

thumb [th.um]

good [gud]

god [god]

sing [seeng]/[sIng]

I [ai]

Japan [dj.a’pAn]

apple [Apl]

banana [b.anan.a]

genre [janr.e]/[janr.a]

usual [yUju.al]

shoot [shoot]/[shUt]

show [shou]

water [water]

cow [kau]

monkey [m.ungki]

desperately [desp.er.atli]/…

resign [ri’zain]

climb [klaim]

king [king]

        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        明天就是夏天
        
        </title>
        <url>////nth233.top/posts/2020-03-17-明天就是夏天.html</url>
        <search-text>
        
        
            瞎写
        
        
        
        锻炼一下想象力，乱写
        
        
        
# 明天就是夏天

“明天就是夏天了。”

朝山下看去，大雾弥漫了整个城市，正慢慢地升腾起来。

这里一年只有冬夏两季，或者更准确地说：*数月冬夏，两日春秋*。昨天这个小镇还白雪皑皑，覆满积雪。但从今天恒星（方便起见姑且叫太阳）升起的那一刻开始，一切都开始改变了：几小时内积雪融化大半，而到现在，太阳刚刚下山，积雪已经全部消失，取而代之的是春夏夜晚飘满城镇的夜气。

大雾朦胧了卫星的反射光（方便起见姑且叫月光），抬头望去，只能看到朦胧得不成型的一圆。在这样黯淡的天光之下，小A坐在山顶的亭子里，激动地朝城中喊出那句话。春天来了，也要走了，明天就是夏天。一年只有一天会这样，人们每隔四个小时脱一件衣服，融化的积雪把镇子变成水城，在外的乡人匆匆赶回，不过由于公路被水封堵，只能乘船回来。大规模的人口流动下，每条水道都拥堵而热闹。小A向远处望去，目之所及，都有船透出的灯光。

山另一边的冻原正快速消退，几天后会变成草原，再久一点，看不到的中心就变成沙漠了。

这一切发生的时间都是不确定的。

小A还记得，去年的冬天比今年长得多，前年的则比去年的短一些。人们适应了这种四季不平衡，该有的制度和措施已经很完善。就这个小镇而言，所有屋子都有凉屋和暖屋，冬天睡暖屋，夏天睡凉屋。空出来的房间，就看户主怎么处置了。田地、工厂也都是做了相关保障的。

预报？预报在当前是几乎不可能的。科学院的预报只能做到提前十分钟，甚至还没等预报传播出去，人们自己就已经知道要换季了，因为换季开始时的大风已经吹起来了。大风开始时一直吹，然后就开始减小，到现在已经几乎没风了。老人的经验？老人在换季时间上唯一有用的经验，就是“换季是不确定的”。不过每当换季，干不了活的老人就会拉上小孩，群聚在一块，没什么别的可说，就是一遍一遍地回忆以前换季时的往事，仿佛牛在反刍。

不管怎么样，看尽了新闻播报，听厌了老人的老调，春天正在过去。慢慢地，一点点微微的春风吹起，虽然小得连树叶都吹不响，但让人很舒服。耳畔都是水从树上和山上淌下的声音，山下的交谈声和马达声混杂，传到山上只有细细的一点，大概就是所谓“较小剂量”的吵闹，令人愉悦。突然，政府小楼敲了9下钟，小A决定下山。

夜气弥漫，明天就是夏天。

&gt;   草稿写于2020.3.3

        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        高数（下）笔记
        
        </title>
        <url>////nth233.top/notes/gaoshu_2.html</url>
        <search-text>
        
        
            math
        
            笔记
        
            数学
        
        
        
        记录高数的一些概念、解法和证明
        
        
        
&gt;  很久以前的笔记，现在为了复习更新上来（2022-05-03）

## 空间解析几何

### 平面、直线的方程

1.  已知在平面里的三点，要求平面方程
    1.  设一般方程，暴力解方程组
    2.  $\overrightarrow{AB}\times \overrightarrow{BC}$，得到法向量

2.  已知直线的一般方程，求参数方程
    1.  两个平面的法向量叉乘就是其方向向量。得到方向向量与其上一点，就可以列出对称式方程，从而得到参数方程。
    2.  暴力。对方程组进行变形，写出对称式方程，然后写出参数式方程。

3.  点到平面的距离
    $$
    d=\frac{|Ax_0+By_0+Cz_0+D|}{\sqrt{A^2+B^2+C^2}}
    $$

4.  两直线的夹角

    方向向量的夹角余弦值
    $$
    \cos{\alpha}=\frac{|m_1m_2+n_1n_2+p_1p_2|}{\sqrt{m_1^2+n_1^2+p_1^2}\cdot\sqrt{m_2^2+n_2^2+p_2^2}}
    $$

5.  直线与平面的夹角

    等于方向向量与法向量的夹角

    直线与平面的关系，其实就是考察法向量和方向向量的关系。

### 曲面方程

#### 旋转曲面

有以曲线$F(x, y)=0$，绕$x$轴旋转，得到
$$
F(x, \sqrt{y^2+z^2})
$$

&gt;   绕哪个轴旋转，哪个轴就不变

1.  旋转椭球面
2.  圆锥面

#### 柱面

简单

#### 二次曲面

1.  椭球面
    $$
    \frac{x^2}{a^2}+\frac{y^2}{b^2}+\frac{z^2}{c^2}=1
    $$

2.  椭圆抛物面
    $$
    \frac{x^2}{2p}+\frac{y^2}{2q}=z
    $$

3.  马鞍面（双曲抛物面）
    $$
    -\frac{x^2}{2p}+\frac{y^2}{2q}=z
    $$

4.  单叶双曲面
    $$
    \frac{x^2}{a^2}+\frac{y^2}{b^2}-\frac{z^2}{c^2}=1
    $$

5.  双叶双曲面
    $$
    \frac{x^2}{a^2}+\frac{y^2}{b^2}-\frac{z^2}{c^2}=-1
    $$

6.  二次锥面
    $$
    \frac{x^2}{a^2}+\frac{y^2}{b^2}-\frac{z^2}{c^2}=0
    $$

#### 空间曲线的方程

1.  一般方程：两个曲面相交得到
2.  参数方程

## 多元函数微分学

&gt;   类比

### 点

1. 内点：存在$\delta &gt; 0$、$P_0\in \mathbb{R^2}$使$U(P_0, \delta)\subset\mathbb{R^2}$，则$P_0$是内点
2. 边界点和外点：类比上面的定义。

### 点集

1.  开集：没有边界点，全是内点
2.  闭集：开集的余集（$R^2-D$）成为闭集
3.  区域：联通的点集

### 二元函数的极限

$P\to P_0$有无穷条路径

&gt;   经典例子：
&gt;   $$
&gt;   \lim_{(x,y)\to(0,0)}\frac{xy}{x^2+y^2}
&gt;   $$
&gt;
&gt;   $$
&gt;   \lim_{x\to 0, y\to 0}\frac{xy^2}{x^2+y^2}
&gt;   $$
&gt;
&gt;   $$
&gt;   \lim_{(x,y)\to (0,0)}\frac{x^y}{x^4+y^2}
&gt;   $$

累次极限存在，不代表二重极限一定存在；二重极限存在，也不代表累次极限存在。但是如果它们都存在，则必然相等。

二元函数求极限的方法：

1.  等价无穷小替换
2.  换元
3.  夹逼

#### 闭区域上连续函数的性质

有界性、最值定理、介值定理

### 偏导数

只留一个变量动，把其他变量都固定，对动的变量求导，得到偏导数。

&gt;   这个符号$\partial$可以读作partial

偏导数记号，一般应视作整体，$\displaystyle \frac{\partial f}{\partial x}$和$\displaystyle \frac{\partial f}{\partial y}$的分母实际上是不同的，但是记号却是一样的。

可偏导未必连续，连续未必可偏导。

#### 高阶/混合偏导数

Clairaut定理：两个二阶混合偏导数的求导顺序不同，不一定相等。但是如果两个二阶混合偏导数都在区域$D$内连续，二者则相等。

&gt;   我好像也没那么蠢

&gt;   Laplace算子$\Delta r = \frac{\partial^2 r}{\partial x^2} + \frac{\partial^2 r}{\partial y^2} + \frac{\partial^2 r}{\partial z^2}$

### 全微分

$z=f(x,y)$，全微分$dz=\frac{\partial z}{\partial x}dx + \frac{\partial z}{\partial y}dy$

在区域$D$中每一点都存在全微分，则$f$是$D$内的可微函数

可微必连续、必可偏导。

#### 可微的必要条件和充分条件

1. 必要条件

    1. $f(x,y)$在这点续
    2. 偏导数在这点存在

2. 充分条件

    偏导数在这点的某邻域内存在，且在这点连续。

&gt;   利用全微分进行近似计算，比如计算$1.04^{1.98}$
&gt;
&gt;   设$z = x^y$， $(x_0,y_0)=(1, 2)$
&gt;
&gt;   
&gt;   $$
&gt;   f(x,y)-f(x_0,y_0)\approx f_x(x_0,y_0)\Delta x+f_y(x_0,y_0)\Delta y
&gt;   $$

&gt;   一阶微分的不变性为凑微分提供依据。
&gt;
&gt;   和一阶微分一样，一阶全微分也具有不变性：
&gt;
&gt;   $f = f(u, v)$，$u=u(x,y)$，$v=v(x,y)$，那么
&gt;   $$
&gt;   df = \frac{\partial f}{\partial u}du+\frac{\partial f}{\partial v}dv = \frac{\partial f}{\partial u}{(\frac{\partial u}{\partial x}x+\frac{\partial u}{\partial y}y)}+\frac{\partial f}{\partial v}{(\frac{\partial v}{\partial x}x+\frac{\partial v}{\partial y}y)}
&gt;   $$

#### 多元函数链法则

![image-20200318102540421](%E9%AB%98%E6%95%B0%EF%BC%88%E4%B8%8B%EF%BC%89%E7%AC%94%E8%AE%B0/image-20200318102540421.png)

&gt;   证明思路：
&gt;
&gt;   利用全微分知识：$\Delta_x z=f_u\Delta_x u+f_v\Delta_x v+o(\rho)$，两边除以$\Delta x$，求极限，就得到链法则。 

#### 隐函数的偏导数

两边求偏导，嗯，就这样。

##### 隐函数组的偏导数

&gt;    其实就是tm就是解方程组。

考虑方程组

$$\left\{\begin{aligned}&amp; P(x,y,u,v)\\&amp;Q(x,y,u,v)\end{aligned}\right.$$

把四个变量中的两个作为自变量，就确定出两个两元函数，作为一个两元隐函数。

然后教材上列出Jacobi式，莫名奇妙出现一堆行列式。其实tm就是解方程组，Cramer法则用用罢了。看着怪吓人的。

&gt;   过后我重新审视了一下Jacobi的方法，感觉也没有那么复杂难记，其实只要用心看看下面这组公式就明白了。
&gt;
&gt;   隐函数组
&gt;   
&gt;
&gt;   $$
&gt;   \begin{cases}
&gt;   F(u, v, x, y) = 0 \\\
&gt;   G(u, v, x, y) = 0
&gt;   \end{cases}
&gt;   $$
&gt;   
&gt;
&gt;   $$
&gt;   J = \frac{\partial(F, G)}{\partial(u, v)} = \begin{vmatrix}F_x &amp; F_v \\\\ G_x &amp; G_y\end{vmatrix}
&gt;   $$
&gt;
&gt;   $$
&gt;   \frac{\partial u}{\partial x} = -\frac{1}{J}\frac{\partial(F, G)}{\partial(x, v)}
&gt;   $$
&gt;
&gt;   $$
&gt;   \frac{\partial u}{\partial y} = -\frac{1}{J}\frac{\partial(F, G)}{\partial(y, v)}
&gt;   $$
&gt;
&gt;   $$
&gt;   \frac{\partial v}{\partial x} = -\frac{1}{J}\frac{\partial(F, G)}{\partial(u, x)}
&gt;   $$
&gt;
&gt;   $$
&gt;   \frac{\partial v}{\partial y} = -\frac{1}{J}\frac{\partial(F, G)}{\partial(u, y)}
&gt;   $$

&gt; 隐函数存在定理
&gt;
&gt; $J$在某点处不等于0，则在这点可以确定唯一的单值函数。

#### 方向导数和梯度

实际上还是把多元问题变成一元问题。设有一个向量$\boldsymbol{l}$，有一个函数$z=f(x,y)$，那么这个函数$P_0(x_0,y_0)$处$\boldsymbol{l}$方向的导数记为：

$$
\left.\frac{\partial z}{\partial\boldsymbol{l}}\right|_{P_0} = \lim_{\rho\to 0}\frac{f(x_0+\Delta x, y_0 + \Delta y)}{\rho} \ \left(\rho = \sqrt{\Delta x^2 + \Delta y^2}\right)
$$

如果在这点可微，则：

$$
\left.\frac{\partial z}{\partial\boldsymbol{l}}\right|_{P_0} = f_x(x_0,y_0)\cos\alpha + f_y(x_0,y_0)\cos \beta
$$

&gt;   就是梯度点乘了$\vec l$的方向余弦。
&gt;
&gt;   证明利用了$\Delta x/\rho = \cos\alpha$，$\Delta y/\rho = \cos\beta$

从上面的式子可以看出，如果$\vec l = \{f_x(x_0,y_0),f_y(x_0,y_0)\}$，刚好让方向导数最大！

这个方向就是**梯度**。

&gt;   梯度记为$\nabla x$或者$\mathrm{grad}z$，$\nabla$是nabla算子

#### 求曲线/曲面的切、法

### 曲线的切线和法平面

用参数方程，或者也可以用全导数 ~~（Jacobi式令人死亡）#tuxie~~

切线的方向向量就是法平面的法向量。

### 曲面的法向量和切平面

&gt; 总是忘记法向量的计算方法，所以这次回来重新审视和理解一下法向量是怎么算的。**感觉很巧妙**

设曲面方程为$F(x,y,z)=0$

那么求法向量的核心就是全导数公式。

$$
\frac{dF}{dt} = \frac{\partial F}{\partial x}\frac{d x}{d t} + \frac{\partial F}{\partial y}\frac{d y}{d t} + \frac{\partial F}{\partial z}\frac{d y}{d z} = 0
$$

其中

$$
\left\{
\begin{aligned}
&amp; x = x(t) \\
&amp; y = y(t) \\ 
&amp; z = z(t)
\end{aligned}
\right.
$$

是经过某点$P_0$的曲面上的曲线

上式恰好可以看成曲线在$P_0$切向量于另一个向量的点成，而由于曲线是一般的，所以“另一个向量”就是要找的法向量。

$\vec v = \left\{ \frac{\partial F}{\partial x}, \frac{\partial F}{\partial y}, \frac{\partial F}{\partial z} \right\}$

#### 二元函数Taylor公式

本质上是参数方程+链法则。

考虑$z=f(x,y)$，我们主要考虑$x$和$y$在这里变一点点，$z$怎么变，最大限度地模拟它的变化。比如给$x$一个变化$a$，给$y$一个变化$b$，想知道$f(x+a,y+b)$是多少。

很自然地，考虑这个$(a,b)$这个方向的方向导数。设$\phi(t) = f(x_0 + at, y_0+bt)$

根据一元函数的Maclauring公式

$$
\phi(t) = \sum_{k=0}^{n} \frac{\phi^{(n)}(0)}{k!}t^k + R_n(t)
$$

可以知道

$$
f(x+a, y+b) = \phi(1) = \sum_{k=0}^{n}\frac{\phi^{(n)}(1)}{k!} + R_n
$$

$\phi^{(n)}(t)$实际上就是在$f(x,y)$在$(a, b)$个方向上的$n$阶导数，可以证明：
$$
\phi^{(n)}(t) = \left(a\frac{\partial}{\partial x} + b\frac{\partial}{\partial y}\right)^nf(x_0+at, y_0+bt)
$$

&gt;   证明可以使用数学归纳法

嘿，那么直接代入就可以得到：
$$
f(x+a,y+b) = \sum_{k=0}^n\frac{1}{k!}\left(a\frac{\partial}{\partial x} + b\frac{\partial}{\partial y}\right)^kf(x_0, y_0) + R_n
$$
这就是多元函数的Taylor公式！

其中Lagrange余项$R_n$如下（$t=1$，所以没有$t^{n+1}$这个因式）：
$$
R_n = \frac{\phi^{(n+1)}(\xi)}{(n+1)!} = \frac{1}{(n+1)!}\left(a\frac{\partial}{\partial x} + b\frac{\partial}{\partial y}\right)^{n+1}\cdot f(x_0+a\xi, y_0+b\xi) \ (0\le\xi\le1)
$$
也可以写成Peano余项$o(\rho^n)$，$\rho = \sqrt{a^2 + b^2}$

#### 求极值

思想很简单，就是找出**驻点**，再判断是不是比周围都高/低。

极值存在的充分条件需要注意，似乎就是考虑各个方向的二阶方向导数，只不过为了方便证明借助了Taylor公式

在$(x_0,y_0)$的邻域有连续的二阶偏导数，记Heissian矩阵为

$$
H_f = \begin{vmatrix}
f_{xx} &amp; f_{xy} \\
f_{yx} &amp; f_{yy}
\end{vmatrix}
$$

1.  若$H_f$**正定**，即其行列式大于0且$f_{xx} &gt; 0$，这点是极**小**值点
2.  若$H_f$**负定**，即其行列式大于0且$f_{xx}&lt;0$，这点是极**大**值点
3.  如果$|H_f| &lt; 0$，不是极值点
4.  如果$|H_f| = 0$，另作讨论，再说

#### 条件极值

碰到不能转化为非条件极值的极值问题，可以使用Lagrange乘数法。证明不想看。方法如下：

设$\phi(x,y)$和$\psi(x,y)$是约束条件，要求极值的函数是$z = f(x,y)$

1.  构造Lagrange函数$L(x,y,z,\lambda,\mu) = f(x,z,y) + \lambda \phi(x,y)+\mu\psi(x,y)$
2.  Lagrange函数分别对每个变量求偏导数，令每个偏导数都等于0，就能得到一个方程组
3.  解出来就完了:fu:（还要验证）​

&gt;   居然在经济学的书上面看到了Lagrange乘数法，看来还是在最优化问题中还是挺有用的。

## 多元函数积分学

### 二重积分

记号、定义、线性、可加性、估值公式此不再赘述，具体看书，类比一元的情况。

&gt;    二重积分也有中值定理：
&gt;
&gt;   函数$f(x,y)$在闭区域$D$上连续，则存在一点$(\xi, \eta)\in D$，使
&gt;   $$
&gt;   \iint_D f(x,y)d\sigma = f(\xi, \eta)\sigma
&gt;   $$
&gt;   即
&gt;   $$
&gt;   \frac{1}{\sigma}\iint_D f(x,y)d\sigma = f(\xi, \eta)
&gt;   $$

#### 二重积分的计算

##### 直角坐标

基本思想就是化成**累次积分**。

二重积分的几何意义是以某个区域为底的曲顶柱体的体积，如果把这个柱体切成很多薄片，每个薄片的面积就是一个曲边梯形，把这些梯形面积积分起来，就得到了二重积分的值。

下面就是最基本的形式：

$$
\iint_Df(x,y)dxdy = \int_a^bdx\int_{\phi_1(x)}^{\phi_2(x)}f(x,y)dy
$$

必要的时候可以把区域划分为多个小区域，分别积分后加在一起。有时候也可以用几何意义，虽然道理讲不清楚。

&gt;   几个作业题：（懒得打，以后再加进来）

##### 换元

&gt;   都是因为这题作业题我才会纠结换元的问题：
&gt;
&gt;   计算$\iint_{D} x^{2} y^{2} \mathrm{d} x \mathrm{d} y$，其中$D$是由曲线$x y=1$、$x y=2$和直线$y=x$、$y=4x$所围成的第一象限的区域。

换元实际上就是面积的变换，利用我最讨厌的Jacobi行列式就可以做到。
$$
\iint_Df(x,y)dxdy = \iint_{D&#39;}g(u,v)\left|\frac{\partial(x,y)}{\partial{(u,v)}}\right|dudv
$$
具体证明并不复杂，就是考虑每个面积元在变换实施后的改变。

利用换元法，就可以直接获得极坐标下二重积分的计算方法。（大概就是旋转体体积柱壳法的来源）

##### 极坐标

设$x = \rho\cos\theta$，$y=\rho\sin\theta$

$$
\iint_Df(x,y)dxdy = \iint_Df(\rho\cos\theta, \rho\sin\theta)\left|\frac{\partial(x,y)}{\partial{(\rho,\theta)}}\right|d\rho d\theta
$$

其中

$$
\left|\frac{\partial(x,y)}{\partial{(\rho,\theta)}}\right| = 
\begin{vmatrix}
\cos\theta &amp; -\rho\sin\theta \\
\sin\theta &amp; \rho\cos\theta
\end{vmatrix} = \rho
$$

故：

$$
\iint_Df(x,y)dxdy = \iint_D\rho f(\rho\cos\theta, \rho\sin\theta) \cdot d\rho d\theta
$$

&gt;   这就是大物里面求圆盘转动摩擦力矩的积分方法。

#### 三重积分

基本思想也是替换成累次积分

##### 先一后二法（投影法）

本质就是把一块体积看作是无数细长柱体拼起来的，先在线段上积分（一元积分），然后把投影面积上的线再积起来（二元积分）。

##### 先二后一法（截面法）

这个比较好理解，就是把一个区域切成很多薄片，每个薄片分别进行二重积分，最后再积起来。

##### 换元法

跟二元一样。一般是换成柱坐标或者球坐标。

换成柱坐标好说，但是换成球坐标还是需要注意。

设

$$
\left\{
\begin{aligned}
&amp; x = \rho\sin\phi\cos\theta \\
&amp; y = \rho\sin\phi\sin\theta \\
&amp; z = \rho\cos\phi
\end{aligned}
\right.
$$

&gt;   $\theta$是向量与x轴夹角，$\phi$是向量与z轴夹角。画个图好理解。书上是理解为三个曲面交出一个点（球面，圆锥面，平面）。总之很独特，感觉比二维的情况复杂多了。

Jacobi行列式不好算，总之，最终得到结果$dv = \rho^2\sin\phi \ d\rho d\phi d\theta$

#### 重积分的几个典型应用

&gt;   一切按定义推。如果写成矢量形式会更简洁。

##### 求重心

假设有一个平面薄片，密度分布函数为$\rho(x, y)$，$\vec s = x\vec i + y\vec j$是薄片上某一质点的位矢。

则总质量就是

$$
M = \iint_D \rho(x,y) d\sigma
$$

重心的位矢就是

$$
\vec s_0 = \frac{1}{M}\int_D\vec{r}\rho(x, y) \ d\sigma
$$

&gt;   三维物体如法炮制即可。

##### 求转动惯量

物体的空间区域为$\Omega$，有连续的密度分布函数$\rho(x,y,z)$

对$z$轴的转动惯量就是

$$
I_z = \iiint_\Omega (x^2+y^2)\rho(x,y,z) \ dV
$$

对原点的转动惯量就是

$$
I_O = \iiint_{\Omega} (x^2+y^2+z^2)\rho(x,y,z)\ dV
$$

##### 求引力

物体空间区域为$\Omega$，给定一个质点的位矢$\vec{s}$，有密度$\rho(\vec s)$，求这个物体对区域外一点$\vec s_0$的万有引力。
$$
\vec F = G\iiint_\Omega\frac{\rho(\vec s)}{|\vec s - \vec{s}_0|}(\vec s - \vec s_0) \ dV
$$

### 曲线曲面积分

#### 第一类曲线积分（对弧长）

$$
\int_Lf(x,y) ds
$$

如果是闭合曲线，则记为
$$
\oint_Lf(x,y)d s
$$
各种性质不再赘述。关键是怎么求。

基本思路就是化为参数方程

$$
\begin{cases}
x = \phi(t)\\
y = \psi(t)
\end{cases}
$$

则
$$
ds = \sqrt{x&#39;^2_t + y&#39;^2_t}dt
$$

$$
\int_Lf(x,y)ds = \int_{t_1}^{t_2}f[\phi(t), \psi(t)]\sqrt{\phi&#39;^2(t)+\psi&#39;^2(t)}dt
$$

&gt;   虽然看起来很丑，但是实际做起来并不难，只是繁琐罢了。这种做法有很多条件，具体看书，不是重点。更高维的如法炮制。

如果是极坐标，需要注意
$$
ds = \sqrt{r^2+r&#39;^2}d\theta
$$

#### 第二类曲线积分（对坐标）

$$
\int_L\vec{F}\cdot d\vec{s}
$$

三个轴分别积分就是了。不难，反而更简单。

{--不是三个轴分别积分那么简单的，这样分别积分是有条件的。（路径是折线）--} 把问题复杂化了。

用参数方程来理解。

$$
\left\{
\begin{aligned}
&amp; x = x(t) \\ 
&amp; y = y(t)
\end{aligned}
\right.
$$

然后代进积分中

$$
\int_{L}P(x,y)dx + Q(x, y)dy = \int_LP(x(t), y(t))x&#39;(t)dt + \cdots
$$

{++稍微化一下就能发现++}

$$
\int_{L}P(x,y)dx + Q(x, y)dy = \int_LP(x(t), y(t))x&#39;(t)dt + Q(x(t), y(t))y&#39;(t)dt = \int_LP(x(t), y(t))x&#39;(t)dt + \int_L Q(x(t), y(t))y&#39;(t)dt = \int_LPdx + \int_LQdy
$$

&gt;   两类曲线积分是可以互相转换的
&gt;   
&gt;   $$
&gt; \int_L\vec F\cdot d\vec s = \int_L \frac{\vec F\cdot \nabla\vec s}{|\nabla\vec s|}ds
&gt; $$
#### Green公式

&gt;   类比Newton-Leibniz公式？

先对区域分类。

&gt;   单连通区域和复连通区域
&gt;
&gt;   如果$D$内任何一条闭合曲线所围的区域都属于$D$，那么就是单连通的。简单说就是**没有洞**。否则就是复连通（有洞）。

考虑一个单连通的闭区域$D$，函数$P(x,y)$和$Q(x,y)$在区域内**都有连续的一阶偏导数**，$L$是区域$D$的边界，那么

$$
\iint_D\left(\frac{\partial Q}{\partial x} - \frac{\partial P}{\partial y}\right)dxdy = \oint_L Pdx + Qdy
$$

&gt;   果不其然，证明用了Newton-Leibniz公式。
&gt;
&gt;   需要考虑$x$型还是$y$型。书上证明假定既是$x$型，也是$y$型，比较普遍。
&gt;
&gt;   必须强调 ==$L$是有正方向的，也就是$D$始终在观察者的左侧==
&gt;
&gt;   如果$D$是复连通区域，那么需要考虑全部边界的曲线积分，然后*加*起来。

Green公式还可以写成向量形式

$$
\oint_C \vec F \cdot\vec n^0ds = \iint_D\nabla \vec F d\sigma
$$

利用Green公式，可以得到一个面积公式

$$
A = \frac{1}{2}\oint_Lxdy-ydx
$$

&gt; 计算
&gt; 
&gt; $$
&gt;  \oint_C \frac{xdy-ydx}{x^2+y^2}
&gt; $$
&gt; 
&gt; $C$是**包围原点**的任意闭合曲线
&gt;  
&gt; &gt; 注意，Green公式不能用，因为在原点没有定义，也就没有偏导数

#### Gauss公式

Green公式的三维推广

#### Stokes公式

曲面积分与曲面边界的曲线积分的关系。

$$
\iint_\Sigma\left(\frac{\partial R}{\partial y} - \frac{\partial Q}{\partial z}\right)dydz + \left(\frac{\partial P}{\partial z}-\frac{\partial R}{\partial x}\right)dzdx + \left(\frac{\partial Q}{\partial x}-\frac{\partial P}{\partial y}\right)dxdy = \oint_\Gamma Pdx + Qdy + Rdz
$$

行列式助记

$$
\iint_\Sigma
\begin{vmatrix}
dydz &amp; dzdx &amp; dxdy \\
\frac{\partial}{\partial x} &amp; \frac{\partial}{\partial y} &amp; \frac{\partial}{\partial z} \\
P &amp; Q &amp; R
\end{vmatrix} 
= \oint_L Pdx + Qdy + Rdz
$$

向量形式

$$
\iint_\Sigma \mathrm{rot} \vec A\cdot\vec ndS = \oint_L \vec A\cdot \vec t ds
$$

### 散度和旋度

&gt; 本节内容参考《矢量分析和场论》

#### 散度

*公式支持垃圾，不写了*。
$$
\iint_\Omega \left(P dydz + Qdzdz+Rdxdy\right)dv
$$

$$
\mathrm{div}\boldsymbol{v} = \frac{\partial P}{\partial x}+\frac{\partial Q}{\partial y}+\frac{\partial R}{\partial z}
$$

实际上是用了Gauss公式：
$$
\iint_\Sigma \vec v \cdot \vec ndS = \iiint_\Omega \mathrm{div}\vec vdv
$$

#### 旋度

$$
\mathrm{rot}\boldsymbol A = \begin{vmatrix}
\boldsymbol i &amp; \boldsymbol j &amp; \boldsymbol k \\
\frac{\partial}{\partial x} &amp; \frac{\partial}{\partial y} &amp; \frac{\partial}{\partial z} \\
P &amp; Q &amp; R
\end{vmatrix}
$$

实际上是用Stokes公式：
$$
\oint_L \vec v\cdot d\vec s = \iint_\Sigma \mathrm{rot}\vec v\cdot \vec ndS
$$

## 微分方程

&gt;   主要是常微分方程，这部分内容老师自己的讲义写得比教材清楚（而且教材有种怪味），因此这部分的笔记基本上是照搬老师的讲义。

### 一、二阶的一些特殊的常系数微分方程

&gt;   非线性微分方程不是每个我们都能解，所以才会出现下面这种奇奇怪怪的分类，只是一个技巧的总结，不成一个知识体系。

1.  可分离变量的：分离变量，两边积分

2.  齐次的

    方程肯定可以化为这种形式
    
    $$
    \frac{dx}{dy} = f\left(\frac{y}{x}\right)
    $$
    
    接下来只需设$u = y/x$，就**可分离变量**了。
    
    $$
    u + x\frac{du}{dx} = f(u)
    $$

3.  可化为齐次的

    对于
    
    $$
    y&#39; = f\left(\frac{a_1x+b_1y+c_1}{a_2x+b_2y+c_2}\right)
    $$

    利用不动点，也就是分子分母联立，解方程组。如果系数矩阵为0，说明上下两个方程线性相关，可以直接换元为可分离变量的微分方程。
    
4.  可降阶的二阶微分方程

    1. $y&#39;&#39;=f(x,y&#39;)$，令$y&#39;=u(x)$
    2. $y&#39;&#39;=f(y,y&#39;)$，令$y&#39;=u(y)$

5. Bernoulli方程

    $$
    y&#39;+P(x)y=Q(x)y^n
    $$

    方程两边同时除以$y^n$，化为一阶线性方程。

6. 全微分方程（恰当方程）

    $$
    P(x,y)dx + Q(x,y)dy = 0
    $$

    需要验证平衡条件$\displaystyle \frac{\partial Q}{\partial x} = \frac{\partial P}{\partial y}$

    若不满足平衡条件，可以尝试找*积分因子*

### n阶线性微分方程

#### 一阶线性方程

可以直接套公式。也可以求出对应其次方程的通解，然后加上这个非其次方程的一个特解。

$$
\frac{dy}{dx} + P(x)y = Q(x)
$$

$$
y = e^{-\int P(x)dx}\left(\int Q(x)e^{\int P(x)dx} + C\right)
$$

&gt; 具体推导过程书上有。

#### 二阶线性方程

$$
\frac{d^2y}{dx}+P(x)\frac{dy}{dx}+Q(x)y = 0
$$

如果已知齐次方程一个解，可以直接使用Liouville公式，求得另一个线性无关的解。
$$
y_2 = y_1\int\frac{1}{y_1^2}e^{-\int P(x)dx}dx
$$

&gt; Wronsky行列式可以判断函数组是否线性相关。
&gt;
&gt; $W(x)_{i,j} = y_i^{(j)}$

&gt; 对于非齐次方程，使用常数变易法。
&gt;
&gt; 假设$C_1(x)和$$C_2(x)$，
&gt; $$
&gt; y^* = C_1(x)y_1 + C_2(x)y_2
&gt; $$
&gt; 然后求导，添加限制条件，解方程。

#### 二阶常系数微分方程

$$
y&#39;&#39; + py&#39; + qy = 0
$$

设$t = e^{rx}$，则得到特征方程
$$
r^2 + pr + q = 0
$$
如果没有重根（共轭复根也是），那么直接线性组合即可。如果有重根，则$x$乘以求得的根就是另一个根。


        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        折腾hugo
        
        </title>
        <url>////nth233.top/posts/2020-02-22-折腾hugo.html</url>
        <search-text>
        
        
            折腾记录
        
            blog
        
        
        
        最近折腾了一下hugo，因此咸鱼了几天。
        
        
        
最近折腾了一下hugo，有点中毒，咸鱼了几天在搞这个，网课都没怎么上。

感觉花在折腾上的时间太多了。

## 安装Hugo

由于国内特殊的网络环境，本来很简单的东西变得有点麻烦，必须用一些旁敲侧击的方法。从GitHub下载release的速度很慢，所以只好自己编译。从码云的镜像仓库clone下来，然后按照官网的步骤自己编译。

1.  首先安装go。得益于[go的国内镜像](https://golang.google.cn)，下载速度还算快。

2.  然后编译安装hugo

    ```sh
    go install --tags extended
    ```

    如果不要Sass/Scss支持的话可以把后面的选项去掉。

3.  试试hugo能不能用，应该是可以了。

## 找个主题

几经挑选，找到了这个主题（cactus-plus）。

不得不说，这步可能是第二花时间的。

## 一点配置

### 数学公式

这样弄完之后发现数学公式没法渲染，于是乎添加KaTex的支持。

在`theme/layouts/partials`里添加一个`katex.html`，内容如下：

```html
&lt;script&gt;
    document.addEventListener(&quot;DOMContentLoaded&quot;, function() {
        renderMathInElement(document.body, {
            delimiters: [
              {left: &quot;$$&quot;, right: &quot;$$&quot;, display: true},
              {left: &quot;$&quot;, right: &quot;$&quot;, display: false}
            ]
        });
    });
&lt;/script&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css&quot; integrity=&quot;sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq&quot; crossorigin=&quot;anonymous&quot;&gt;
&lt;!-- The loading of KaTeX is deferred to speed up page rendering --&gt;
&lt;script defer src=&quot;https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js&quot; integrity=&quot;sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;
&lt;!-- To automatically render math in text elements, include the auto-render extension: --&gt;
&lt;script defer src=&quot;https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js&quot; integrity=&quot;sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI&quot; crossorigin=&quot;anonymous&quot; onload=&quot;renderMathInElement(document.body);&quot;&gt;&lt;/script&gt;
```

当然也可以使用国内bootcdn的镜像，加载（理论上）更快。

然后在`head.html`中添加：

{% raw %}
```html
{{ if or .Params.katex .Site.Params.katex }}
{{ partial &quot;katex.html&quot; . }}
{{ end }}
```
{% endraw %}

当渲染的页面当中有数学公式的时候，就在Front Matter里面加上`katex: true`即可。

&gt;   ps: 还是有一点问题，`\\`、`_`、`&lt;`这些符号还是不能直接使用，即使按照网上某些教程的说法，把渲染器改成mmark也不行，似乎也没有什么简洁的处理方法，只能在用的时候注意。

### 对主题的微调

这个主题并不是尽如人意，有些地方还是得自己调整，这是最花时间的。

首先是代码块的样式有点丑。这个主题使用了highlight.js进行代码高亮，但却没有禁用hugo自带的高亮，就会出来一些奇奇怪怪的问题，比如代码块的圆角之外会有黑角，因为hugo默认采用monokai作为高亮主题，背景是暗色的。在配置文件中加入以下片段来禁用hugo自带的高亮。

```toml
[markup]
  [markup.highlight]
    codeFences = false
    lineNos =  false
```

然后我几乎把所有元素的`border-radius`都改成了`0px`。（吐血

改动了footer和navbar，更符合我的喜好。

把字体替换成了Noto Sans SC，等宽字体替换成了Roboto Mono。用了Google Font。在`head.html`加入：

```html
&lt;link href=&quot;https://fonts.googleapis.com/css?family=Noto+Sans+SC|Noto+Serif+SC|Roboto+Mono&amp;display=swap&quot; rel=&quot;stylesheet&quot;&gt;
```

### 用Javascript自动替换插图路径

我习惯使用Typora作为markdown编辑器。当我把图片粘贴进来是，Typora就会把图片从剪贴板保存到`./${filename}`中，很方便，但是这样与hugo查找图片的方式冲突了。

为了方便，只好用Js。现学了一点js后，编写了以下代码。虽然此策不优雅，但是还算能用。

在`static/js`里面添加一个js文件：

```javascript
// replace image source
window.onload = function() {
    var imgs = this.document.getElementsByTagName(&#39;img&#39;);
    for (let i = 0; i &lt; imgs.length; i++) {
        var img = imgs[i];
        var temp_arr = img.src.split(&#39;/&#39;);
        var repl = &#39;&#39;;
        var flag = false;
        for(let j = 0;j &lt; temp_arr.length;j++) {
            if(j &gt;= 2 &amp;&amp; temp_arr[j-2] == &#39;posts&#39; &amp;&amp; temp_arr[j] == temp_arr[j-1]) {
                flag = true;
                continue;
            }
            repl = repl + temp_arr[j]
            if(j != temp_arr.length - 1) { 
                repl = repl + &#39;/&#39;;
            }
        }
        if(flag) {
            console.log(&#39;replace &#39; + img.src + &#39; to &#39; + repl);
            img.src = repl;
        }
    }
}
```

然后把它添加到配置文件的customJs中，即可。

### 其他

诸如替换头像、添加email图标之类的，此不再赘述，要么调配置，要么改主题模板。

## 部署

一开始先尝试了一下gitee pages，但是会出现莫名其妙的404问题。于是干脆搞到自己的云服务器上，用git部署。

### 搭建git服务器

参考下面的某条链接……由于是在ubuntu上弄，所以比较顺利。

大概就是：新建git用户，添加公钥，修改`/etc/passwd`，新建裸仓库。

### （半）自动部署

利用git钩子，如果愿意的话可以在服务器上装上hugo，然后自动构建、部署。但是我不想再装一次了。于是效法很多挂到github page的静态网页，分支`master` 专门管理源码，分支`gh-pages`专门管理构建好的网页。参考下面某条链接……

在要放网页文件的地方克隆`gh-pages`分支。然后在裸仓库的`hook`里面添加`post-update`文件，内容大致如下：

```sh
unset GIT_DIR
echo &quot;Hello!&quot;
DEPLOY_PATH=&quot;放网页的目录&quot;
cd $DEPLOY_PATH
git pull origin gh-pages
```

下次push时就会自动把网页拉到这里来了。

为了更自动化一些，本地也添加一个脚本`deploy.sh`。

```sh
hugo
cd public
git add .
git commit -m &quot;Update - `date +%Y-%m-%d`&quot;
cd ..
git push origin gh-pages
git add .
git commit -a
git push origin master
```

下次写完博文，直接

```sh
sh deploy.sh
```

或者双击脚本即可。

### 静态网站的搭建

使用nginx，此不赘述。

## 一些链接

-   安装hugo

    https://gohugo.io/getting-started/installing/

-   搭建git服务器

    https://www.liaoxuefeng.com/wiki/896043488029600/899998870925664

-   git钩子

    https://blog.csdn.net/u010837612/article/details/70825225

    https://git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-Git-%E9%92%A9%E5%AD%90

-   gh-pages

    https://gohugo.io/hosting-and-deployment/hosting-on-github/

&gt;   一些未解决也暂时懒得解决的问题：
&gt;
&gt;   -   about页面不显示头像
&gt;
&gt;   -   about页面内容不居中
&gt;   -   tasklist的checkbox前会有一点

        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        高数笔记
        
        </title>
        <url>////nth233.top/notes/高數筆記.html</url>
        <search-text>
        
        
            math
        
            高数
        
        
        
        陈年高数笔记
        
        
        
&gt; 很久之前的高数笔记，如今为了复习而放上来。也许会有大量错漏（就像我的其他blog一样），但我也懒得逐一校对纠正了。

# 高數筆記

## 極限

### 極限的性質

1. 唯一性
2. 保號性
3. 保序性

### 極限的計算

1. 其他

2. 等價無窮小替換

      ![doge](img/1.jpg)

3. 重要極限

4. L&#39;Hospital法則

5. Taylor公式

## 函數連續性

### 間斷點的分類

#### 第一類間斷點

1. 可去間斷點：**左右極限存在且相等，但是不等於函數值**或者函數在這點沒有定義。補充定義或者改變定義即可使函數連續。
2. 跳躍間斷點：**左右極限存在但是不相等**。

#### 第二類間斷點

1. 無窮間斷點
2. 震盪間斷點
3. ……

## 導數與微分

### 求導公式

$$
(\arcsin x)&#39; = \frac{1}{\sqrt{1-x^2}}
$$

$$
(\arccos x)&#39; = -\frac{1}{\sqrt{1-x^2}}
$$

$$
(\arctan{x})&#39; = \frac{1}{1+x^2}
$$

### 求導法則

鏈法則，複合函數求導法則，隱函數求導法則，對數求導法

#### 高階導數

- Leibniz公式：$(uv)^{(n)}=\sum^n_{k=0}C^k_n\cdot u^{(n-k)}v^{(k)}$
- 數學歸納法（通常不完全歸納法即可，不必太嚴謹）

### 微分中值定理

#### Fermat定理

對於可導函數，極值點一定是駐點。

證明方法：依據導數的定義，極值點左右導數分別大於等於0和小於等於0，於是極值點一定是駐點。

#### Rolle定理

閉區間上連續、開區間上可導，區間兩端函數值相等，則開區間內必有一點導數等於0。

證明方法：找出極大值或極小值，使用Fermat定理，在極值點導數爲0。

#### Lagrange中值定理

閉區間上連續，開區間上可導，則開區間內必有一點，在這點的導數等於區間端點連線的斜率。

證明方法：函數減去區間端點連線的直線方程，使用Rolle定理。
$$
f&#39;(\xi)(a-b)={f(a)-f(b)}
$$

&gt; Lagrange中值定理/Rolle定理的題目**構造函數的套路**：
&gt;
&gt; - 要證$xf&#39;(x)+nf(x)=0$，構造$F(x)=x^nf(x)$；
&gt;
&gt; - 要證$xf&#39;(x)-nf(x)=0$，構造$F(x)=\frac{f(x)}{x^n}$
&gt; -  要證$f&#39;(x)+\lambda f(x)=0$，構造$F(x)=e^{\lambda x} f(x)$
&gt; - 要證$f&#39;(x)+g&#39;(x)f(x)=0$，構造$F(x)=e^{g(x)}f(x)$

#### Cauchy中值定理

$$
\frac{f(a)-f(b)}{F(a)-F(b)} = \frac{f&#39;(\xi)}{F&#39;(\xi)}
$$

證明方法：作輔助函數
$$
\varphi(x)=f&#39;(x)-f(a)-\frac{f(b)-f(a)}{F(a)-F(b)}\cdot F&#39;(x)
$$
使用Rolle定理。

#### 題目收集

$$
  \frac{\alpha}{1+\alpha} &lt; \ln{(1+\alpha)} &lt; \alpha
$$

#### Taylor公式及餘項，Taylor中值定理

證明方法：使用$n$次Cauchy中值定理。

函數$n+1$階可導，則$x$和$x_0$之間存在一點，使
$$
f(x)=\sum^n_{i=0}\frac{f^{(n)}(x_0)}{n!}\cdot(x-x_0)^n+R_n(x)
$$
其中
$$
R_n(x) = \frac{f^{(n+1)}(\xi)}{(n+1)!} = o \left( (x-x_0)^n \right)
$$
$x_0=0$時，得Maclauring公式。

#### 常用Taylor公式

均爲$x\to0$

$$
\frac{1}{1-x}=\sum^n_{i=0}{x^i}+R_n(x)
$$

$$
 e^x = \sum^n_{i=0}{\frac{x^i}{i!}} + R_n(x)
$$

$$
 \ln x = \sum^n_{i=0}{(-1)^{i-1} \cdot\frac{x^i}{i}} + R_n(x)
$$

$$
 \sin x = \sum^{2n}_{i=1}{(-1)^{i-1}\cdot\frac{x^{2i-1}}{i!}} + R_n(x)
$$

$$
 \cos x = \sum^{2n}_{i=0}{(-1)^{i}\cdot\frac{x^{2i}}{i!}} + R_n(x)
$$

$$
(1+x)^p = 1+px+\frac{p(p-1)}{2!}x^2+\cdots+\frac{p(p-1)(p-2)(p-n+1)}{n!}x^n + R_n(x)
$$

### 凹凸性

考慮二階導數，證明過程使用Lagrange中值定理。

$f&#39;&#39;(x) &lt; 0$，則函數爲凸函數；$f&#39;&#39;(x)&gt;0$，則函數爲凹函數。（前提是$f&#39;&#39;(x)$存在，否則還是乖乖用$f&#39;(x)$的單調性來判別）。

凹凸形發生改變的點稱爲拐點，注意，拐點處不一定存在$f&#39;&#39;(x)$。

### 描繪函數圖形

1. 定義域，求一二階導數
2. 求出一二階導數爲0/不存在的點
3. 列表分析單調性和凹凸性
4. 漸近線
5. 描出關鍵點
6. 畫圖

#### 關於*斜漸進線*

由$\lim_{x\to\infty}[f(x)-a-b]$，得到$a=\lim_{x\to\infty}{\frac{f(x)}{x}}$，$b=\lim_{x\to\infty}{f(x)-ax}$

### 弧微分和曲率

$$
\mathrm{d} s = \sqrt{1+\left(\frac{\mathrm{d}y}{\mathrm{d}x}\right)^2} = \sqrt{(\mathrm{d}y)^2+(\mathrm{d}x)^2} = \sqrt{r^2+(r&#39;)^2}\mathrm{d}\theta
$$

#### 曲率公式

$$
k =\frac{1}{\rho} = \left|\frac{\mathrm{d}\alpha}{\mathrm{d}s}\right| = \frac{y&#39;&#39;&#39;}{\left[1+(y&#39;)^2\right]^{\frac{3}{2}}}
$$

若曲線由參數方程$\displaystyle \begin{cases}x = \phi(t)\\y=\psi(t)\end{cases}$給出，那麼相應有曲率公式：
$$
k = \frac{\left|\psi&#39;&#39;(t)\phi&#39;(t)-\phi&#39;&#39;(t)\psi&#39;(t)\right|}{\left[(\phi&#39;(t))^2+(\psi&#39;(t))^2\right]^{\frac{3}{2}}}
$$

## 不定積分

連續函數必然存在原函數，且其所有原函數相差一個常數。

### 積分表

這裏只列舉形式比較簡潔而且容易忘記的
$$
 \int\cos^2x\ \mathrm{d}x = \tan x + C
$$

$$
\int{\sec x\tan x}\ \mathrm{d}x = \sec x + C
$$

$$
\int{\tan x}\ \mathrm{d}x = -\ln{|\cos x|} + C
$$

$$
\int{\cot x}\ \mathrm{d}x = \ln{|\sin x|} + C
$$

$$
\int{\sec x}\ \mathrm{d}x = \ln{|\sec x+\tan x|} + C
$$

$$
\int{\csc x}\ \mathrm{d}x = \ln{|\csc x+\cot x|} + C
$$

$$
\int\frac{dx}{\sqrt{x^2\pm a^2}}=\ln{(x+\sqrt{x^2\pm a^2})}
$$

### 求不定積分

#### 第一類換元法

就是凑微分……

$\int\sin mx \cos nx \ \mathrm{d}x$考慮使用積化和差。

$\int \sin^mx\cos^nx \ \mathrm{d}x$考慮使用降冪公式。

!!! 關於分段函數的積分
    分段求積分，後使用連續函數的性質將兩段的任意常數關聯起來

#### 第二類換元法

設$f(x)$爲連續函數，$x=\varphi(x)$單調可導，且$\varphi(t)\ne0$，若$\int f(\varphi(t))\varphi&#39;(t) \ \mathrm{d}t = F(t) + C$，則$\int f(x) \ \mathrm{d}x = F(\varphi^{-1}(t)) + C$

具體而言，可以用來去掉根式。使用三角恆等式做一些三角換元。

也可以暴力使用根式代換。

分子分母次數相差超過1時，可以考慮倒代換。

#### 分部積分

$$
\int u \ \mathrm{d}v = uv - \int v\ \mathrm{d}u
$$

- 指三冪對反

- 注意循環式，如$\int e^{ax}\sin bx\ \mathrm dx$
- 可以用於建立遞推公式，比如$I_n=\int \sin^nx\ \mathrm dx$
- 不同函數類型乘積，則往往要用分部積分法

#### 有理函數積分

#### 分式

- 真分式，分母因式分解，可裂項爲四種部分分式，此略
- 使用多項式除法將假分式變爲整式與真分式的和
- 用冪函數法則直接積分

#### 三角函數有理式

- 萬能變換，使用萬能公式（設$t=\tan x$，則$\displaystyle\sin x = \frac{2t}{1+t^2}$，$\displaystyle\cos x=\frac{1-t^2}{1+t^2}$）
- 通過湊微分，變換爲同名三角函數的有理式

### “簡單”無理函數

1. 形如$\int R(x, \sqrt[n]{ax+b}) \mathrm dx$，則設$t = \sqrt[n]{ax+b}$
2. 形如$\int R(x, \sqrt[n]{\frac{ax+b}{cx+d}}) \mathrm dx$，則設$t = \sqrt[n]{\frac{ax+b}{cx+d}}$
3. 對於形如$\int\frac{dx}{(mx+n)\sqrt{ax^2+bx+c}}$的式子，考慮使用倒代換（$t = \frac{1}{x}$）
4. 乖乖查表

## 定積分

### 計算

#### 定義

$$
\int^a_bf(x)dx = \lim_{\lambda\to0}\sum^n_{i=1}{f(\xi_i)\Delta x_i}
$$

通常利用定義求定積分的時候採用等分區間的方法，比較簡單，否則十分反人類。

#### 性質

- 線性
- 矩形性
- 區間可加性
- 保號性（區間上$f(x) \ge 0$，則$\int^a_bf(x)dx\ge0$；推論：$\left|\int^a_bf(x)dx\right| \le \int^a_b\left|f(x)dx\right|$）
- 估值定理（$m(b-a)=\int^b_amdx\le\int^b_af(x)dx\le\int^b_aMdx=M(b-a)$）
- 積分中值定理（$\exists \xi\in[a,b]$，使$\int^b_af(x)dx=f(\xi)(b-a)$）

利用以上性質，可以比較定積分的大小。

####  微積分基本定理（Newton-Leibniz公式）

##### 第一基本定理：變上限積分

$\Phi(x)=\int^x_af(t)dt$，則$\Phi&#39;(x) = f(x)$

##### 第二基本定理：Newton-Leibniz公式

$\int^b_af(x)dx=F(b)-F(a)=F(x)|^b_a$

#### 其他方法

定積分的換元法、分部積分公式……

注意對稱區間上，奇函數定積分永遠是0

### 應用

#### 求面積

直角座標下沒什麼好說的：$\int^b_a[g(x)-f(x)]dx = A$

極座標下利用$S = \frac{1}{2}r^2\theta$的“擴展”：$\displaystyle A = \frac{1}{2}\int^b_ar^2(\theta)d\theta$

對於參數方程給出的曲線來說，一般而言，按照順時針方向設定上下限；規定曲線的正向爲：不管怎麼走，**曲邊梯形總在右手邊**。

##### 例子

求雙紐線（$r^2=a^2\cos{2\theta}$）圍成圖形的面積。

#### 求弧長

$$
s = \int_{?}^{?}ds = \int^?_?\sqrt{dx^2+dy^2}=\int_a^b\sqrt{1+(y&#39;)^2}dx
$$

極座標下，又有：
$$
s = \int_\alpha^\beta\sqrt{r^2(\theta)+(r&#39;(\theta))^2}d\theta
$$

##### 例子

求星形線$\displaystyle x^{\frac{3}{2}}+y^{\frac{3}{2}}=a^{\frac{3}{2}} \ (a&gt;0)$的全長和圍成的面積。（提示：寫成參數方程）

#### 求體積

1. 常規方法（還有平行截面已知的立體圖形）
1. 柱殼法（旋轉體）

## 反常積分

1. 無窮區間積分
2. 瑕積分

- 定義：把無限化爲有限，然後求極限
- 廣義積分的Newton-Leibniz公式
- $\Gamma$函數：$\Gamma(n) = n!$，$\Gamma(1/2)=\sqrt{\pi}$

##### 簡單的例子

- 求$\int^1_0\ln x\ dx$
- 求$\int_0^a\frac{dx}{\sqrt{a^2-x^2}}\ (a&gt;0)$


## 常數項級數

#### 級數的斂散性

若$\lim_{n\to\infty}S_n = S$，則稱級數收斂，否則級數發散

級數的餘項$r_n = S - S_n$，收斂級數的餘項滿足$\lim_{n\to\infty}r_n =0$

#### 常數項級數的基本性質

1. 若級數$\sum_{n=1}^{\infty}u_n$收斂，則$\sum_{n=1}^{\infty}ku_n$也收斂，$k$爲任意常數，和也變成$k$倍
2. 兩個級數分別收斂，**它們的和所成級數也收斂**，即兩個級數可以逐項相加或相減
3. 把級數**加上或去掉有限項**不改變級數的收斂性
4. 如果級數**收斂**，對該級數**加括號**所成級數也收斂
5. 如果級數收斂，則**一般項極限爲0**

### 正項級數審斂法

#### 比較審斂法

- 一般形式
- 極限形式：若$\lim_{n\to\infty}\frac{u_n}{v_n} = l$，則兩個級數斂散性相同……

#### 比值審斂法（D&#39;Alember）

設 $\sum_{n=1}^{\infty}u_n$爲正項級數，且有$\lim_{n\to\infty}\frac{u_n}{v_n}=\rho$，若$\rho &lt; 1$，則級數收斂……

證明方法涉及到與等比級數比較。

#### 根值審斂法（Cauchy）

  設 $\sum_{n=1}^{\infty}u_n$爲正項級數，且有$\lim_{n\to\infty}\sqrt[n]{u_n}=\rho$，若$\rho &lt; 1$，則級數收斂……

  證明方法涉及到與等比級數比較。

#### 幾個重要級數

  - 調和級數
  - p級數（$\sum^{\infty}_{n=0}n^{-p}$，$p&gt;1$時收斂，否則發散）「證法：先證調和，後比較審斂」
  - 等比級數

### 交錯級數和任意項級數

#### Leibniz定理：

交錯級數的一般項單調且趨於0，則級數收斂

證明過程使用了單調有界準則，奇偶分別判斷

#### 絕對收斂定理

加絕對值之後收斂爲絕對收斂，絕對收斂則一定收斂

證明過程構造了一個新級數，十分巧妙。（$\displaystyle v_n = \frac{u_n + |u_n|}{2}$）

&gt; 如果不絕對收斂，還可能條件收斂，那麼只能使用Leibniz定理。
&gt;
&gt; Leibniz定理只適用於交錯級數……
&gt;
&gt; 若$\lim_{n\to\infty}\left|u_n\right| = \infty$，則原級數一定發散

## 函數項級數

&gt; 約定，如果級數的$n$初始值不重要，那麼就省略不寫……

**在收斂域上**，函數項級數$\sum^{\infty}_{n=1}u_n(x)$的和是$x$的函數，記爲$S(x)$，稱爲級數的和函數。

### 冪級數

&gt; 生成函數有一堆騷操作。——讀《應用組合數學》有感

#### 關於收斂半徑

##### Abel定理

對於級數$\sum^{\infty}_{n=0}a_nx^n$：

1. 若在$x_0$收斂，則對於滿足不等式$|x|&lt;|x_0|$的一切$x$收斂
2. 若在$x_0$發散，則對於滿足不等式$|x| &gt; |x_0|$的一切$x$ 發散

證明構造了一個等比級數，證明結論1，後使用反證法，證明了結論2。

##### 推論和相關的定義

由Abel定理可以推出，冪級數要麼只在$x=0$收斂，要麼處處收斂，要麼在一個實數“以內”收斂。

由是定義**收斂半徑**$R$和**收斂區間**$(-R,R)$。

&gt; 需注意，收斂區間不是收斂域，收斂區間去掉了端點

##### 求收斂半徑

對於冪級數$\sum^{\infty}_{n=0}a_n x^n$，設它的收斂半徑是$R$，那麼

如果$\displaystyle\lim_{x\to\infty}\left|\frac{a_{n+1}}{a_{n}}\right|=\rho$，則$R=1/\rho$

&gt; $\rho$可以是$0$或$\infty$，即無窮小或無窮大。

#### 冪級數的運算性質

加減乘&lt;del&gt;除&lt;/del&gt;，其中乘法有一點複雜，跟卷積有點關係。

$$
\sum a_nx^n \cdot\sum b_nx^n = \sum c_nx^n
$$

$\{c_n\}$就是$\{a_n\}$和$\{b_n\}$的卷積，即$c_n = \sum^n_{i=0}a_ib_{n-i}$。

&gt;  收斂級數的和差積的收斂半徑可能比原先大。

#### 冪級數的和函數性質

$S(x) = \sum^{\infty}_{n=0}a_nx^{n}$

1. 連續性
2. 逐項求導，$S&#39;(x) = \sum^{\infty}_{n=1}na_nx^{n-1}$，注意$n$的取值
3. 逐項積分，$\int^x_0S(x)\ \mathrm{d}x=\sum^{\infty}_{n=0}\frac{a_n}{n+1}x^{n+1}$，注意上下限

##### 兩道題

都是想方設法變成等比級數，用上求導和積分，不過其中可能會涉及一些技巧。

1. 求級數$\sum^{\infty}_{n=1}\frac{x^n}{n\cdot3^n}$的和函數
2. 求$\sum^{\infty}_{n=1}n(n+1)\cdot2^{-n}$

### 兩個重要的函數展開

&gt; 似乎對於考試而言不是那麼重要

#### Taylor級數

首先需要注意，泰勒級數未必收斂，收斂也未必收斂於原來的函數。要收斂於原來的函數，需要一定條件，即餘項趨於0:
$$
\lim_{n\to \infty}R_n(x) = 0 \ (x\in U(x_0))
$$

&gt; 倪皖湘：不收斂/不收斂於原來的函數是少數情況，我們作業和考試的答案基本沒有驗證是否收斂於原來的函數，所以我們統一不用驗證。

##### Newton二項展開式

注意和**二項式定理**區別開，這個公式可以視爲是對二項式定理的擴展
$$
f(x)=(1+x)^\alpha=1+\alpha x+\frac{\alpha(\alpha-1)}{2!}x^2+\cdots+\frac{\alpha(\alpha-1)(\alpha-2)\cdots(\alpha-n+1)}{n!}x^n
$$

##### 一道題

將$\ln{(x+\sqrt{1+x^2})}$展開成冪級數。

&gt; 歐拉公式：$e^{i\theta} = \cos\theta+i\sin\theta$，$\displaystyle \cos\theta=\frac{e^{i\theta}+e^{-i\theta}}{2}$，sin如法炮製

#### Fourier級數

三角函數正交系


        
        </search-text>
    </page>
    
    
    
    <page>
        <title>
        
        自制MC启动器的失败尝试
        
        </title>
        <url>////nth233.top/posts/2019-02-17-mclauncher.html</url>
        <search-text>
        
        
            minecraft
        
            折腾记录
        
        
        
        本打算在寒假重拾MC，却突然发现HMCL在arch上用不了了，明明18年八月初还是可以用的。打开HMCL后ui无法被正常渲染，只有空白窗口一个。疑似是arch的锅，也可能是openjfx的bug（但是我就算是换用oracle的jdk问题也依然存在，并且就算是一路回退到2018年七月的版本，问题也依然没有解决）。于是便再次将自制MC启动器提上日程，作为六月前的最后一次在电脑上的折腾。
        
        
        

本打算在寒假重拾MC，却突然发现HMCL在arch上用不了了，明明18年八月初还是可以用的。打开HMCL后ui无法被正常渲染，只有空白窗口一个。疑似是arch的锅，也可能是openjfx的bug（但是我就算是换用oracle的jdk问题也依然存在，并且就算是一路回退到2018年七月的版本，问题也依然没有解决）。于是便再次将自制MC启动器提上日程，作为六月前的最后一次在电脑上的折腾。

这不是我第一次尝试自制MC启动器，三四年前不会用HMCL的时候也想过自己做一个。但是当时连MC为什么要用启动器都不知道，自制启动器一直停留在「想法」阶段。

上网查了一些MC启动器相关的东西，算是大致了解了一下MC启动器的原理。但是网上的很多博文对具体的细节语焉不详，还得自己翻HMCL或者JMCCC的源代码慢慢理解。

-----

## MC启动器的原理

简而言之，启动器的工作就是列出一堆option，生成启动脚本，然后用脚本启动MC。

### 为什么MC需要启动器？

按照[BMCL作者的说法](https://www.zhihu.com/question/49997128/answer/119951802)，MC需要启动器的原因大致有几点：

1. MC启动需要传入JVM参数、游戏参数、列出主类依赖的jar包等等，启动脚本很长，不适合手打。
2. 管理资源文件，比如声音、语言。
3. 正版登录以及验证。
4. 版本管理。
5. 依赖管理。
6. 额外的功能，比如下载MC、Forge或Optifine，放置新闻...

### MC的目录结构

举个例子：

```
.minecraft/
	assets/
		indexes/                 // 里面有一些以版本号命名的json
		objects/                 // 里面都是乱七八糟的东西
	libraries/                 // 里面是MC运行所依赖的jar包，按照包名建好了一层一层的文件夹
	logs/                      // 顾名思义，都是日志文件 
	resourcepacks/             // 顾名思义，都是资源包，也叫材质包
	saves/                     // 顾名思义，里面放存档
	screenshots/               // 顾名思义，里面放截屏
	versions/                  // 放置不同版本的minecraft主程序
		1.7.2/
			1.7.2.jar              // 1.7.2版本的minecraft主程序
			1.7.2.json             // 列出了所依赖的jar包及其下载地址。这些jar包在libraries中可找到
		1.7.10/
			1.7.10.jar
			1.7.10.json
	options.txt                // minecraft游戏的具体设置，比如鼠标灵敏度、键盘控制等等
	usercache.json             // 玩家信息的缓存，内含游戏名、uuid、最后登陆时间
```

### 启动参数说明

下面这个启动脚本是由HMCL在windows下生成的。我把`\`都换成了`/`

```bat
@echo off
set appdata=F:\MC\Minecraft 1.10.2-Forge\.minecraft
&quot;C:/Program Files/Java/jre1.8.0_73/bin/javaw.exe&quot; 
-XX:HeapDumpPath=MojangTricksIntelDriversForPerformance_javaw.exe_minecraft.exe.heapdump 
-XX:+UseG1GC 
-XX:-UseAdaptiveSizePolicy 
-XX:-OmitStackTraceInFastThrow 
-Xmn128m 
-Xmx512m 
&quot;-Djava.library.path=F:/MC/Minecraft 1.10.2-Forge/.minecraft/versions/1.10/1.10-natives&quot; 
-Dfml.ignoreInvalidMinecraftCertificates=true 
-Dfml.ignorePatchDiscrepancies=true 
-cp &quot;F:/MC/Minecraft 1.10.2-Forge/.minecraft/libraries/com/mojang/netty/1.6/netty-1.6.jar;F:/MC/Minecraft 1.10.2-Forge/.minecraft/libraries/oshi-project/oshi-core/1.1/oshi-core-1.1.jar;F:/MC/Minecraft 1.10.2-Forge/.minecraft/libraries/net/java/dev/jna/jna/3.4.0/jna-3.4.0.jar;F:/MC/Minecraft 1.10.2-Forge/.minecraft/libraries/net/java/dev/jna/platform/3.4.0/platform-3.4.0.jar;F:/MC/Minecraft 1.10.2-Forge/.minecraft/libraries/com/ibm/icu/icu4j-core-mojang/51.2/icu4j-core-mojang-51.2.jar;F:/MC/Minecraft 1.10.2-Forge/.minecraft/libraries/net/sf/jopt-simple/jopt-simple/4.6/jopt-simple-4.6.jar;F:/MC/Minecraft 1.10.2-Forge/.minecraft/libraries/com/paulscode/codecjorbis/20101023/codecjorbis-20101023.jar;F:/MC/Minecraft 1.10.2-Forge/.minecraft/libraries/com/paulscode/codecwav/20101023/codecwav-20101023.jar;F:/MC/Minecraft 1.10.2-Forge/.minecraft/libraries/com/paulscode/libraryjavasound/20101123/libraryjavasound-20101123.jar;F:/MC/Minecraft 1.10.2-Forge/.minecraft/libraries/com/paulscode/librarylwjglopenal/20100824/librarylwjglopenal-20100824.jar;F:/MC/Minecraft 1.10.2-Forge/.minecraft/libraries/com/paulscode/soundsystem/20120107/soundsystem-20120107.jar;F:/MC/Minecraft 1.10.2-Forge/.minecraft/libraries/io/netty/netty-all/4.0.23.Final/netty-all-4.0.23.Final.jar;F:/MC/Minecraft 1.10.2-Forge/.minecraft/libraries/com/google/guava/guava/17.0/guava-17.0.jar;F:/MC/Minecraft 1.10.2-Forge/.minecraft/libraries/org/apache/commons/commons-lang3/3.3.2/commons-lang3-3.3.2.jar;F:/MC/Minecraft 1.10.2-Forge/.minecraft/libraries/commons-io/commons-io/2.4/commons-io-2.4.jar;F:/MC/Minecraft 1.10.2-Forge/.minecraft/libraries/commons-codec/commons-codec/1.9/commons-codec-1.9.jar;F:/MC/Minecraft 1.10.2-Forge/.minecraft/libraries/net/java/jinput/jinput/2.0.5/jinput-2.0.5.jar;F:/MC/Minecraft 1.10.2-Forge/.minecraft/libraries/net/java/jutils/jutils/1.0.0/jutils-1.0.0.jar;F:/MC/Minecraft 1.10.2-Forge/.minecraft/libraries/com/google/code/gson/gson/2.2.4/gson-2.2.4.jar;F:/MC/Minecraft 1.10.2-Forge/.minecraft/libraries/com/mojang/authlib/1.5.22/authlib-1.5.22.jar;F:/MC/Minecraft 1.10.2-Forge/.minecraft/libraries/com/mojang/realms/1.9.0/realms-1.9.0.jar;F:/MC/Minecraft 1.10.2-Forge/.minecraft/libraries/org/apache/commons/commons-compress/1.8.1/commons-compress-1.8.1.jar;F:/MC/Minecraft 1.10.2-Forge/.minecraft/libraries/org/apache/httpcomponents/httpclient/4.3.3/httpclient-4.3.3.jar;F:/MC/Minecraft 1.10.2-Forge/.minecraft/libraries/commons-logging/commons-logging/1.1.3/commons-logging-1.1.3.jar;F:/MC/Minecraft 1.10.2-Forge/.minecraft/libraries/org/apache/httpcomponents/httpcore/4.3.2/httpcore-4.3.2.jar;F:/MC/Minecraft 1.10.2-Forge/.minecraft/libraries/it/unimi/dsi/fastutil/7.0.12_mojang/fastutil-7.0.12_mojang.jar;F:/MC/Minecraft 1.10.2-Forge/.minecraft/libraries/org/apache/logging/log4j/log4j-api/2.0-beta9/log4j-api-2.0-beta9.jar;F:/MC/Minecraft 1.10.2-Forge/.minecraft/libraries/org/apache/logging/log4j/log4j-core/2.0-beta9/log4j-core-2.0-beta9.jar;F:/MC/Minecraft 1.10.2-Forge/.minecraft/libraries/org/lwjgl/lwjgl/lwjgl/2.9.4-nightly-20150209/lwjgl-2.9.4-nightly-20150209.jar;F:/MC/Minecraft 1.10.2-Forge/.minecraft/libraries/org/lwjgl/lwjgl/lwjgl_util/2.9.4-nightly-20150209/lwjgl_util-2.9.4-nightly-20150209.jar;F:/MC/Minecraft 1.10.2-Forge/.minecraft/versions/1.10/1.10.jar&quot; net.minecraft.client.main.Main 
--username nothing 
--version &quot;HMCL 2.5.1.79&quot; 
--gameDir &quot;F:/MC/Minecraft 1.10.2-Forge/.minecraft&quot; 
--assetsDir &quot;F:/MC/Minecraft 1.10.2-Forge/.minecraft/assets&quot; 
--assetIndex 1.10 
--uuid 3e47b75000b0924b6c9ba5759a7cf15d 
--accessToken 3e47b75000b0924b6c9ba5759a7cf15d 
--userType Legacy 
--versionType &quot;HMCL 2.5.1.79&quot; 
--height 480 
--width 854
```

linux下脚本可能会像这样（我用上面的手改的，因为有些依赖似乎与系统相关，所以不知道还能不能用）。`~`应该换成别的，比如`/home/username`。

```shell
/usr/bin/java
-XX:+UseG1GC 
-XX:-UseAdaptiveSizePolicy 
-XX:-OmitStackTraceInFastThrow 
-Xmn128m
-Xmx1024m 
-Djava.library.path=~/.minecraft/versions/1.10/1.10-natives
-Dfml.ignoreInvalidMinecraftCertificates=true 
-Dfml.ignorePatchDiscrepancies=true 
-cp &quot;~/.minecraft/libraries/com/mojang/netty/1.6/netty-1.6.jar;~/.minecraft/libraries/oshi-project/oshi-core/1.1/oshi-core-1.1.jar;~/.minecraft/libraries/net/java/dev/jna/jna/3.4.0/jna-3.4.0.jar;~/.minecraft/libraries/net/java/dev/jna/platform/3.4.0/platform-3.4.0.jar;~/.minecraft/libraries/com/ibm/icu/icu4j-core-mojang/51.2/icu4j-core-mojang-51.2.jar;~/.minecraft/libraries/net/sf/jopt-simple/jopt-simple/4.6/jopt-simple-4.6.jar;~/.minecraft/libraries/com/paulscode/codecjorbis/20101023/codecjorbis-20101023.jar;~/.minecraft/libraries/com/paulscode/codecwav/20101023/codecwav-20101023.jar;~/.minecraft/libraries/com/paulscode/libraryjavasound/20101123/libraryjavasound-20101123.jar;~/.minecraft/libraries/com/paulscode/librarylwjglopenal/20100824/librarylwjglopenal-20100824.jar;~/.minecraft/libraries/com/paulscode/soundsystem/20120107/soundsystem-20120107.jar;~/.minecraft/libraries/io/netty/netty-all/4.0.23.Final/netty-all-4.0.23.Final.jar;~/.minecraft/libraries/com/google/guava/guava/17.0/guava-17.0.jar;~/.minecraft/libraries/org/apache/commons/commons-lang3/3.3.2/commons-lang3-3.3.2.jar;~/.minecraft/libraries/commons-io/commons-io/2.4/commons-io-2.4.jar;~/.minecraft/libraries/commons-codec/commons-codec/1.9/commons-codec-1.9.jar;~/.minecraft/libraries/net/java/jinput/jinput/2.0.5/jinput-2.0.5.jar;~/.minecraft/libraries/net/java/jutils/jutils/1.0.0/jutils-1.0.0.jar;~/.minecraft/libraries/com/google/code/gson/gson/2.2.4/gson-2.2.4.jar;~/.minecraft/libraries/com/mojang/authlib/1.5.22/authlib-1.5.22.jar;~/.minecraft/libraries/com/mojang/realms/1.9.0/realms-1.9.0.jar;~/.minecraft/libraries/org/apache/commons/commons-compress/1.8.1/commons-compress-1.8.1.jar;~/.minecraft/libraries/org/apache/httpcomponents/httpclient/4.3.3/httpclient-4.3.3.jar;~/.minecraft/libraries/commons-logging/commons-logging/1.1.3/commons-logging-1.1.3.jar;~/.minecraft/libraries/org/apache/httpcomponents/httpcore/4.3.2/httpcore-4.3.2.jar;~/.minecraft/libraries/it/unimi/dsi/fastutil/7.0.12_mojang/fastutil-7.0.12_mojang.jar;~/.minecraft/libraries/org/apache/logging/log4j/log4j-api/2.0-beta9/log4j-api-2.0-beta9.jar;~/.minecraft/libraries/org/apache/logging/log4j/log4j-core/2.0-beta9/log4j-core-2.0-beta9.jar;~/.minecraft/libraries/org/lwjgl/lwjgl/lwjgl/2.9.4-nightly-20150209/lwjgl-2.9.4-nightly-20150209.jar;~/.minecraft/libraries/org/lwjgl/lwjgl/lwjgl_util/2.9.4-nightly-20150209/lwjgl_util-2.9.4-nightly-20150209.jar;~/.minecraft/versions/1.10/1.10.jar&quot; 
net.minecraft.client.main.Main 
--username nth233 
--version &quot;HMCL 2.5.1.79&quot; 
--gameDir &quot;~/.minecraft&quot; 
--assetsDir &quot;~/.minecraft/assets&quot; 
--assetIndex 1.10 
--uuid 3e47b75000b0924b6c9ba5759a7cf15d 
--accessToken 3e47b75000b0924b6c9ba5759a7cf15d 
--userType Legacy 
--versionType &quot;HMCL 2.5.1.79&quot; 
--height 480 
--width 854
```

我们来大致分析一下启动脚本。`/usr/bin/java`是完整的java路径。

然后是一串JVM参数，比如`-Xmn128m`指定了最小内存，`-Xmx1024m`指定了最大内存，`-Djava.library.path=~/.minecraft/versions/1.10/1.10-natives`指明了natives文件夹的位置。`-XmsXXXm`指定了初始堆的大小。不知道开头那三行有什么用...

接下来以`-Dfml`开头的两行是让forge忽略自身文件被修改，否则无法兼容optifine。

接下来是以`-cp`开头的「一行」，很长，列出了所有MC依赖的jar包（其中就包含了声音、领域、twitch等一堆东西）。 可以从MC主程序旁边的那个同名`json`里获得它们的下载地址和应放置的位置。

再接下来的一行`net.minecraft.client.main.Main `是主类。

再接下来的一堆是游戏参数，包括了游戏主目录`.minecraft`的位置、MC版本、uuid、令牌、启动器版本以及游戏窗口的长宽、是否全屏（`--fullscreen`，上面的脚本没有体现）等等。

### 粗略的启动过程

0. 获取java路径、下载MC
1. 根据用户的设置，生成启动脚本
2. 启动MC
3. 还可以监视MC的进程（不是很懂，不是非常确定是不是这个功能）

----

## 具体的尝试过程

先是花了三天时间分析HMCL的源码。不知道为什么，我这里vscode装了java扩展后依然无法使用「转到定义」等功能，于是一些本来应该由IDE/编辑器自动完成的事情变成要我人肉手动完成，十分蛋疼。花了一堆时间解决诸如「`gameDir`是哪个文件夹？」、「`versionDir`是哪个文件夹？」这类问题。我记得我第一天看代码看得差点睡着（事实证明，看别人的代码对我这种菜鸡来说可以算是催眠法宝之一）。在HMCL的代码里绕了三天后，总算是自己搞出了一个启动脚本（人肉编译执行2333）。但是，无论我怎么修改，这个启动脚本都没法启动MC。原因似乎是MC没有下载「完整」（缺少natives文件夹）。好吧，我又花了一个小时左右的时间**手动**下载natives里的内容，**手动**按照包名一层层建文件夹，置入依赖的jar包，然而最终还是没有成功。

自制启动器的尝试到这里算是基本失败了。

但是，我又找到了JMCCC。JMCCC的代码比HMCL的「整洁」，再加上之前阅读HMCL代码的经验，看JMCCC的代码比看HMCL的快多了。由于担心JMCCC的脚本不兼容HMCL的目录结构，所以还得重新下载MC。到这里我已经彻底放弃了，按照JMCCC的代码再做一回人肉编译器，重新下载MC，还不如直接调用JMCCC。

好吧，调用JMCCC。完全按照教程，用java调用JMCCC「自制」了一个启动器（simplelauncher）。先是建立项目，把maven依赖添加到`pom.xml`，复制JMCCC项目`README.md`里面的示例代码，稍微改一改：用几十行代码下载MC，用几行代码启动MC。在eclipse里一运行，居然真的启动了MC的1.7.10版本。然后又尝试了几个版本，屡试不爽。当然这个时候心情自然是非常爽。

编译的时候由于不了解java又踩了一些坑。本来想直接把`class`文件拿来用，但很快我发现我这个启动器需要另一个「启动器的启动器」来启动，实在是滑稽。后来查到可以编译成可执行jar包。于是又往`pom.xml`里面添了几行，编译出可执行jar包。又大致给这个启动器添加几个启动选项后，这个「自制的」simplelauncher终于到了「能用」的层级。不过操作依然非常傻：双击，则默认从`~/.minecraft`启动1.7.10版本。要启动其他版本，或者要下载MC，必须在命令行里面`java -jar sl.jar [ --version ${version} ] [ --download ]`。还是有点蛋疼，不过我已经懒得再改了，也懒得玩MC了。

## 一些链接

[《 Minecraft 》为什么要以启动器的形式启动？](https://www.zhihu.com/question/49997128)

[JMCCC使用教程——Java启动器类库，几行代码下载并启动MC](http://www.MCbbs.net/thread-573154-1-1.html)
[Hello Minecraft! Launcher](https://github.com/huanghongxun/HMCL/)
[JMCCC](https://github.com/to2mbn/JMCCC)
[JMCCC使用教程](https://github.com/yushijinhun/jMCcc.tutorial)
[How can I create an executable JAR with dependencies using Maven?](https://stackoverflow.com/questions/574594/how-can-i-create-an-executable-jar-with-dependencies-using-maven)
[[Why do JVM arguments start with “-D”?](https://stackoverflow.com/questions/44745261/why-do-jvm-arguments-start-with-d)](https://stackoverflow.com/questions/44745261/why-do-jvm-arguments-start-with-d)
[JVM系列三:JVM参数设置、分析](http://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html)
[Tuning Garbage Collection with the 5.0 Java Virtual Machine](https://www.oracle.com/technetwork/java/gc-tuning-5-138395.html)
[Guide to the Most Important JVM Parameters](https://www.baeldung.com/jvm-parameters)

        
        </search-text>
    </page>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
</site>
