<!DOCTYPE html>

<html>
    <head>
        
        <title>Empty Space - TCP拥塞控制</title>
        
        <meta charset="UTF-8">
        <meta content="width=device-width, initial-scale=1, viewport-fit=cover" name="viewport">

        
        <meta name="description" content="关于TCP的拥塞控制。本文简要概述了为何要引入拥塞控制，拥塞控制面临的问题，以及TCP拥塞控制相关的标准。">
        

        
        <meta name="keywords" content="computer,计算机网络,TCP/IP">
        

        <link rel="stylesheet" href="//nth233.top/assets/style/main.css">
        <link rel="stylesheet" href="//nth233.top/assets/style/tango.css">
        <link rel="stylesheet" href="//nth233.top/assets/style/katex.min.css" integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ" crossorigin="anonymous">

        
        
        <link rel="apple-touch-icon" sizes="180x180" href="//nth233.top/assets/favicon/apple-touch-icon.png">
        <link rel="icon" type="image/png" sizes="32x32" href="//nth233.top/assets/favicon/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="//nth233.top/assets/favicon/favicon-16x16.png">
        <link rel="manifest" href="//nth233.top/assets/favicon/site.webmanifest">
        
    </head>
    <body>
        <header>

<div class="header-logo">
    <img class="nth233logo" src="//nth233.top/assets/img/404.png"></img>
    <a href="//nth233.top/">Empty Space</a>
</div>

<div class="header-menu">
    <a href="//nth233.top/notes/">Notes</a>
    <a href="//nth233.top/about/">About</a>
    <a href="//nth233.top/feed.xml">RSS</a>
    <!--<a href="//nth233.top/friends.html">Friends</a>-->
    <div id="theme-switch" title="夜幕降临">🌒</button>
</div>

</header>

        <main>
            
<div class="post-area">
<div class="post-front-matter">
    
    <h1>TCP拥塞控制</h1>
    
    <div class="date-bar">
        <span class="date">2022-04-25</span>
    </div>
    <div class="category-bar">
    
        <span class="category">〔note〕</span>
    
    </div>
    <div class="tag-bar">
    
        <span class="tag">#computer</span>
    
        <span class="tag">#计算机网络</span>
    
        <span class="tag">#TCP/IP</span>
    
    </div>
</div>
<hr class="hr-wavy">
<div class="post-content">
    <h2 id="为何要引入拥塞控制">为何要引入拥塞控制</h2>
<p>首先，如果不进行拥塞控制，控制各个发送端发包的速度，那么网络将拥挤不堪，各方都难以成功发送消息。并且仅仅在网络层控制拥塞是治标不治本的，因为拥塞的根源在于发送端过快的发送速度，给网络层带来巨大负担。</p>
<p>其次，即使引入了流量控制，网络拥塞的问题依然没有得到根本解决。</p>
<p>流量控制和拥塞控制目的不同。流量控制中的窗口反映了接受端的接收能力，但是并没有反映网络的容量，而发送端的发送量应该同时受二者控制。</p>
<h2 id="拥塞控制的基本原理">拥塞控制的基本原理</h2>
<p>原理：接收方ACK〔应答〕的速率反映了网络传输能力，发送方可以据此控制发送速率。</p>
<p>以下内容假设发送的“包”长度都等于MSS〔最大报文段长度〕。</p>
<p>我们假设网络的容量是当前数据传输的瓶颈（也就是网络传输能力低于发送端的发送能力，也低于接受端的接收能力，此时便是拥塞控制应该发挥作用的时候）。发送端每秒发送<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>个包，接收端每秒接收<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>个包，网络层每秒传输却只能传输<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>个包，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>&lt;</mo><mi>n</mi><mo>&lt;</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">m &lt; n &lt; k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>。</p>
<p>如果发送端每秒发出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>个包，经过网络层之后，接收方每秒也只能接收到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>个包。接收每收到一个包，就发回一个ACK，所以发送端每秒收到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>个ACK。因此发送方可以知道网络当前的容量是每秒钟<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>个包。调整发送速率到每秒<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>个包，就算是进行了拥塞控制。</p>
<blockquote>
<p>滑动窗口反映了接收方的接收能力，因此发送方可以知道现在的传输瓶颈究竟是网络传输能力，还是接收方的接收能力。</p>
</blockquote>
<h2 id="拥塞控制的难题">拥塞控制的难题</h2>
<p>和TCP计时器控制一样，协议必须面对多变的网络环境。网络传输能力时时刻刻都在发生变化，因此拥塞控制必须动态地适应这一变化，及时“收敛”到最佳的发送速度上去。这便是TCP拥塞控制要解决的问题。</p>
<h2 id="tcp的拥塞控制">TCP的拥塞控制</h2>
<blockquote>
<p>这部分内容在<a href="https://www.rfc-editor.org/rfc/rfc2581.html">RFC
2851</a>有详细、清晰的说明，我只是RFC的搬运工罢了。RFC的讲解比很多教材清晰明了，建议阅读。</p>
</blockquote>
<p>拥塞控制涉及到4个关键的算法：慢开始，拥塞避免，快速重传，快速恢复。</p>
<p>涉及一些定义：</p>
<ol type="1">
<li><code>SMSS</code>：发送方最大报文段长度</li>
<li><code>IW</code>：初始拥塞窗口大小，三次握手之后使用这个作为拥塞窗口的初值</li>
<li><code>FlightSize</code>：已经发出但是未应答的包的个数</li>
</ol>
<p>涉及几个关键的状态变量：</p>
<ol type="1">
<li><code>cwnd</code>：拥塞窗口大小。不同实现方式中含义不同，有的按「全长包」的个数计算，有的按字节数计算</li>
<li><code>rwnd</code>：接收方的窗口大小</li>
<li><code>ssthresh</code>：决定「慢开始」算法和「拥塞避免」算法的选用</li>
</ol>
<h3 id="慢开始和拥塞避免">慢开始和拥塞避免</h3>
<p>首先，设置<code>cwnd</code>初值为<code>IW</code>，<code>ssthresh</code>初值为一个任意大的值。然后进入慢开始阶段。</p>
<h4 id="慢开始阶段">慢开始阶段</h4>
<p>慢开始阶段，每收到一个ACK，便让<code>cwnd</code>至多增加<code>SMSS</code>。如果按「全长包个数」计算，就是加一。</p>
<p>慢开始算法一点也不“慢”。考虑上述算法的表现，慢开始阶段，每个RTT〔往返时间〕<code>cwnd</code>都倍增一次。当<code>cwnd</code>大于或者等于<code>ssthresh</code>的时候，进入拥塞避免阶段。</p>
<blockquote>
<p>在<code>cwnd</code>和<code>ssthresh</code>相等的时候，标准并没有规定用哪一算法，因此取决于具体的TCP实现。</p>
</blockquote>
<h4 id="拥塞避免阶段">拥塞避免阶段</h4>
<p>拥塞避免阶段，每个RTT内<code>cwnd</code>增加<code>SMSS</code>。如果按「全长包个数」计算，就是<code>cwnd</code>在每个RTT增加1。当「发现拥塞」的时候，拥塞避免阶段结束。</p>
<blockquote>
<p>实际中不好统计RTT。因此可以对于每个不重复的ACK，执行一次</p>
<p><code>cwnd</code> = <code>SMSS</code> * <code>SMSS</code> /
<code>cwnd</code></p>
</blockquote>
<h4 id="发现拥塞">「发现拥塞」</h4>
<p>当「超时重传」的现象出现，我们就认为拥塞发生了。这就是「发现拥塞」的方式。</p>
<p>当发现拥塞的时候，将<code>ssthresh</code>重新设置为以下值。</p>
<p><code>ssthresh</code> = max(<code>FlightSize</code> / 2, 2 *
<code>SMSS</code>)</p>
<blockquote>
<p>实际上是将发送窗口折半，但是至少可以发送两个包。如果传输速率受制于网络传输能力，那么其实就是把<code>ssthresh</code>设置为<code>cwnd</code>的一半。</p>
<p>但是为什么不能直接设置为<code>cwnd</code>的一半？标准说这样可能会使<code>ssthresh</code>超过<code>rwnd</code>。</p>
</blockquote>
<blockquote>
<p>Tanenbaum的教材中直接就说设为当前<code>cwnd</code>的一半。</p>
</blockquote>
<p>重设<code>ssthresh</code>之后，<code>cwnd</code>回到初始值重新进行慢开始。</p>
<h3 id="快速重传和快速恢复">快速重传和快速恢复</h3>
<p>引入这两个算法是为了加快收敛速度。</p>
<p>当接收方收到失序的报文段时，应立即回复一个“重复的ACK”，指明期望接收的序列号应该是多少。当失序的情况发生，意味着网络传输能力的不足。发送方通过观察重复的ACK，可以作出一些操作来控制拥塞。当然，网络错误也有可能造成重复ACK。</p>
<p>当发送端收到第三个重复的ACK时，按照之前发现拥塞的算法重设<code>ssthresh</code>（如果按照教材上的说法，就是折半<code>cwnd</code>）。然后立即重发可能丢失的包，不必等超时重传（这就是快速重传）。接下来，设置<code>cwnd</code>为<code>3*SMSS+ssthresh</code>（如果按照全长包来计算，就是<code>cwnd</code>设为<code>3+ssthresh</code>。</p>
<blockquote>
<p>为什么要人为使<code>cwnd</code>“膨胀”3？因为三个重复ACK意味着接收方收到了三个失序的包，或者说，有三个包实际上已经离开网络了。</p>
</blockquote>
<p>重传之后，每收到一个重复的ACK，<code>cwnd</code>就增加一个<code>SMSS</code>，或者从全长包个数的角度说，就是增加1。</p>
<blockquote>
<p>同上，意味着又有一个包离开网络了。</p>
</blockquote>
<p>收到下一个ACK的时候，进行一次“收缩”，将<code>cwnd</code>设为<code>ssthresh</code>（这就是快速恢复）。接下来因为<code>cwnd &gt;= ssthresh</code>，因此应该使用拥塞避免算法。</p>
<h2 id="tcp拥塞控制的表现">TCP拥塞控制的表现</h2>
<p>如果记录每个RTT传输的包数，将得到一张锯齿状的折线图。图片来自WikiCommons。</p>
<figure>
<img
src="../assets/img/post/TCP_Slow-Start_and_Congestion_Avoidance.svg"
alt="Illustration of TCP’s Congestion Avoidance based on this image. author: Fleshgrinder" />
<figcaption aria-hidden="true">Illustration of TCP’s Congestion
Avoidance based on this image. author: Fleshgrinder</figcaption>
</figure>
<h2 id="更多拥塞控制的方法">更多拥塞控制的方法</h2>
<ol type="1">
<li><p>引入SACK〔选择性ACK〕。允许声明哪些「区间」的字节已经收到。更有利于高效地重传</p></li>
<li><p>引入ECN〔显性拥塞通知〕。网络是否拥塞，网络层自己本身最清楚，ECN允许网络层给传输层反馈，直接告知拥塞情况。</p></li>
</ol>
<h2 id="参考资料">参考资料</h2>
<ol type="1">
<li><p>RFC 2851</p></li>
<li><p>Tanenbaum, A.S. and Wetherall, D.J: <em>Computer Networks 5th
edition</em></p></li>
</ol>

</div>

<div class="sibling-pages">
    
    <div class="sibling-page-arrow"><a href="//nth233.top/notes/jacobian_simple_proof.html">〈</a></div>
    <div class="sibling-page sibling-page-next">
        <div class="sibling-page-title"><a href="//nth233.top/notes/jacobian_simple_proof.html">Jacobian ...</a></div>
        <div class="sibling-page-date">2022-05-03</div>
    </div>
    
    
    <div class="sibling-page sibling-page-last">
        <div class="sibling-page-title"><a href="//nth233.top/notes/mathproblem1.html">一道积分：利用分部...</a></div>
        <div class="sibling-page-date">2022-04-16</div>
    </div>
    <div class="sibling-page-arrow"><a href="//nth233.top/notes/mathproblem1.html">〉</a></div>
    
</div>




    <script src="https://utteranc.es/client.js"
        repo="fpg2012/fpg2012.github.io"
        issue-term="pathname"
        label="Comment"
        theme="preferred-color-scheme"
        crossorigin="anonymous"
        async>
</script>


</div>

        </main>
        <footer>
<span>© nth233 2023 | <span class="theme-about">Powered by <a href="https://github.com/fpg2012/sushi">sushi</a> |  Theme <a href="https://github.com/fpg2012/sushi-theme-empty">empty</a> by <a href="https://github.com/fpg2012">nth233</a></span>
</footer>
        <div id="fullscreen-img-container" class="hidden">
        </div>
        <div id="top-button" onclick="window.scrollTo(0,0)">↥</div>
	<script src="//nth233.top/assets/js/fullscreen-img.js"></script>
    <script src="//nth233.top/assets/js/switch-theme.js"></script>
    
    </body>
</html>
